//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
"use strict";

const thrift = require('thrift');
const Thrift = thrift.Thrift;
const Int64 = require('node-int64');


const ttypes = require('./talk_types');
//HELPER FUNCTIONS AND STRUCTURES

const ChannelService_getDomains_args = class {
  constructor(args) {
    this.lastSynced = null;
    if (args) {
      if (args.lastSynced !== undefined && args.lastSynced !== null) {
        this.lastSynced = args.lastSynced;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.lastSynced = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getDomains_args');
    if (this.lastSynced !== null && this.lastSynced !== undefined) {
      output.writeFieldBegin('lastSynced', Thrift.Type.I64, 2);
      output.writeI64(this.lastSynced);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getDomains_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelDomains(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelDomains();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getDomains_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_approveChannelAndIssueRequestToken_args = class {
  constructor(args) {
    this.channelId = null;
    this.otpId = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.otpId !== undefined && args.otpId !== null) {
        this.otpId = args.otpId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.otpId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_approveChannelAndIssueRequestToken_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 1);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.otpId !== null && this.otpId !== undefined) {
      output.writeFieldBegin('otpId', Thrift.Type.STRING, 2);
      output.writeString(this.otpId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_approveChannelAndIssueRequestToken_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_approveChannelAndIssueRequestToken_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueOTP_args = class {
  constructor(args) {
    this.channelId = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueOTP_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 2);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueOTP_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.OTPResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.OTPResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueOTP_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannelSettings_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannelSettings_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannelSettings_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelSettings(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelSettings();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannelSettings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannelNotificationSettings_args = class {
  constructor(args) {
    this.locale = null;
    if (args) {
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannelNotificationSettings_args');
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 1);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannelNotificationSettings_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.ChannelNotificationSetting]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3789 = input.readListBegin();
          const _size788 = _rtmp3789.size || 0;
          for (let _i790 = 0; _i790 < _size788; ++_i790) {
            let elem791 = null;
            elem791 = new ttypes.ChannelNotificationSetting();
            elem791.read(input);
            this.success.push(elem791);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannelNotificationSettings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter792 in this.success) {
        if (this.success.hasOwnProperty(iter792)) {
          iter792 = this.success[iter792];
          iter792.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_updateChannelNotificationSetting_args = class {
  constructor(args) {
    this.setting = null;
    if (args) {
      if (args.setting !== undefined && args.setting !== null) {
        this.setting = Thrift.copyList(args.setting, [ttypes.ChannelNotificationSetting]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.setting = [];
          const _rtmp3794 = input.readListBegin();
          const _size793 = _rtmp3794.size || 0;
          for (let _i795 = 0; _i795 < _size793; ++_i795) {
            let elem796 = null;
            elem796 = new ttypes.ChannelNotificationSetting();
            elem796.read(input);
            this.setting.push(elem796);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_updateChannelNotificationSetting_args');
    if (this.setting !== null && this.setting !== undefined) {
      output.writeFieldBegin('setting', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.setting.length);
      for (let iter797 in this.setting) {
        if (this.setting.hasOwnProperty(iter797)) {
          iter797 = this.setting[iter797];
          iter797.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_updateChannelNotificationSetting_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_updateChannelNotificationSetting_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_updateChannelSettings_args = class {
  constructor(args) {
    this.channelSettings = null;
    if (args) {
      if (args.channelSettings !== undefined && args.channelSettings !== null) {
        this.channelSettings = new ttypes.ChannelSettings(args.channelSettings);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.channelSettings = new ttypes.ChannelSettings();
          this.channelSettings.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_updateChannelSettings_args');
    if (this.channelSettings !== null && this.channelSettings !== undefined) {
      output.writeFieldBegin('channelSettings', Thrift.Type.STRUCT, 1);
      this.channelSettings.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_updateChannelSettings_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_updateChannelSettings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getCommonDomains_args = class {
  constructor(args) {
    this.lastSynced = null;
    if (args) {
      if (args.lastSynced !== undefined && args.lastSynced !== null) {
        this.lastSynced = args.lastSynced;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.lastSynced = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getCommonDomains_args');
    if (this.lastSynced !== null && this.lastSynced !== undefined) {
      output.writeFieldBegin('lastSynced', Thrift.Type.I64, 1);
      output.writeI64(this.lastSynced);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getCommonDomains_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelDomains(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelDomains();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getCommonDomains_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueRequestTokenWithAuthScheme_args = class {
  constructor(args) {
    this.channelId = null;
    this.otpId = null;
    this.authScheme = null;
    this.returnUrl = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.otpId !== undefined && args.otpId !== null) {
        this.otpId = args.otpId;
      }
      if (args.authScheme !== undefined && args.authScheme !== null) {
        this.authScheme = Thrift.copyList(args.authScheme, [null]);
      }
      if (args.returnUrl !== undefined && args.returnUrl !== null) {
        this.returnUrl = args.returnUrl;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.otpId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.authScheme = [];
          const _rtmp3799 = input.readListBegin();
          const _size798 = _rtmp3799.size || 0;
          for (let _i800 = 0; _i800 < _size798; ++_i800) {
            let elem801 = null;
            elem801 = input.readString();
            this.authScheme.push(elem801);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.returnUrl = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueRequestTokenWithAuthScheme_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 1);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.otpId !== null && this.otpId !== undefined) {
      output.writeFieldBegin('otpId', Thrift.Type.STRING, 2);
      output.writeString(this.otpId);
      output.writeFieldEnd();
    }
    if (this.authScheme !== null && this.authScheme !== undefined) {
      output.writeFieldBegin('authScheme', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.authScheme.length);
      for (let iter802 in this.authScheme) {
        if (this.authScheme.hasOwnProperty(iter802)) {
          iter802 = this.authScheme[iter802];
          output.writeString(iter802);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.returnUrl !== null && this.returnUrl !== undefined) {
      output.writeFieldBegin('returnUrl', Thrift.Type.STRING, 4);
      output.writeString(this.returnUrl);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueRequestTokenWithAuthScheme_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.RequestTokenResponse(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.RequestTokenResponse();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueRequestTokenWithAuthScheme_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannelNotificationSetting_args = class {
  constructor(args) {
    this.channelId = null;
    this.locale = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannelNotificationSetting_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 1);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 2);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannelNotificationSetting_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelNotificationSetting(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelNotificationSetting();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannelNotificationSetting_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueChannelToken_args = class {
  constructor(args) {
    this.channelId = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueChannelToken_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 1);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueChannelToken_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelToken(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelToken();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueChannelToken_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannels_args = class {
  constructor(args) {
    this.lastSynced = null;
    this.locale = null;
    if (args) {
      if (args.lastSynced !== undefined && args.lastSynced !== null) {
        this.lastSynced = args.lastSynced;
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.lastSynced = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannels_args');
    if (this.lastSynced !== null && this.lastSynced !== undefined) {
      output.writeFieldBegin('lastSynced', Thrift.Type.I64, 2);
      output.writeI64(this.lastSynced);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 3);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannels_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelInfos(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelInfos();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannels_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_fetchNotificationItems_args = class {
  constructor(args) {
    this.localRev = null;
    if (args) {
      if (args.localRev !== undefined && args.localRev !== null) {
        this.localRev = args.localRev;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.localRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_fetchNotificationItems_args');
    if (this.localRev !== null && this.localRev !== undefined) {
      output.writeFieldBegin('localRev', Thrift.Type.I64, 2);
      output.writeI64(this.localRev);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_fetchNotificationItems_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.NotificationFetchResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.NotificationFetchResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_fetchNotificationItems_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannelInfo_args = class {
  constructor(args) {
    this.channelId = null;
    this.locale = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannelInfo_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 2);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 3);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getChannelInfo_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getChannelInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getNotificationBadgeCount_args = class {
  constructor(args) {
    this.localRev = null;
    if (args) {
      if (args.localRev !== undefined && args.localRev !== null) {
        this.localRev = args.localRev;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.localRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getNotificationBadgeCount_args');
    if (this.localRev !== null && this.localRev !== undefined) {
      output.writeFieldBegin('localRev', Thrift.Type.I64, 2);
      output.writeI64(this.localRev);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getNotificationBadgeCount_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getNotificationBadgeCount_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueRequestToken_args = class {
  constructor(args) {
    this.channelId = null;
    this.otpId = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.otpId !== undefined && args.otpId !== null) {
        this.otpId = args.otpId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.otpId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueRequestToken_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 1);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.otpId !== null && this.otpId !== undefined) {
      output.writeFieldBegin('otpId', Thrift.Type.STRING, 2);
      output.writeString(this.otpId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueRequestToken_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueRequestToken_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_revokeChannel_args = class {
  constructor(args) {
    this.channelId = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_revokeChannel_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 1);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_revokeChannel_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_revokeChannel_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getApprovedChannels_args = class {
  constructor(args) {
    this.lastSynced = null;
    this.locale = null;
    if (args) {
      if (args.lastSynced !== undefined && args.lastSynced !== null) {
        this.lastSynced = args.lastSynced;
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.lastSynced = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getApprovedChannels_args');
    if (this.lastSynced !== null && this.lastSynced !== undefined) {
      output.writeFieldBegin('lastSynced', Thrift.Type.I64, 2);
      output.writeI64(this.lastSynced);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 3);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getApprovedChannels_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ApprovedChannelInfos(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ApprovedChannelInfos();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getApprovedChannels_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getFriendChannelMatrices_args = class {
  constructor(args) {
    this.channelIds = null;
    if (args) {
      if (args.channelIds !== undefined && args.channelIds !== null) {
        this.channelIds = Thrift.copyList(args.channelIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.channelIds = [];
          const _rtmp3804 = input.readListBegin();
          const _size803 = _rtmp3804.size || 0;
          for (let _i805 = 0; _i805 < _size803; ++_i805) {
            let elem806 = null;
            elem806 = input.readString();
            this.channelIds.push(elem806);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getFriendChannelMatrices_args');
    if (this.channelIds !== null && this.channelIds !== undefined) {
      output.writeFieldBegin('channelIds', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRING, this.channelIds.length);
      for (let iter807 in this.channelIds) {
        if (this.channelIds.hasOwnProperty(iter807)) {
          iter807 = this.channelIds[iter807];
          output.writeString(iter807);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getFriendChannelMatrices_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.FriendChannelMatricesResponse(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.FriendChannelMatricesResponse();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getFriendChannelMatrices_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueRequestTokenForAutoLogin_args = class {
  constructor(args) {
    this.channelId = null;
    this.otpId = null;
    this.redirectUrl = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.otpId !== undefined && args.otpId !== null) {
        this.otpId = args.otpId;
      }
      if (args.redirectUrl !== undefined && args.redirectUrl !== null) {
        this.redirectUrl = args.redirectUrl;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.otpId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.redirectUrl = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueRequestTokenForAutoLogin_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 2);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.otpId !== null && this.otpId !== undefined) {
      output.writeFieldBegin('otpId', Thrift.Type.STRING, 3);
      output.writeString(this.otpId);
      output.writeFieldEnd();
    }
    if (this.redirectUrl !== null && this.redirectUrl !== undefined) {
      output.writeFieldBegin('redirectUrl', Thrift.Type.STRING, 4);
      output.writeString(this.redirectUrl);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_issueRequestTokenForAutoLogin_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_issueRequestTokenForAutoLogin_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getUpdatedChannelIds_args = class {
  constructor(args) {
    this.channelIds = null;
    if (args) {
      if (args.channelIds !== undefined && args.channelIds !== null) {
        this.channelIds = Thrift.copyList(args.channelIds, [ttypes.ChannelIdWithLastUpdated]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.channelIds = [];
          const _rtmp3809 = input.readListBegin();
          const _size808 = _rtmp3809.size || 0;
          for (let _i810 = 0; _i810 < _size808; ++_i810) {
            let elem811 = null;
            elem811 = new ttypes.ChannelIdWithLastUpdated();
            elem811.read(input);
            this.channelIds.push(elem811);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getUpdatedChannelIds_args');
    if (this.channelIds !== null && this.channelIds !== undefined) {
      output.writeFieldBegin('channelIds', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.channelIds.length);
      for (let iter812 in this.channelIds) {
        if (this.channelIds.hasOwnProperty(iter812)) {
          iter812 = this.channelIds[iter812];
          iter812.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_getUpdatedChannelIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3814 = input.readListBegin();
          const _size813 = _rtmp3814.size || 0;
          for (let _i815 = 0; _i815 < _size813; ++_i815) {
            let elem816 = null;
            elem816 = input.readString();
            this.success.push(elem816);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_getUpdatedChannelIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter817 in this.success) {
        if (this.success.hasOwnProperty(iter817)) {
          iter817 = this.success[iter817];
          output.writeString(iter817);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_reserveCoinUse_args = class {
  constructor(args) {
    this.request = null;
    this.locale = null;
    if (args) {
      if (args.request !== undefined && args.request !== null) {
        this.request = new ttypes.CoinUseReservation(args.request);
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.request = new ttypes.CoinUseReservation();
          this.request.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_reserveCoinUse_args');
    if (this.request !== null && this.request !== undefined) {
      output.writeFieldBegin('request', Thrift.Type.STRUCT, 2);
      this.request.write(output);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 3);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_reserveCoinUse_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_reserveCoinUse_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_syncChannelData_args = class {
  constructor(args) {
    this.lastSynced = null;
    this.locale = null;
    if (args) {
      if (args.lastSynced !== undefined && args.lastSynced !== null) {
        this.lastSynced = args.lastSynced;
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.lastSynced = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_syncChannelData_args');
    if (this.lastSynced !== null && this.lastSynced !== undefined) {
      output.writeFieldBegin('lastSynced', Thrift.Type.I64, 2);
      output.writeI64(this.lastSynced);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 3);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_syncChannelData_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelSyncDatas(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelSyncDatas();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_syncChannelData_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_approveChannelAndIssueChannelToken_args = class {
  constructor(args) {
    this.channelId = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_approveChannelAndIssueChannelToken_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 1);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelService_approveChannelAndIssueChannelToken_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ChannelException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ChannelToken(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ChannelToken();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ChannelException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChannelService_approveChannelAndIssueChannelToken_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const ChannelServiceClient = exports.Client = class {
  constructor(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this._seqid = 0;
    this._reqs = {};
  }
  seqid () { return this._seqid; }
  new_seqid () { return this._seqid += 1; }

  getDomains (lastSynced) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getDomains(lastSynced);
    });
  }

  send_getDomains (lastSynced) {
    const output = new this.pClass(this.output);
    const params = {
      lastSynced: lastSynced
    };
    const args = new ChannelService_getDomains_args(params);
    try {
      output.writeMessageBegin('getDomains', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getDomains (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getDomains_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getDomains failed: unknown result');
  }

  approveChannelAndIssueRequestToken (channelId, otpId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_approveChannelAndIssueRequestToken(channelId, otpId);
    });
  }

  send_approveChannelAndIssueRequestToken (channelId, otpId) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      otpId: otpId
    };
    const args = new ChannelService_approveChannelAndIssueRequestToken_args(params);
    try {
      output.writeMessageBegin('approveChannelAndIssueRequestToken', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_approveChannelAndIssueRequestToken (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_approveChannelAndIssueRequestToken_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('approveChannelAndIssueRequestToken failed: unknown result');
  }

  issueOTP (channelId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_issueOTP(channelId);
    });
  }

  send_issueOTP (channelId) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId
    };
    const args = new ChannelService_issueOTP_args(params);
    try {
      output.writeMessageBegin('issueOTP', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_issueOTP (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_issueOTP_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('issueOTP failed: unknown result');
  }

  getChannelSettings () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getChannelSettings();
    });
  }

  send_getChannelSettings () {
    const output = new this.pClass(this.output);
    const args = new ChannelService_getChannelSettings_args();
    try {
      output.writeMessageBegin('getChannelSettings', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getChannelSettings (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getChannelSettings_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getChannelSettings failed: unknown result');
  }

  getChannelNotificationSettings (locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getChannelNotificationSettings(locale);
    });
  }

  send_getChannelNotificationSettings (locale) {
    const output = new this.pClass(this.output);
    const params = {
      locale: locale
    };
    const args = new ChannelService_getChannelNotificationSettings_args(params);
    try {
      output.writeMessageBegin('getChannelNotificationSettings', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getChannelNotificationSettings (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getChannelNotificationSettings_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getChannelNotificationSettings failed: unknown result');
  }

  updateChannelNotificationSetting (setting) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateChannelNotificationSetting(setting);
    });
  }

  send_updateChannelNotificationSetting (setting) {
    const output = new this.pClass(this.output);
    const params = {
      setting: setting
    };
    const args = new ChannelService_updateChannelNotificationSetting_args(params);
    try {
      output.writeMessageBegin('updateChannelNotificationSetting', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateChannelNotificationSetting (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_updateChannelNotificationSetting_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  updateChannelSettings (channelSettings) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateChannelSettings(channelSettings);
    });
  }

  send_updateChannelSettings (channelSettings) {
    const output = new this.pClass(this.output);
    const params = {
      channelSettings: channelSettings
    };
    const args = new ChannelService_updateChannelSettings_args(params);
    try {
      output.writeMessageBegin('updateChannelSettings', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateChannelSettings (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_updateChannelSettings_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('updateChannelSettings failed: unknown result');
  }

  getCommonDomains (lastSynced) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getCommonDomains(lastSynced);
    });
  }

  send_getCommonDomains (lastSynced) {
    const output = new this.pClass(this.output);
    const params = {
      lastSynced: lastSynced
    };
    const args = new ChannelService_getCommonDomains_args(params);
    try {
      output.writeMessageBegin('getCommonDomains', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getCommonDomains (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getCommonDomains_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getCommonDomains failed: unknown result');
  }

  issueRequestTokenWithAuthScheme (channelId, otpId, authScheme, returnUrl) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_issueRequestTokenWithAuthScheme(channelId, otpId, authScheme, returnUrl);
    });
  }

  send_issueRequestTokenWithAuthScheme (channelId, otpId, authScheme, returnUrl) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      otpId: otpId,
      authScheme: authScheme,
      returnUrl: returnUrl
    };
    const args = new ChannelService_issueRequestTokenWithAuthScheme_args(params);
    try {
      output.writeMessageBegin('issueRequestTokenWithAuthScheme', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_issueRequestTokenWithAuthScheme (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_issueRequestTokenWithAuthScheme_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('issueRequestTokenWithAuthScheme failed: unknown result');
  }

  getChannelNotificationSetting (channelId, locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getChannelNotificationSetting(channelId, locale);
    });
  }

  send_getChannelNotificationSetting (channelId, locale) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      locale: locale
    };
    const args = new ChannelService_getChannelNotificationSetting_args(params);
    try {
      output.writeMessageBegin('getChannelNotificationSetting', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getChannelNotificationSetting (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getChannelNotificationSetting_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getChannelNotificationSetting failed: unknown result');
  }

  issueChannelToken (channelId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_issueChannelToken(channelId);
    });
  }

  send_issueChannelToken (channelId) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId
    };
    const args = new ChannelService_issueChannelToken_args(params);
    try {
      output.writeMessageBegin('issueChannelToken', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_issueChannelToken (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_issueChannelToken_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('issueChannelToken failed: unknown result');
  }

  getChannels (lastSynced, locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getChannels(lastSynced, locale);
    });
  }

  send_getChannels (lastSynced, locale) {
    const output = new this.pClass(this.output);
    const params = {
      lastSynced: lastSynced,
      locale: locale
    };
    const args = new ChannelService_getChannels_args(params);
    try {
      output.writeMessageBegin('getChannels', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getChannels (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getChannels_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getChannels failed: unknown result');
  }

  fetchNotificationItems (localRev) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_fetchNotificationItems(localRev);
    });
  }

  send_fetchNotificationItems (localRev) {
    const output = new this.pClass(this.output);
    const params = {
      localRev: localRev
    };
    const args = new ChannelService_fetchNotificationItems_args(params);
    try {
      output.writeMessageBegin('fetchNotificationItems', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_fetchNotificationItems (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_fetchNotificationItems_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('fetchNotificationItems failed: unknown result');
  }

  getChannelInfo (channelId, locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getChannelInfo(channelId, locale);
    });
  }

  send_getChannelInfo (channelId, locale) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      locale: locale
    };
    const args = new ChannelService_getChannelInfo_args(params);
    try {
      output.writeMessageBegin('getChannelInfo', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getChannelInfo (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getChannelInfo_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getChannelInfo failed: unknown result');
  }

  getNotificationBadgeCount (localRev) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getNotificationBadgeCount(localRev);
    });
  }

  send_getNotificationBadgeCount (localRev) {
    const output = new this.pClass(this.output);
    const params = {
      localRev: localRev
    };
    const args = new ChannelService_getNotificationBadgeCount_args(params);
    try {
      output.writeMessageBegin('getNotificationBadgeCount', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getNotificationBadgeCount (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getNotificationBadgeCount_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getNotificationBadgeCount failed: unknown result');
  }

  issueRequestToken (channelId, otpId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_issueRequestToken(channelId, otpId);
    });
  }

  send_issueRequestToken (channelId, otpId) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      otpId: otpId
    };
    const args = new ChannelService_issueRequestToken_args(params);
    try {
      output.writeMessageBegin('issueRequestToken', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_issueRequestToken (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_issueRequestToken_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('issueRequestToken failed: unknown result');
  }

  revokeChannel (channelId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_revokeChannel(channelId);
    });
  }

  send_revokeChannel (channelId) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId
    };
    const args = new ChannelService_revokeChannel_args(params);
    try {
      output.writeMessageBegin('revokeChannel', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_revokeChannel (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_revokeChannel_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getApprovedChannels (lastSynced, locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getApprovedChannels(lastSynced, locale);
    });
  }

  send_getApprovedChannels (lastSynced, locale) {
    const output = new this.pClass(this.output);
    const params = {
      lastSynced: lastSynced,
      locale: locale
    };
    const args = new ChannelService_getApprovedChannels_args(params);
    try {
      output.writeMessageBegin('getApprovedChannels', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getApprovedChannels (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getApprovedChannels_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getApprovedChannels failed: unknown result');
  }

  getFriendChannelMatrices (channelIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getFriendChannelMatrices(channelIds);
    });
  }

  send_getFriendChannelMatrices (channelIds) {
    const output = new this.pClass(this.output);
    const params = {
      channelIds: channelIds
    };
    const args = new ChannelService_getFriendChannelMatrices_args(params);
    try {
      output.writeMessageBegin('getFriendChannelMatrices', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getFriendChannelMatrices (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getFriendChannelMatrices_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getFriendChannelMatrices failed: unknown result');
  }

  issueRequestTokenForAutoLogin (channelId, otpId, redirectUrl) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_issueRequestTokenForAutoLogin(channelId, otpId, redirectUrl);
    });
  }

  send_issueRequestTokenForAutoLogin (channelId, otpId, redirectUrl) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      otpId: otpId,
      redirectUrl: redirectUrl
    };
    const args = new ChannelService_issueRequestTokenForAutoLogin_args(params);
    try {
      output.writeMessageBegin('issueRequestTokenForAutoLogin', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_issueRequestTokenForAutoLogin (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_issueRequestTokenForAutoLogin_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('issueRequestTokenForAutoLogin failed: unknown result');
  }

  getUpdatedChannelIds (channelIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getUpdatedChannelIds(channelIds);
    });
  }

  send_getUpdatedChannelIds (channelIds) {
    const output = new this.pClass(this.output);
    const params = {
      channelIds: channelIds
    };
    const args = new ChannelService_getUpdatedChannelIds_args(params);
    try {
      output.writeMessageBegin('getUpdatedChannelIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getUpdatedChannelIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_getUpdatedChannelIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getUpdatedChannelIds failed: unknown result');
  }

  reserveCoinUse (request, locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reserveCoinUse(request, locale);
    });
  }

  send_reserveCoinUse (request, locale) {
    const output = new this.pClass(this.output);
    const params = {
      request: request,
      locale: locale
    };
    const args = new ChannelService_reserveCoinUse_args(params);
    try {
      output.writeMessageBegin('reserveCoinUse', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reserveCoinUse (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_reserveCoinUse_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('reserveCoinUse failed: unknown result');
  }

  syncChannelData (lastSynced, locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_syncChannelData(lastSynced, locale);
    });
  }

  send_syncChannelData (lastSynced, locale) {
    const output = new this.pClass(this.output);
    const params = {
      lastSynced: lastSynced,
      locale: locale
    };
    const args = new ChannelService_syncChannelData_args(params);
    try {
      output.writeMessageBegin('syncChannelData', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_syncChannelData (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_syncChannelData_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('syncChannelData failed: unknown result');
  }

  approveChannelAndIssueChannelToken (channelId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_approveChannelAndIssueChannelToken(channelId);
    });
  }

  send_approveChannelAndIssueChannelToken (channelId) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId
    };
    const args = new ChannelService_approveChannelAndIssueChannelToken_args(params);
    try {
      output.writeMessageBegin('approveChannelAndIssueChannelToken', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_approveChannelAndIssueChannelToken (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new ChannelService_approveChannelAndIssueChannelToken_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('approveChannelAndIssueChannelToken failed: unknown result');
  }
};
const ChannelServiceProcessor = exports.Processor = class {
  constructor(handler) {
    this._handler = handler;
  }
  process (input, output) {
    const r = input.readMessageBegin();
    if (this['process_' + r.fname]) {
      return this['process_' + r.fname].call(this, r.rseqid, input, output);
    } else {
      input.skip(Thrift.Type.STRUCT);
      input.readMessageEnd();
      const x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname);
      output.writeMessageBegin(r.fname, Thrift.MessageType.EXCEPTION, r.rseqid);
      x.write(output);
      output.writeMessageEnd();
      output.flush();
    }
  }
  process_getDomains (seqid, input, output) {
    const args = new ChannelService_getDomains_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getDomains.length === 1) {
      Promise.resolve(this._handler.getDomains.bind(this._handler)(
        args.lastSynced
      )).then(result => {
        const result_obj = new ChannelService_getDomains_result({success: result});
        output.writeMessageBegin("getDomains", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getDomains_result(err);
          output.writeMessageBegin("getDomains", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getDomains", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getDomains(args.lastSynced, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getDomains_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getDomains", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getDomains", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_approveChannelAndIssueRequestToken (seqid, input, output) {
    const args = new ChannelService_approveChannelAndIssueRequestToken_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.approveChannelAndIssueRequestToken.length === 2) {
      Promise.resolve(this._handler.approveChannelAndIssueRequestToken.bind(this._handler)(
        args.channelId,
        args.otpId
      )).then(result => {
        const result_obj = new ChannelService_approveChannelAndIssueRequestToken_result({success: result});
        output.writeMessageBegin("approveChannelAndIssueRequestToken", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_approveChannelAndIssueRequestToken_result(err);
          output.writeMessageBegin("approveChannelAndIssueRequestToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("approveChannelAndIssueRequestToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.approveChannelAndIssueRequestToken(args.channelId, args.otpId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_approveChannelAndIssueRequestToken_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("approveChannelAndIssueRequestToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("approveChannelAndIssueRequestToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_issueOTP (seqid, input, output) {
    const args = new ChannelService_issueOTP_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.issueOTP.length === 1) {
      Promise.resolve(this._handler.issueOTP.bind(this._handler)(
        args.channelId
      )).then(result => {
        const result_obj = new ChannelService_issueOTP_result({success: result});
        output.writeMessageBegin("issueOTP", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_issueOTP_result(err);
          output.writeMessageBegin("issueOTP", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueOTP", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.issueOTP(args.channelId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_issueOTP_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("issueOTP", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueOTP", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getChannelSettings (seqid, input, output) {
    const args = new ChannelService_getChannelSettings_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getChannelSettings.length === 0) {
      Promise.resolve(this._handler.getChannelSettings.bind(this._handler)(
      )).then(result => {
        const result_obj = new ChannelService_getChannelSettings_result({success: result});
        output.writeMessageBegin("getChannelSettings", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getChannelSettings_result(err);
          output.writeMessageBegin("getChannelSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannelSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getChannelSettings((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getChannelSettings_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getChannelSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannelSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getChannelNotificationSettings (seqid, input, output) {
    const args = new ChannelService_getChannelNotificationSettings_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getChannelNotificationSettings.length === 1) {
      Promise.resolve(this._handler.getChannelNotificationSettings.bind(this._handler)(
        args.locale
      )).then(result => {
        const result_obj = new ChannelService_getChannelNotificationSettings_result({success: result});
        output.writeMessageBegin("getChannelNotificationSettings", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getChannelNotificationSettings_result(err);
          output.writeMessageBegin("getChannelNotificationSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannelNotificationSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getChannelNotificationSettings(args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getChannelNotificationSettings_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getChannelNotificationSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannelNotificationSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateChannelNotificationSetting (seqid, input, output) {
    const args = new ChannelService_updateChannelNotificationSetting_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateChannelNotificationSetting.length === 1) {
      Promise.resolve(this._handler.updateChannelNotificationSetting.bind(this._handler)(
        args.setting
      )).then(result => {
        const result_obj = new ChannelService_updateChannelNotificationSetting_result({success: result});
        output.writeMessageBegin("updateChannelNotificationSetting", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_updateChannelNotificationSetting_result(err);
          output.writeMessageBegin("updateChannelNotificationSetting", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateChannelNotificationSetting", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateChannelNotificationSetting(args.setting, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_updateChannelNotificationSetting_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateChannelNotificationSetting", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateChannelNotificationSetting", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateChannelSettings (seqid, input, output) {
    const args = new ChannelService_updateChannelSettings_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateChannelSettings.length === 1) {
      Promise.resolve(this._handler.updateChannelSettings.bind(this._handler)(
        args.channelSettings
      )).then(result => {
        const result_obj = new ChannelService_updateChannelSettings_result({success: result});
        output.writeMessageBegin("updateChannelSettings", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_updateChannelSettings_result(err);
          output.writeMessageBegin("updateChannelSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateChannelSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateChannelSettings(args.channelSettings, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_updateChannelSettings_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateChannelSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateChannelSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getCommonDomains (seqid, input, output) {
    const args = new ChannelService_getCommonDomains_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getCommonDomains.length === 1) {
      Promise.resolve(this._handler.getCommonDomains.bind(this._handler)(
        args.lastSynced
      )).then(result => {
        const result_obj = new ChannelService_getCommonDomains_result({success: result});
        output.writeMessageBegin("getCommonDomains", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getCommonDomains_result(err);
          output.writeMessageBegin("getCommonDomains", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCommonDomains", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getCommonDomains(args.lastSynced, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getCommonDomains_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getCommonDomains", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCommonDomains", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_issueRequestTokenWithAuthScheme (seqid, input, output) {
    const args = new ChannelService_issueRequestTokenWithAuthScheme_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.issueRequestTokenWithAuthScheme.length === 4) {
      Promise.resolve(this._handler.issueRequestTokenWithAuthScheme.bind(this._handler)(
        args.channelId,
        args.otpId,
        args.authScheme,
        args.returnUrl
      )).then(result => {
        const result_obj = new ChannelService_issueRequestTokenWithAuthScheme_result({success: result});
        output.writeMessageBegin("issueRequestTokenWithAuthScheme", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_issueRequestTokenWithAuthScheme_result(err);
          output.writeMessageBegin("issueRequestTokenWithAuthScheme", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueRequestTokenWithAuthScheme", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.issueRequestTokenWithAuthScheme(args.channelId, args.otpId, args.authScheme, args.returnUrl, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_issueRequestTokenWithAuthScheme_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("issueRequestTokenWithAuthScheme", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueRequestTokenWithAuthScheme", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getChannelNotificationSetting (seqid, input, output) {
    const args = new ChannelService_getChannelNotificationSetting_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getChannelNotificationSetting.length === 2) {
      Promise.resolve(this._handler.getChannelNotificationSetting.bind(this._handler)(
        args.channelId,
        args.locale
      )).then(result => {
        const result_obj = new ChannelService_getChannelNotificationSetting_result({success: result});
        output.writeMessageBegin("getChannelNotificationSetting", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getChannelNotificationSetting_result(err);
          output.writeMessageBegin("getChannelNotificationSetting", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannelNotificationSetting", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getChannelNotificationSetting(args.channelId, args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getChannelNotificationSetting_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getChannelNotificationSetting", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannelNotificationSetting", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_issueChannelToken (seqid, input, output) {
    const args = new ChannelService_issueChannelToken_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.issueChannelToken.length === 1) {
      Promise.resolve(this._handler.issueChannelToken.bind(this._handler)(
        args.channelId
      )).then(result => {
        const result_obj = new ChannelService_issueChannelToken_result({success: result});
        output.writeMessageBegin("issueChannelToken", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_issueChannelToken_result(err);
          output.writeMessageBegin("issueChannelToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueChannelToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.issueChannelToken(args.channelId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_issueChannelToken_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("issueChannelToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueChannelToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getChannels (seqid, input, output) {
    const args = new ChannelService_getChannels_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getChannels.length === 2) {
      Promise.resolve(this._handler.getChannels.bind(this._handler)(
        args.lastSynced,
        args.locale
      )).then(result => {
        const result_obj = new ChannelService_getChannels_result({success: result});
        output.writeMessageBegin("getChannels", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getChannels_result(err);
          output.writeMessageBegin("getChannels", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannels", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getChannels(args.lastSynced, args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getChannels_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getChannels", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannels", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_fetchNotificationItems (seqid, input, output) {
    const args = new ChannelService_fetchNotificationItems_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.fetchNotificationItems.length === 1) {
      Promise.resolve(this._handler.fetchNotificationItems.bind(this._handler)(
        args.localRev
      )).then(result => {
        const result_obj = new ChannelService_fetchNotificationItems_result({success: result});
        output.writeMessageBegin("fetchNotificationItems", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_fetchNotificationItems_result(err);
          output.writeMessageBegin("fetchNotificationItems", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("fetchNotificationItems", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.fetchNotificationItems(args.localRev, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_fetchNotificationItems_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("fetchNotificationItems", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("fetchNotificationItems", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getChannelInfo (seqid, input, output) {
    const args = new ChannelService_getChannelInfo_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getChannelInfo.length === 2) {
      Promise.resolve(this._handler.getChannelInfo.bind(this._handler)(
        args.channelId,
        args.locale
      )).then(result => {
        const result_obj = new ChannelService_getChannelInfo_result({success: result});
        output.writeMessageBegin("getChannelInfo", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getChannelInfo_result(err);
          output.writeMessageBegin("getChannelInfo", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannelInfo", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getChannelInfo(args.channelId, args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getChannelInfo_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getChannelInfo", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getChannelInfo", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getNotificationBadgeCount (seqid, input, output) {
    const args = new ChannelService_getNotificationBadgeCount_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getNotificationBadgeCount.length === 1) {
      Promise.resolve(this._handler.getNotificationBadgeCount.bind(this._handler)(
        args.localRev
      )).then(result => {
        const result_obj = new ChannelService_getNotificationBadgeCount_result({success: result});
        output.writeMessageBegin("getNotificationBadgeCount", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getNotificationBadgeCount_result(err);
          output.writeMessageBegin("getNotificationBadgeCount", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getNotificationBadgeCount", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getNotificationBadgeCount(args.localRev, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getNotificationBadgeCount_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getNotificationBadgeCount", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getNotificationBadgeCount", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_issueRequestToken (seqid, input, output) {
    const args = new ChannelService_issueRequestToken_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.issueRequestToken.length === 2) {
      Promise.resolve(this._handler.issueRequestToken.bind(this._handler)(
        args.channelId,
        args.otpId
      )).then(result => {
        const result_obj = new ChannelService_issueRequestToken_result({success: result});
        output.writeMessageBegin("issueRequestToken", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_issueRequestToken_result(err);
          output.writeMessageBegin("issueRequestToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueRequestToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.issueRequestToken(args.channelId, args.otpId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_issueRequestToken_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("issueRequestToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueRequestToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_revokeChannel (seqid, input, output) {
    const args = new ChannelService_revokeChannel_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.revokeChannel.length === 1) {
      Promise.resolve(this._handler.revokeChannel.bind(this._handler)(
        args.channelId
      )).then(result => {
        const result_obj = new ChannelService_revokeChannel_result({success: result});
        output.writeMessageBegin("revokeChannel", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_revokeChannel_result(err);
          output.writeMessageBegin("revokeChannel", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("revokeChannel", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.revokeChannel(args.channelId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_revokeChannel_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("revokeChannel", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("revokeChannel", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getApprovedChannels (seqid, input, output) {
    const args = new ChannelService_getApprovedChannels_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getApprovedChannels.length === 2) {
      Promise.resolve(this._handler.getApprovedChannels.bind(this._handler)(
        args.lastSynced,
        args.locale
      )).then(result => {
        const result_obj = new ChannelService_getApprovedChannels_result({success: result});
        output.writeMessageBegin("getApprovedChannels", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getApprovedChannels_result(err);
          output.writeMessageBegin("getApprovedChannels", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getApprovedChannels", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getApprovedChannels(args.lastSynced, args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getApprovedChannels_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getApprovedChannels", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getApprovedChannels", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getFriendChannelMatrices (seqid, input, output) {
    const args = new ChannelService_getFriendChannelMatrices_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getFriendChannelMatrices.length === 1) {
      Promise.resolve(this._handler.getFriendChannelMatrices.bind(this._handler)(
        args.channelIds
      )).then(result => {
        const result_obj = new ChannelService_getFriendChannelMatrices_result({success: result});
        output.writeMessageBegin("getFriendChannelMatrices", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getFriendChannelMatrices_result(err);
          output.writeMessageBegin("getFriendChannelMatrices", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getFriendChannelMatrices", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getFriendChannelMatrices(args.channelIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getFriendChannelMatrices_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getFriendChannelMatrices", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getFriendChannelMatrices", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_issueRequestTokenForAutoLogin (seqid, input, output) {
    const args = new ChannelService_issueRequestTokenForAutoLogin_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.issueRequestTokenForAutoLogin.length === 3) {
      Promise.resolve(this._handler.issueRequestTokenForAutoLogin.bind(this._handler)(
        args.channelId,
        args.otpId,
        args.redirectUrl
      )).then(result => {
        const result_obj = new ChannelService_issueRequestTokenForAutoLogin_result({success: result});
        output.writeMessageBegin("issueRequestTokenForAutoLogin", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_issueRequestTokenForAutoLogin_result(err);
          output.writeMessageBegin("issueRequestTokenForAutoLogin", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueRequestTokenForAutoLogin", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.issueRequestTokenForAutoLogin(args.channelId, args.otpId, args.redirectUrl, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_issueRequestTokenForAutoLogin_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("issueRequestTokenForAutoLogin", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("issueRequestTokenForAutoLogin", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getUpdatedChannelIds (seqid, input, output) {
    const args = new ChannelService_getUpdatedChannelIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getUpdatedChannelIds.length === 1) {
      Promise.resolve(this._handler.getUpdatedChannelIds.bind(this._handler)(
        args.channelIds
      )).then(result => {
        const result_obj = new ChannelService_getUpdatedChannelIds_result({success: result});
        output.writeMessageBegin("getUpdatedChannelIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_getUpdatedChannelIds_result(err);
          output.writeMessageBegin("getUpdatedChannelIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getUpdatedChannelIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getUpdatedChannelIds(args.channelIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_getUpdatedChannelIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getUpdatedChannelIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getUpdatedChannelIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reserveCoinUse (seqid, input, output) {
    const args = new ChannelService_reserveCoinUse_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reserveCoinUse.length === 2) {
      Promise.resolve(this._handler.reserveCoinUse.bind(this._handler)(
        args.request,
        args.locale
      )).then(result => {
        const result_obj = new ChannelService_reserveCoinUse_result({success: result});
        output.writeMessageBegin("reserveCoinUse", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_reserveCoinUse_result(err);
          output.writeMessageBegin("reserveCoinUse", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reserveCoinUse", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reserveCoinUse(args.request, args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_reserveCoinUse_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reserveCoinUse", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reserveCoinUse", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_syncChannelData (seqid, input, output) {
    const args = new ChannelService_syncChannelData_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.syncChannelData.length === 2) {
      Promise.resolve(this._handler.syncChannelData.bind(this._handler)(
        args.lastSynced,
        args.locale
      )).then(result => {
        const result_obj = new ChannelService_syncChannelData_result({success: result});
        output.writeMessageBegin("syncChannelData", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_syncChannelData_result(err);
          output.writeMessageBegin("syncChannelData", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("syncChannelData", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.syncChannelData(args.lastSynced, args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_syncChannelData_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("syncChannelData", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("syncChannelData", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_approveChannelAndIssueChannelToken (seqid, input, output) {
    const args = new ChannelService_approveChannelAndIssueChannelToken_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.approveChannelAndIssueChannelToken.length === 1) {
      Promise.resolve(this._handler.approveChannelAndIssueChannelToken.bind(this._handler)(
        args.channelId
      )).then(result => {
        const result_obj = new ChannelService_approveChannelAndIssueChannelToken_result({success: result});
        output.writeMessageBegin("approveChannelAndIssueChannelToken", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ChannelException) {
          result = new ChannelService_approveChannelAndIssueChannelToken_result(err);
          output.writeMessageBegin("approveChannelAndIssueChannelToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("approveChannelAndIssueChannelToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.approveChannelAndIssueChannelToken(args.channelId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ChannelException) {
          result_obj = new ChannelService_approveChannelAndIssueChannelToken_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("approveChannelAndIssueChannelToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("approveChannelAndIssueChannelToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
};
