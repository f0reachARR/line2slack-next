//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
"use strict";

const thrift = require('thrift');
const Thrift = thrift.Thrift;
const Int64 = require('node-int64');


const ttypes = require('./talk_types');
//HELPER FUNCTIONS AND STRUCTURES

const TalkService_reportDeviceState_args = class {
  constructor(args) {
    this.booleanState = null;
    this.stringState = null;
    if (args) {
      if (args.booleanState !== undefined && args.booleanState !== null) {
        this.booleanState = Thrift.copyMap(args.booleanState, [null]);
      }
      if (args.stringState !== undefined && args.stringState !== null) {
        this.stringState = Thrift.copyMap(args.stringState, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.booleanState = {};
          const _rtmp3819 = input.readMapBegin();
          const _size818 = _rtmp3819.size || 0;
          for (let _i820 = 0; _i820 < _size818; ++_i820) {
            let key821 = null;
            let val822 = null;
            key821 = input.readI32();
            val822 = input.readBool();
            this.booleanState[key821] = val822;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.stringState = {};
          const _rtmp3824 = input.readMapBegin();
          const _size823 = _rtmp3824.size || 0;
          for (let _i825 = 0; _i825 < _size823; ++_i825) {
            let key826 = null;
            let val827 = null;
            key826 = input.readI32();
            val827 = input.readString();
            this.stringState[key826] = val827;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportDeviceState_args');
    if (this.booleanState !== null && this.booleanState !== undefined) {
      output.writeFieldBegin('booleanState', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.BOOL, Thrift.objectLength(this.booleanState));
      for (let kiter828 in this.booleanState) {
        if (this.booleanState.hasOwnProperty(kiter828)) {
          let viter829 = this.booleanState[kiter828];
          output.writeI32(kiter828);
          output.writeBool(viter829);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.stringState !== null && this.stringState !== undefined) {
      output.writeFieldBegin('stringState', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRING, Thrift.objectLength(this.stringState));
      for (let kiter830 in this.stringState) {
        if (this.stringState.hasOwnProperty(kiter830)) {
          let viter831 = this.stringState[kiter830];
          output.writeI32(kiter830);
          output.writeString(viter831);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportDeviceState_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportDeviceState_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifySleepV2_args = class {
  constructor(args) {
    this.lastStatusMap = null;
    if (args) {
      if (args.lastStatusMap !== undefined && args.lastStatusMap !== null) {
        this.lastStatusMap = Thrift.copyMap(args.lastStatusMap, [ttypes.ClientLastStatus]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.lastStatusMap = {};
          const _rtmp3833 = input.readMapBegin();
          const _size832 = _rtmp3833.size || 0;
          for (let _i834 = 0; _i834 < _size832; ++_i834) {
            let key835 = null;
            let val836 = null;
            key835 = input.readI32();
            val836 = new ttypes.ClientLastStatus();
            val836.read(input);
            this.lastStatusMap[key835] = val836;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifySleepV2_args');
    if (this.lastStatusMap !== null && this.lastStatusMap !== undefined) {
      output.writeFieldBegin('lastStatusMap', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRUCT, Thrift.objectLength(this.lastStatusMap));
      for (let kiter837 in this.lastStatusMap) {
        if (this.lastStatusMap.hasOwnProperty(kiter837)) {
          let viter838 = this.lastStatusMap[kiter837];
          output.writeI32(kiter837);
          viter838.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifySleepV2_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifySleepV2_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateNotificationToken_args = class {
  constructor(args) {
    this.token = null;
    this.type = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateNotificationToken_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 2);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateNotificationToken_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateNotificationToken_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateGroup_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.group = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.group !== undefined && args.group !== null) {
        this.group = new ttypes.Group(args.group);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.group = new ttypes.Group();
          this.group.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateGroup_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.group !== null && this.group !== undefined) {
      output.writeFieldBegin('group', Thrift.Type.STRUCT, 2);
      this.group.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateGroup_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateGroup_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyAccountMigrationPincode_args = class {
  constructor(args) {
    this.migrationPincodeSessionId = null;
    this.accountMigrationPincode = null;
    if (args) {
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
      if (args.accountMigrationPincode !== undefined && args.accountMigrationPincode !== null) {
        this.accountMigrationPincode = args.accountMigrationPincode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountMigrationPincode = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyAccountMigrationPincode_args');
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 2);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    if (this.accountMigrationPincode !== null && this.accountMigrationPincode !== undefined) {
      output.writeFieldBegin('accountMigrationPincode', Thrift.Type.STRING, 3);
      output.writeString(this.accountMigrationPincode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyAccountMigrationPincode_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyAccountMigrationPincode_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithExistingSnsIdAndIdentityCredential_args = class {
  constructor(args) {
    this.identityCredential = null;
    this.region = null;
    this.udidHash = null;
    this.deviceInfo = null;
    this.migrationPincodeSessionId = null;
    if (args) {
      if (args.identityCredential !== undefined && args.identityCredential !== null) {
        this.identityCredential = new ttypes.IdentityCredential(args.identityCredential);
      }
      if (args.region !== undefined && args.region !== null) {
        this.region = args.region;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.identityCredential = new ttypes.IdentityCredential();
          this.identityCredential.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithExistingSnsIdAndIdentityCredential_args');
    if (this.identityCredential !== null && this.identityCredential !== undefined) {
      output.writeFieldBegin('identityCredential', Thrift.Type.STRUCT, 2);
      this.identityCredential.write(output);
      output.writeFieldEnd();
    }
    if (this.region !== null && this.region !== undefined) {
      output.writeFieldBegin('region', Thrift.Type.STRING, 3);
      output.writeString(this.region);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 4);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 5);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 6);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithExistingSnsIdAndIdentityCredential_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithExistingSnsIdAndIdentityCredential_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerDeviceWithoutPhoneNumber_args = class {
  constructor(args) {
    this.region = null;
    this.udidHash = null;
    this.deviceInfo = null;
    if (args) {
      if (args.region !== undefined && args.region !== null) {
        this.region = args.region;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerDeviceWithoutPhoneNumber_args');
    if (this.region !== null && this.region !== undefined) {
      output.writeFieldBegin('region', Thrift.Type.STRING, 2);
      output.writeString(this.region);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 3);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 4);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerDeviceWithoutPhoneNumber_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerDeviceWithoutPhoneNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_changeVerificationMethod_args = class {
  constructor(args) {
    this.sessionId = null;
    this.method = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.method !== undefined && args.method !== null) {
        this.method = args.method;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.method = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_changeVerificationMethod_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.method !== null && this.method !== undefined) {
      output.writeFieldBegin('method', Thrift.Type.I32, 3);
      output.writeI32(this.method);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_changeVerificationMethod_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.VerificationSessionData(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.VerificationSessionData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_changeVerificationMethod_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_setBuddyLocation_args = class {
  constructor(args) {
    this.mid = null;
    this.index = null;
    this.location = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.index !== undefined && args.index !== null) {
        this.index = args.index;
      }
      if (args.location !== undefined && args.location !== null) {
        this.location = new ttypes.Geolocation(args.location);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.index = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.location = new ttypes.Geolocation();
          this.location.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_setBuddyLocation_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.index !== null && this.index !== undefined) {
      output.writeFieldBegin('index', Thrift.Type.I32, 3);
      output.writeI32(this.index);
      output.writeFieldEnd();
    }
    if (this.location !== null && this.location !== undefined) {
      output.writeFieldBegin('location', Thrift.Type.STRUCT, 4);
      this.location.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_setBuddyLocation_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_setBuddyLocation_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getFriendRequests_args = class {
  constructor(args) {
    this.direction = null;
    this.lastSeenSeqId = null;
    if (args) {
      if (args.direction !== undefined && args.direction !== null) {
        this.direction = args.direction;
      }
      if (args.lastSeenSeqId !== undefined && args.lastSeenSeqId !== null) {
        this.lastSeenSeqId = args.lastSeenSeqId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.direction = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.lastSeenSeqId = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getFriendRequests_args');
    if (this.direction !== null && this.direction !== undefined) {
      output.writeFieldBegin('direction', Thrift.Type.I32, 1);
      output.writeI32(this.direction);
      output.writeFieldEnd();
    }
    if (this.lastSeenSeqId !== null && this.lastSeenSeqId !== undefined) {
      output.writeFieldBegin('lastSeenSeqId', Thrift.Type.I64, 2);
      output.writeI64(this.lastSeenSeqId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getFriendRequests_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.FriendRequest]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3840 = input.readListBegin();
          const _size839 = _rtmp3840.size || 0;
          for (let _i841 = 0; _i841 < _size839; ++_i841) {
            let elem842 = null;
            elem842 = new ttypes.FriendRequest();
            elem842.read(input);
            this.success.push(elem842);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getFriendRequests_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter843 in this.success) {
        if (this.success.hasOwnProperty(iter843)) {
          iter843 = this.success[iter843];
          iter843.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_kickoutFromGroup_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.groupId = null;
    this.contactIds = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
      if (args.contactIds !== undefined && args.contactIds !== null) {
        this.contactIds = Thrift.copyList(args.contactIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.contactIds = [];
          const _rtmp3845 = input.readListBegin();
          const _size844 = _rtmp3845.size || 0;
          for (let _i846 = 0; _i846 < _size844; ++_i846) {
            let elem847 = null;
            elem847 = input.readString();
            this.contactIds.push(elem847);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_kickoutFromGroup_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    if (this.contactIds !== null && this.contactIds !== undefined) {
      output.writeFieldBegin('contactIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.contactIds.length);
      for (let iter848 in this.contactIds) {
        if (this.contactIds.hasOwnProperty(iter848)) {
          iter848 = this.contactIds[iter848];
          output.writeString(iter848);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_kickoutFromGroup_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_kickoutFromGroup_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyIdentityCredentialWithResult_args = class {
  constructor(args) {
    this.identityCredential = null;
    this.migrationPincodeSessionId = null;
    if (args) {
      if (args.identityCredential !== undefined && args.identityCredential !== null) {
        this.identityCredential = new ttypes.IdentityCredential(args.identityCredential);
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.identityCredential = new ttypes.IdentityCredential();
          this.identityCredential.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyIdentityCredentialWithResult_args');
    if (this.identityCredential !== null && this.identityCredential !== undefined) {
      output.writeFieldBegin('identityCredential', Thrift.Type.STRUCT, 2);
      this.identityCredential.write(output);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 3);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyIdentityCredentialWithResult_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.UserAuthStatus(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.UserAuthStatus();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyIdentityCredentialWithResult_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendEchoPush_args = class {
  constructor(args) {
    this.text = null;
    if (args) {
      if (args.text !== undefined && args.text !== null) {
        this.text = args.text;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.text = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendEchoPush_args');
    if (this.text !== null && this.text !== undefined) {
      output.writeFieldBegin('text', Thrift.Type.STRING, 2);
      output.writeString(this.text);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendEchoPush_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendEchoPush_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createSession_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createSession_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createSession_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createSession_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reissueDeviceCredential_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reissueDeviceCredential_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reissueDeviceCredential_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reissueDeviceCredential_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRecommendationIds_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRecommendationIds_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRecommendationIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3850 = input.readListBegin();
          const _size849 = _rtmp3850.size || 0;
          for (let _i851 = 0; _i851 < _size849; ++_i851) {
            let elem852 = null;
            elem852 = input.readString();
            this.success.push(elem852);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRecommendationIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter853 in this.success) {
        if (this.success.hasOwnProperty(iter853)) {
          iter853 = this.success[iter853];
          output.writeString(iter853);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_inviteViaEmail_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.email = null;
    this.name = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.email !== undefined && args.email !== null) {
        this.email = args.email;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.email = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_inviteViaEmail_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.email !== null && this.email !== undefined) {
      output.writeFieldBegin('email', Thrift.Type.STRING, 2);
      output.writeString(this.email);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 3);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_inviteViaEmail_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_inviteViaEmail_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRoomsV2_args = class {
  constructor(args) {
    this.roomIds = null;
    if (args) {
      if (args.roomIds !== undefined && args.roomIds !== null) {
        this.roomIds = Thrift.copyList(args.roomIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.roomIds = [];
          const _rtmp3855 = input.readListBegin();
          const _size854 = _rtmp3855.size || 0;
          for (let _i856 = 0; _i856 < _size854; ++_i856) {
            let elem857 = null;
            elem857 = input.readString();
            this.roomIds.push(elem857);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRoomsV2_args');
    if (this.roomIds !== null && this.roomIds !== undefined) {
      output.writeFieldBegin('roomIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.roomIds.length);
      for (let iter858 in this.roomIds) {
        if (this.roomIds.hasOwnProperty(iter858)) {
          iter858 = this.roomIds[iter858];
          output.writeString(iter858);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRoomsV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Room]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3860 = input.readListBegin();
          const _size859 = _rtmp3860.size || 0;
          for (let _i861 = 0; _i861 < _size859; ++_i861) {
            let elem862 = null;
            elem862 = new ttypes.Room();
            elem862.read(input);
            this.success.push(elem862);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRoomsV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter863 in this.success) {
        if (this.success.hasOwnProperty(iter863)) {
          iter863 = this.success[iter863];
          iter863.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getReadMessageOps_args = class {
  constructor(args) {
    this.chatId = null;
    if (args) {
      if (args.chatId !== undefined && args.chatId !== null) {
        this.chatId = args.chatId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getReadMessageOps_args');
    if (this.chatId !== null && this.chatId !== undefined) {
      output.writeFieldBegin('chatId', Thrift.Type.STRING, 2);
      output.writeString(this.chatId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getReadMessageOps_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Operation]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3865 = input.readListBegin();
          const _size864 = _rtmp3865.size || 0;
          for (let _i866 = 0; _i866 < _size864; ++_i866) {
            let elem867 = null;
            elem867 = new ttypes.Operation();
            elem867.read(input);
            this.success.push(elem867);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getReadMessageOps_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter868 in this.success) {
        if (this.success.hasOwnProperty(iter868)) {
          iter868 = this.success[iter868];
          iter868.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSettingsAttributes_args = class {
  constructor(args) {
    this.attrBitset = null;
    if (args) {
      if (args.attrBitset !== undefined && args.attrBitset !== null) {
        this.attrBitset = args.attrBitset;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.attrBitset = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSettingsAttributes_args');
    if (this.attrBitset !== null && this.attrBitset !== undefined) {
      output.writeFieldBegin('attrBitset', Thrift.Type.I32, 2);
      output.writeI32(this.attrBitset);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSettingsAttributes_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Settings(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Settings();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSettingsAttributes_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestIdentityUnbind_args = class {
  constructor(args) {
    this.identifier = null;
    this.provider = null;
    if (args) {
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.provider !== undefined && args.provider !== null) {
        this.provider = args.provider;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.provider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestIdentityUnbind_args');
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 2);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.provider !== null && this.provider !== undefined) {
      output.writeFieldBegin('provider', Thrift.Type.I32, 4);
      output.writeI32(this.provider);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestIdentityUnbind_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestIdentityUnbind_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessagesBySequenceNumber_args = class {
  constructor(args) {
    this.channelId = null;
    this.messageBoxId = null;
    this.startSeq = null;
    this.endSeq = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.startSeq !== undefined && args.startSeq !== null) {
        this.startSeq = args.startSeq;
      }
      if (args.endSeq !== undefined && args.endSeq !== null) {
        this.endSeq = args.endSeq;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.startSeq = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.endSeq = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessagesBySequenceNumber_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 2);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 3);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.startSeq !== null && this.startSeq !== undefined) {
      output.writeFieldBegin('startSeq', Thrift.Type.I64, 4);
      output.writeI64(this.startSeq);
      output.writeFieldEnd();
    }
    if (this.endSeq !== null && this.endSeq !== undefined) {
      output.writeFieldBegin('endSeq', Thrift.Type.I64, 5);
      output.writeI64(this.endSeq);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessagesBySequenceNumber_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Message]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3870 = input.readListBegin();
          const _size869 = _rtmp3870.size || 0;
          for (let _i871 = 0; _i871 < _size869; ++_i871) {
            let elem872 = null;
            elem872 = new ttypes.Message();
            elem872.read(input);
            this.success.push(elem872);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessagesBySequenceNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter873 in this.success) {
        if (this.success.hasOwnProperty(iter873)) {
          iter873 = this.success[iter873];
          iter873.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_inviteIntoRoom_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.roomId = null;
    this.contactIds = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.roomId !== undefined && args.roomId !== null) {
        this.roomId = args.roomId;
      }
      if (args.contactIds !== undefined && args.contactIds !== null) {
        this.contactIds = Thrift.copyList(args.contactIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.roomId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.contactIds = [];
          const _rtmp3875 = input.readListBegin();
          const _size874 = _rtmp3875.size || 0;
          for (let _i876 = 0; _i876 < _size874; ++_i876) {
            let elem877 = null;
            elem877 = input.readString();
            this.contactIds.push(elem877);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_inviteIntoRoom_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.roomId !== null && this.roomId !== undefined) {
      output.writeFieldBegin('roomId', Thrift.Type.STRING, 2);
      output.writeString(this.roomId);
      output.writeFieldEnd();
    }
    if (this.contactIds !== null && this.contactIds !== undefined) {
      output.writeFieldBegin('contactIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.contactIds.length);
      for (let iter878 in this.contactIds) {
        if (this.contactIds.hasOwnProperty(iter878)) {
          iter878 = this.contactIds[iter878];
          output.writeString(iter878);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_inviteIntoRoom_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_inviteIntoRoom_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendChatChecked_args = class {
  constructor(args) {
    this.seq = null;
    this.consumer = null;
    this.lastMessageId = null;
    this.sessionId = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.consumer !== undefined && args.consumer !== null) {
        this.consumer = args.consumer;
      }
      if (args.lastMessageId !== undefined && args.lastMessageId !== null) {
        this.lastMessageId = args.lastMessageId;
      }
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.consumer = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.lastMessageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BYTE) {
          this.sessionId = input.readByte();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendChatChecked_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.consumer !== null && this.consumer !== undefined) {
      output.writeFieldBegin('consumer', Thrift.Type.STRING, 2);
      output.writeString(this.consumer);
      output.writeFieldEnd();
    }
    if (this.lastMessageId !== null && this.lastMessageId !== undefined) {
      output.writeFieldBegin('lastMessageId', Thrift.Type.STRING, 3);
      output.writeString(this.lastMessageId);
      output.writeFieldEnd();
    }
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.BYTE, 4);
      output.writeByte(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendChatChecked_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendChatChecked_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeSnsId_args = class {
  constructor(args) {
    this.snsIdType = null;
    if (args) {
      if (args.snsIdType !== undefined && args.snsIdType !== null) {
        this.snsIdType = args.snsIdType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.snsIdType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeSnsId_args');
    if (this.snsIdType !== null && this.snsIdType !== undefined) {
      output.writeFieldBegin('snsIdType', Thrift.Type.I32, 2);
      output.writeI32(this.snsIdType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeSnsId_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeSnsId_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportSpammer_args = class {
  constructor(args) {
    this.spammerMid = null;
    this.spammerReasons = null;
    this.spamMessageIds = null;
    this.spamMessages = null;
    if (args) {
      if (args.spammerMid !== undefined && args.spammerMid !== null) {
        this.spammerMid = args.spammerMid;
      }
      if (args.spammerReasons !== undefined && args.spammerReasons !== null) {
        this.spammerReasons = Thrift.copyList(args.spammerReasons, [null]);
      }
      if (args.spamMessageIds !== undefined && args.spamMessageIds !== null) {
        this.spamMessageIds = Thrift.copyList(args.spamMessageIds, [null]);
      }
      if (args.spamMessages !== undefined && args.spamMessages !== null) {
        this.spamMessages = Thrift.copyList(args.spamMessages, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.spammerMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.spammerReasons = [];
          const _rtmp3880 = input.readListBegin();
          const _size879 = _rtmp3880.size || 0;
          for (let _i881 = 0; _i881 < _size879; ++_i881) {
            let elem882 = null;
            elem882 = input.readI32();
            this.spammerReasons.push(elem882);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.spamMessageIds = [];
          const _rtmp3884 = input.readListBegin();
          const _size883 = _rtmp3884.size || 0;
          for (let _i885 = 0; _i885 < _size883; ++_i885) {
            let elem886 = null;
            elem886 = input.readString();
            this.spamMessageIds.push(elem886);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.spamMessages = [];
          const _rtmp3888 = input.readListBegin();
          const _size887 = _rtmp3888.size || 0;
          for (let _i889 = 0; _i889 < _size887; ++_i889) {
            let elem890 = null;
            elem890 = input.readString();
            this.spamMessages.push(elem890);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportSpammer_args');
    if (this.spammerMid !== null && this.spammerMid !== undefined) {
      output.writeFieldBegin('spammerMid', Thrift.Type.STRING, 2);
      output.writeString(this.spammerMid);
      output.writeFieldEnd();
    }
    if (this.spammerReasons !== null && this.spammerReasons !== undefined) {
      output.writeFieldBegin('spammerReasons', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.I32, this.spammerReasons.length);
      for (let iter891 in this.spammerReasons) {
        if (this.spammerReasons.hasOwnProperty(iter891)) {
          iter891 = this.spammerReasons[iter891];
          output.writeI32(iter891);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.spamMessageIds !== null && this.spamMessageIds !== undefined) {
      output.writeFieldBegin('spamMessageIds', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.spamMessageIds.length);
      for (let iter892 in this.spamMessageIds) {
        if (this.spamMessageIds.hasOwnProperty(iter892)) {
          iter892 = this.spamMessageIds[iter892];
          output.writeString(iter892);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.spamMessages !== null && this.spamMessages !== undefined) {
      output.writeFieldBegin('spamMessages', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRING, this.spamMessages.length);
      for (let iter893 in this.spamMessages) {
        if (this.spamMessages.hasOwnProperty(iter893)) {
          iter893 = this.spamMessages[iter893];
          output.writeString(iter893);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportSpammer_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportSpammer_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactsByEmail_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.emails = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.emails !== undefined && args.emails !== null) {
        this.emails = Thrift.copyList(args.emails, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.SET) {
          this.emails = [];
          const _rtmp3895 = input.readSetBegin();
          const _size894 = _rtmp3895.size || 0;
          for (let _i896 = 0; _i896 < _size894; ++_i896) {
            let elem897 = null;
            elem897 = input.readString();
            this.emails.push(elem897);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactsByEmail_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.emails !== null && this.emails !== undefined) {
      output.writeFieldBegin('emails', Thrift.Type.SET, 2);
      output.writeSetBegin(Thrift.Type.STRING, this.emails.length);
      for (let iter898 in this.emails) {
        if (this.emails.hasOwnProperty(iter898)) {
          iter898 = this.emails[iter898];
          output.writeString(iter898);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactsByEmail_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [ttypes.Contact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3900 = input.readMapBegin();
          const _size899 = _rtmp3900.size || 0;
          for (let _i901 = 0; _i901 < _size899; ++_i901) {
            let key902 = null;
            let val903 = null;
            key902 = input.readString();
            val903 = new ttypes.Contact();
            val903.read(input);
            this.success[key902] = val903;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactsByEmail_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter904 in this.success) {
        if (this.success.hasOwnProperty(kiter904)) {
          let viter905 = this.success[kiter904];
          output.writeString(kiter904);
          viter905.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactGroups_args = class {
  constructor(args) {
    this.groupIds = null;
    if (args) {
      if (args.groupIds !== undefined && args.groupIds !== null) {
        this.groupIds = Thrift.copyList(args.groupIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.groupIds = [];
          const _rtmp3907 = input.readListBegin();
          const _size906 = _rtmp3907.size || 0;
          for (let _i908 = 0; _i908 < _size906; ++_i908) {
            let elem909 = null;
            elem909 = input.readString();
            this.groupIds.push(elem909);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactGroups_args');
    if (this.groupIds !== null && this.groupIds !== undefined) {
      output.writeFieldBegin('groupIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.groupIds.length);
      for (let iter910 in this.groupIds) {
        if (this.groupIds.hasOwnProperty(iter910)) {
          iter910 = this.groupIds[iter910];
          output.writeString(iter910);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactGroups_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Group]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3912 = input.readListBegin();
          const _size911 = _rtmp3912.size || 0;
          for (let _i913 = 0; _i913 < _size911; ++_i913) {
            let elem914 = null;
            elem914 = new ttypes.Group();
            elem914.read(input);
            this.success.push(elem914);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter915 in this.success) {
        if (this.success.hasOwnProperty(iter915)) {
          iter915 = this.success[iter915];
          iter915.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessage_args = class {
  constructor(args) {
    this.seq = null;
    this.message = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = new ttypes.Message(args.message);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.message = new ttypes.Message();
          this.message.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessage_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRUCT, 2);
      this.message.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessage_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Message(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Message();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRooms_args = class {
  constructor(args) {
    this.roomIds = null;
    if (args) {
      if (args.roomIds !== undefined && args.roomIds !== null) {
        this.roomIds = Thrift.copyList(args.roomIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.roomIds = [];
          const _rtmp3917 = input.readListBegin();
          const _size916 = _rtmp3917.size || 0;
          for (let _i918 = 0; _i918 < _size916; ++_i918) {
            let elem919 = null;
            elem919 = input.readString();
            this.roomIds.push(elem919);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRooms_args');
    if (this.roomIds !== null && this.roomIds !== undefined) {
      output.writeFieldBegin('roomIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.roomIds.length);
      for (let iter920 in this.roomIds) {
        if (this.roomIds.hasOwnProperty(iter920)) {
          iter920 = this.roomIds[iter920];
          output.writeString(iter920);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRooms_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Room]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3922 = input.readListBegin();
          const _size921 = _rtmp3922.size || 0;
          for (let _i923 = 0; _i923 < _size921; ++_i923) {
            let elem924 = null;
            elem924 = new ttypes.Room();
            elem924.read(input);
            this.success.push(elem924);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRooms_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter925 in this.success) {
        if (this.success.hasOwnProperty(iter925)) {
          iter925 = this.success[iter925];
          iter925.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateC2DMRegistrationId_args = class {
  constructor(args) {
    this.registrationId = null;
    if (args) {
      if (args.registrationId !== undefined && args.registrationId !== null) {
        this.registrationId = args.registrationId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.registrationId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateC2DMRegistrationId_args');
    if (this.registrationId !== null && this.registrationId !== undefined) {
      output.writeFieldBegin('registrationId', Thrift.Type.STRING, 2);
      output.writeString(this.registrationId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateC2DMRegistrationId_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateC2DMRegistrationId_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendPostback_args = class {
  constructor(args) {
    this.request = null;
    if (args) {
      if (args.request !== undefined && args.request !== null) {
        this.request = new ttypes.SendPostbackRequest(args.request);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.request = new ttypes.SendPostbackRequest();
          this.request.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendPostback_args');
    if (this.request !== null && this.request !== undefined) {
      output.writeFieldBegin('request', Thrift.Type.STRUCT, 2);
      this.request.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendPostback_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendPostback_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getReadMessageOpsInBulk_args = class {
  constructor(args) {
    this.chatIds = null;
    if (args) {
      if (args.chatIds !== undefined && args.chatIds !== null) {
        this.chatIds = Thrift.copyList(args.chatIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.chatIds = [];
          const _rtmp3927 = input.readListBegin();
          const _size926 = _rtmp3927.size || 0;
          for (let _i928 = 0; _i928 < _size926; ++_i928) {
            let elem929 = null;
            elem929 = input.readString();
            this.chatIds.push(elem929);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getReadMessageOpsInBulk_args');
    if (this.chatIds !== null && this.chatIds !== undefined) {
      output.writeFieldBegin('chatIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.chatIds.length);
      for (let iter930 in this.chatIds) {
        if (this.chatIds.hasOwnProperty(iter930)) {
          iter930 = this.chatIds[iter930];
          output.writeString(iter930);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getReadMessageOpsInBulk_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Operation]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3932 = input.readListBegin();
          const _size931 = _rtmp3932.size || 0;
          for (let _i933 = 0; _i933 < _size931; ++_i933) {
            let elem934 = null;
            elem934 = new ttypes.Operation();
            elem934.read(input);
            this.success.push(elem934);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getReadMessageOpsInBulk_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter935 in this.success) {
        if (this.success.hasOwnProperty(iter935)) {
          iter935 = this.success[iter935];
          iter935.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessageIgnored_args = class {
  constructor(args) {
    this.seq = null;
    this.consumer = null;
    this.messageIds = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.consumer !== undefined && args.consumer !== null) {
        this.consumer = args.consumer;
      }
      if (args.messageIds !== undefined && args.messageIds !== null) {
        this.messageIds = Thrift.copyList(args.messageIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.consumer = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.messageIds = [];
          const _rtmp3937 = input.readListBegin();
          const _size936 = _rtmp3937.size || 0;
          for (let _i938 = 0; _i938 < _size936; ++_i938) {
            let elem939 = null;
            elem939 = input.readString();
            this.messageIds.push(elem939);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessageIgnored_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.consumer !== null && this.consumer !== undefined) {
      output.writeFieldBegin('consumer', Thrift.Type.STRING, 2);
      output.writeString(this.consumer);
      output.writeFieldEnd();
    }
    if (this.messageIds !== null && this.messageIds !== undefined) {
      output.writeFieldBegin('messageIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.messageIds.length);
      for (let iter940 in this.messageIds) {
        if (this.messageIds.hasOwnProperty(iter940)) {
          iter940 = this.messageIds[iter940];
          output.writeString(iter940);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessageIgnored_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessageIgnored_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxWrapUpListV2_args = class {
  constructor(args) {
    this.messageBoxOffset = null;
    this.messageBoxCount = null;
    if (args) {
      if (args.messageBoxOffset !== undefined && args.messageBoxOffset !== null) {
        this.messageBoxOffset = args.messageBoxOffset;
      }
      if (args.messageBoxCount !== undefined && args.messageBoxCount !== null) {
        this.messageBoxCount = args.messageBoxCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.messageBoxOffset = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.messageBoxCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxWrapUpListV2_args');
    if (this.messageBoxOffset !== null && this.messageBoxOffset !== undefined) {
      output.writeFieldBegin('messageBoxOffset', Thrift.Type.I32, 2);
      output.writeI32(this.messageBoxOffset);
      output.writeFieldEnd();
    }
    if (this.messageBoxCount !== null && this.messageBoxCount !== undefined) {
      output.writeFieldBegin('messageBoxCount', Thrift.Type.I32, 3);
      output.writeI32(this.messageBoxCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxWrapUpListV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBoxWrapUpResponse(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBoxWrapUpResponse();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxWrapUpListV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getOldReadMessageOpsWithRange_args = class {
  constructor(args) {
    this.startRev = null;
    this.endRev = null;
    if (args) {
      if (args.startRev !== undefined && args.startRev !== null) {
        this.startRev = args.startRev;
      }
      if (args.endRev !== undefined && args.endRev !== null) {
        this.endRev = args.endRev;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.startRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getOldReadMessageOpsWithRange_args');
    if (this.startRev !== null && this.startRev !== undefined) {
      output.writeFieldBegin('startRev', Thrift.Type.I64, 2);
      output.writeI64(this.startRev);
      output.writeFieldEnd();
    }
    if (this.endRev !== null && this.endRev !== undefined) {
      output.writeFieldBegin('endRev', Thrift.Type.I64, 3);
      output.writeI64(this.endRev);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getOldReadMessageOpsWithRange_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Operation]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3942 = input.readListBegin();
          const _size941 = _rtmp3942.size || 0;
          for (let _i943 = 0; _i943 < _size941; ++_i943) {
            let elem944 = null;
            elem944 = new ttypes.Operation();
            elem944.read(input);
            this.success.push(elem944);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getOldReadMessageOpsWithRange_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter945 in this.success) {
        if (this.success.hasOwnProperty(iter945)) {
          iter945 = this.success[iter945];
          iter945.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRSAKeyInfo_args = class {
  constructor(args) {
    this.provider = null;
    if (args) {
      if (args.provider !== undefined && args.provider !== null) {
        this.provider = args.provider;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.provider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRSAKeyInfo_args');
    if (this.provider !== null && this.provider !== undefined) {
      output.writeFieldBegin('provider', Thrift.Type.I32, 2);
      output.writeI32(this.provider);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRSAKeyInfo_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.RSAKey(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.RSAKey();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRSAKeyInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateProfileAttribute_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.attr = null;
    this.value = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.attr !== undefined && args.attr !== null) {
        this.attr = args.attr;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.attr = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateProfileAttribute_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.attr !== null && this.attr !== undefined) {
      output.writeFieldBegin('attr', Thrift.Type.I32, 2);
      output.writeI32(this.attr);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateProfileAttribute_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateProfileAttribute_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createAccountMigrationPincodeSession_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createAccountMigrationPincodeSession_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createAccountMigrationPincodeSession_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createAccountMigrationPincodeSession_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifiedRedirect_args = class {
  constructor(args) {
    this.paramMap = null;
    if (args) {
      if (args.paramMap !== undefined && args.paramMap !== null) {
        this.paramMap = Thrift.copyMap(args.paramMap, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.paramMap = {};
          const _rtmp3947 = input.readMapBegin();
          const _size946 = _rtmp3947.size || 0;
          for (let _i948 = 0; _i948 < _size946; ++_i948) {
            let key949 = null;
            let val950 = null;
            key949 = input.readString();
            val950 = input.readString();
            this.paramMap[key949] = val950;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifiedRedirect_args');
    if (this.paramMap !== null && this.paramMap !== undefined) {
      output.writeFieldBegin('paramMap', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.paramMap));
      for (let kiter951 in this.paramMap) {
        if (this.paramMap.hasOwnProperty(kiter951)) {
          let viter952 = this.paramMap[kiter951];
          output.writeString(kiter951);
          output.writeString(viter952);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifiedRedirect_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifiedRedirect_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyIndividualEvent_args = class {
  constructor(args) {
    this.notificationStatus = null;
    this.receiverMids = null;
    if (args) {
      if (args.notificationStatus !== undefined && args.notificationStatus !== null) {
        this.notificationStatus = args.notificationStatus;
      }
      if (args.receiverMids !== undefined && args.receiverMids !== null) {
        this.receiverMids = Thrift.copyList(args.receiverMids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.notificationStatus = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.receiverMids = [];
          const _rtmp3954 = input.readListBegin();
          const _size953 = _rtmp3954.size || 0;
          for (let _i955 = 0; _i955 < _size953; ++_i955) {
            let elem956 = null;
            elem956 = input.readString();
            this.receiverMids.push(elem956);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyIndividualEvent_args');
    if (this.notificationStatus !== null && this.notificationStatus !== undefined) {
      output.writeFieldBegin('notificationStatus', Thrift.Type.I32, 2);
      output.writeI32(this.notificationStatus);
      output.writeFieldEnd();
    }
    if (this.receiverMids !== null && this.receiverMids !== undefined) {
      output.writeFieldBegin('receiverMids', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.receiverMids.length);
      for (let iter957 in this.receiverMids) {
        if (this.receiverMids.hasOwnProperty(iter957)) {
          iter957 = this.receiverMids[iter957];
          output.writeString(iter957);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyIndividualEvent_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyIndividualEvent_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateApnsDeviceToken_args = class {
  constructor(args) {
    this.apnsDeviceToken = null;
    if (args) {
      if (args.apnsDeviceToken !== undefined && args.apnsDeviceToken !== null) {
        this.apnsDeviceToken = args.apnsDeviceToken;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.apnsDeviceToken = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateApnsDeviceToken_args');
    if (this.apnsDeviceToken !== null && this.apnsDeviceToken !== undefined) {
      output.writeFieldBegin('apnsDeviceToken', Thrift.Type.STRING, 2);
      output.writeBinary(this.apnsDeviceToken);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateApnsDeviceToken_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateApnsDeviceToken_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxCompactWrapUpListV2_args = class {
  constructor(args) {
    this.messageBoxOffset = null;
    this.messageBoxCount = null;
    if (args) {
      if (args.messageBoxOffset !== undefined && args.messageBoxOffset !== null) {
        this.messageBoxOffset = args.messageBoxOffset;
      }
      if (args.messageBoxCount !== undefined && args.messageBoxCount !== null) {
        this.messageBoxCount = args.messageBoxCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.messageBoxOffset = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.messageBoxCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxCompactWrapUpListV2_args');
    if (this.messageBoxOffset !== null && this.messageBoxOffset !== undefined) {
      output.writeFieldBegin('messageBoxOffset', Thrift.Type.I32, 2);
      output.writeI32(this.messageBoxOffset);
      output.writeFieldEnd();
    }
    if (this.messageBoxCount !== null && this.messageBoxCount !== undefined) {
      output.writeFieldBegin('messageBoxCount', Thrift.Type.I32, 3);
      output.writeI32(this.messageBoxCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxCompactWrapUpListV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBoxWrapUpResponse(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBoxWrapUpResponse();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxCompactWrapUpListV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestEmailConfirmation_args = class {
  constructor(args) {
    this.emailConfirmation = null;
    if (args) {
      if (args.emailConfirmation !== undefined && args.emailConfirmation !== null) {
        this.emailConfirmation = new ttypes.EmailConfirmation(args.emailConfirmation);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.emailConfirmation = new ttypes.EmailConfirmation();
          this.emailConfirmation.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestEmailConfirmation_args');
    if (this.emailConfirmation !== null && this.emailConfirmation !== undefined) {
      output.writeFieldBegin('emailConfirmation', Thrift.Type.STRUCT, 2);
      this.emailConfirmation.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestEmailConfirmation_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.EmailConfirmationSession(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.EmailConfirmationSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestEmailConfirmation_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithSnsIdAndIdentityCredential_args = class {
  constructor(args) {
    this.snsIdType = null;
    this.snsAccessToken = null;
    this.identityCredential = null;
    this.region = null;
    this.udidHash = null;
    this.deviceInfo = null;
    this.migrationPincodeSessionId = null;
    if (args) {
      if (args.snsIdType !== undefined && args.snsIdType !== null) {
        this.snsIdType = args.snsIdType;
      }
      if (args.snsAccessToken !== undefined && args.snsAccessToken !== null) {
        this.snsAccessToken = args.snsAccessToken;
      }
      if (args.identityCredential !== undefined && args.identityCredential !== null) {
        this.identityCredential = new ttypes.IdentityCredential(args.identityCredential);
      }
      if (args.region !== undefined && args.region !== null) {
        this.region = args.region;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.snsIdType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.snsAccessToken = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.identityCredential = new ttypes.IdentityCredential();
          this.identityCredential.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithSnsIdAndIdentityCredential_args');
    if (this.snsIdType !== null && this.snsIdType !== undefined) {
      output.writeFieldBegin('snsIdType', Thrift.Type.I32, 2);
      output.writeI32(this.snsIdType);
      output.writeFieldEnd();
    }
    if (this.snsAccessToken !== null && this.snsAccessToken !== undefined) {
      output.writeFieldBegin('snsAccessToken', Thrift.Type.STRING, 3);
      output.writeString(this.snsAccessToken);
      output.writeFieldEnd();
    }
    if (this.identityCredential !== null && this.identityCredential !== undefined) {
      output.writeFieldBegin('identityCredential', Thrift.Type.STRUCT, 4);
      this.identityCredential.write(output);
      output.writeFieldEnd();
    }
    if (this.region !== null && this.region !== undefined) {
      output.writeFieldBegin('region', Thrift.Type.STRING, 5);
      output.writeString(this.region);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 6);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 7);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 8);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithSnsIdAndIdentityCredential_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithSnsIdAndIdentityCredential_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxCompactWrapUp_args = class {
  constructor(args) {
    this.mid = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxCompactWrapUp_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxCompactWrapUp_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBoxWrapUp(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBoxWrapUp();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxCompactWrapUp_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactByUserTicket_args = class {
  constructor(args) {
    this.ticketIdWithTag = null;
    if (args) {
      if (args.ticketIdWithTag !== undefined && args.ticketIdWithTag !== null) {
        this.ticketIdWithTag = args.ticketIdWithTag;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.ticketIdWithTag = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactByUserTicket_args');
    if (this.ticketIdWithTag !== null && this.ticketIdWithTag !== undefined) {
      output.writeFieldBegin('ticketIdWithTag', Thrift.Type.STRING, 2);
      output.writeString(this.ticketIdWithTag);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactByUserTicket_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Contact(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Contact();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactByUserTicket_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateAccountMigrationPincode_args = class {
  constructor(args) {
    this.accountMigrationPincode = null;
    if (args) {
      if (args.accountMigrationPincode !== undefined && args.accountMigrationPincode !== null) {
        this.accountMigrationPincode = args.accountMigrationPincode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.accountMigrationPincode = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateAccountMigrationPincode_args');
    if (this.accountMigrationPincode !== null && this.accountMigrationPincode !== undefined) {
      output.writeFieldBegin('accountMigrationPincode', Thrift.Type.STRING, 2);
      output.writeString(this.accountMigrationPincode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateAccountMigrationPincode_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateAccountMigrationPincode_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerBuddyUser_args = class {
  constructor(args) {
    this.buddyId = null;
    this.registrarPassword = null;
    if (args) {
      if (args.buddyId !== undefined && args.buddyId !== null) {
        this.buddyId = args.buddyId;
      }
      if (args.registrarPassword !== undefined && args.registrarPassword !== null) {
        this.registrarPassword = args.registrarPassword;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.buddyId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.registrarPassword = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerBuddyUser_args');
    if (this.buddyId !== null && this.buddyId !== undefined) {
      output.writeFieldBegin('buddyId', Thrift.Type.STRING, 2);
      output.writeString(this.buddyId);
      output.writeFieldEnd();
    }
    if (this.registrarPassword !== null && this.registrarPassword !== undefined) {
      output.writeFieldBegin('registrarPassword', Thrift.Type.STRING, 3);
      output.writeString(this.registrarPassword);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerBuddyUser_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerBuddyUser_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateSettings2_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.settings = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.settings !== undefined && args.settings !== null) {
        this.settings = new ttypes.Settings(args.settings);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.settings = new ttypes.Settings();
          this.settings.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateSettings2_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.settings !== null && this.settings !== undefined) {
      output.writeFieldBegin('settings', Thrift.Type.STRUCT, 2);
      this.settings.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateSettings2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateSettings2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getUserTicket_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getUserTicket_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getUserTicket_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Ticket(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Ticket();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getUserTicket_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_fetchOps_args = class {
  constructor(args) {
    this.localRev = null;
    this.count = null;
    this.globalRev = null;
    this.individualRev = null;
    if (args) {
      if (args.localRev !== undefined && args.localRev !== null) {
        this.localRev = args.localRev;
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      }
      if (args.globalRev !== undefined && args.globalRev !== null) {
        this.globalRev = args.globalRev;
      }
      if (args.individualRev !== undefined && args.individualRev !== null) {
        this.individualRev = args.individualRev;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.localRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.count = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.globalRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.individualRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_fetchOps_args');
    if (this.localRev !== null && this.localRev !== undefined) {
      output.writeFieldBegin('localRev', Thrift.Type.I64, 2);
      output.writeI64(this.localRev);
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 3);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    if (this.globalRev !== null && this.globalRev !== undefined) {
      output.writeFieldBegin('globalRev', Thrift.Type.I64, 4);
      output.writeI64(this.globalRev);
      output.writeFieldEnd();
    }
    if (this.individualRev !== null && this.individualRev !== undefined) {
      output.writeFieldBegin('individualRev', Thrift.Type.I64, 5);
      output.writeI64(this.individualRev);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_fetchOps_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ShouldSyncException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Operation]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3959 = input.readListBegin();
          const _size958 = _rtmp3959.size || 0;
          for (let _i960 = 0; _i960 < _size958; ++_i960) {
            let elem961 = null;
            elem961 = new ttypes.Operation();
            elem961.read(input);
            this.success.push(elem961);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ShouldSyncException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_fetchOps_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter962 in this.success) {
        if (this.success.hasOwnProperty(iter962)) {
          iter962 = this.success[iter962];
          iter962.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_commitSendMessagesToMid_args = class {
  constructor(args) {
    this.request = null;
    if (args) {
      if (args.request !== undefined && args.request !== null) {
        this.request = new ttypes.CommitSendMessagesToMidRequest(args.request);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.request = new ttypes.CommitSendMessagesToMidRequest();
          this.request.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_commitSendMessagesToMid_args');
    if (this.request !== null && this.request !== undefined) {
      output.writeFieldBegin('request', Thrift.Type.STRUCT, 1);
      this.request.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_commitSendMessagesToMid_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.CommitSendMessagesToMidResponse(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.CommitSendMessagesToMidResponse();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_commitSendMessagesToMid_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxV2_args = class {
  constructor(args) {
    this.messageBoxId = null;
    this.lastMessagesCount = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.lastMessagesCount !== undefined && args.lastMessagesCount !== null) {
        this.lastMessagesCount = args.lastMessagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.lastMessagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxV2_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.lastMessagesCount !== null && this.lastMessagesCount !== undefined) {
      output.writeFieldBegin('lastMessagesCount', Thrift.Type.I32, 3);
      output.writeI32(this.lastMessagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBox(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBox();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestResendMessage_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.senderMid = null;
    this.messageId = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.senderMid !== undefined && args.senderMid !== null) {
        this.senderMid = args.senderMid;
      }
      if (args.messageId !== undefined && args.messageId !== null) {
        this.messageId = args.messageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.senderMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.messageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestResendMessage_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.senderMid !== null && this.senderMid !== undefined) {
      output.writeFieldBegin('senderMid', Thrift.Type.STRING, 2);
      output.writeString(this.senderMid);
      output.writeFieldEnd();
    }
    if (this.messageId !== null && this.messageId !== undefined) {
      output.writeFieldBegin('messageId', Thrift.Type.STRING, 3);
      output.writeString(this.messageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestResendMessage_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestResendMessage_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroupWithoutMembers_args = class {
  constructor(args) {
    this.groupId = null;
    if (args) {
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroupWithoutMembers_args');
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroupWithoutMembers_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Group(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Group();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroupWithoutMembers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeAllMessages_args = class {
  constructor(args) {
    this.seq = null;
    this.lastMessageId = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.lastMessageId !== undefined && args.lastMessageId !== null) {
        this.lastMessageId = args.lastMessageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.lastMessageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeAllMessages_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.lastMessageId !== null && this.lastMessageId !== undefined) {
      output.writeFieldBegin('lastMessageId', Thrift.Type.STRING, 2);
      output.writeString(this.lastMessageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeAllMessages_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeAllMessages_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyAccountMigration_args = class {
  constructor(args) {
    this.migrationSessionId = null;
    if (args) {
      if (args.migrationSessionId !== undefined && args.migrationSessionId !== null) {
        this.migrationSessionId = args.migrationSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.migrationSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyAccountMigration_args');
    if (this.migrationSessionId !== null && this.migrationSessionId !== undefined) {
      output.writeFieldBegin('migrationSessionId', Thrift.Type.STRING, 2);
      output.writeString(this.migrationSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyAccountMigration_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyAccountMigration_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reissueGroupTicket_args = class {
  constructor(args) {
    this.groupMid = null;
    if (args) {
      if (args.groupMid !== undefined && args.groupMid !== null) {
        this.groupMid = args.groupMid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.groupMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reissueGroupTicket_args');
    if (this.groupMid !== null && this.groupMid !== undefined) {
      output.writeFieldBegin('groupMid', Thrift.Type.STRING, 1);
      output.writeString(this.groupMid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reissueGroupTicket_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reissueGroupTicket_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_logoutSession_args = class {
  constructor(args) {
    this.tokenKey = null;
    if (args) {
      if (args.tokenKey !== undefined && args.tokenKey !== null) {
        this.tokenKey = args.tokenKey;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.tokenKey = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_logoutSession_args');
    if (this.tokenKey !== null && this.tokenKey !== undefined) {
      output.writeFieldBegin('tokenKey', Thrift.Type.STRING, 2);
      output.writeString(this.tokenKey);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_logoutSession_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_logoutSession_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBuddyLocation_args = class {
  constructor(args) {
    this.mid = null;
    this.index = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.index !== undefined && args.index !== null) {
        this.index = args.index;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.index = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBuddyLocation_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.index !== null && this.index !== undefined) {
      output.writeFieldBegin('index', Thrift.Type.I32, 3);
      output.writeI32(this.index);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBuddyLocation_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Geolocation(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Geolocation();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBuddyLocation_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getWapInvitation_args = class {
  constructor(args) {
    this.invitationHash = null;
    if (args) {
      if (args.invitationHash !== undefined && args.invitationHash !== null) {
        this.invitationHash = args.invitationHash;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.invitationHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getWapInvitation_args');
    if (this.invitationHash !== null && this.invitationHash !== undefined) {
      output.writeFieldBegin('invitationHash', Thrift.Type.STRING, 2);
      output.writeString(this.invitationHash);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getWapInvitation_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.WapInvitation(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.WapInvitation();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getWapInvitation_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerDevice_args = class {
  constructor(args) {
    this.sessionId = null;
    this.migrationPincodeSessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerDevice_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 3);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerDevice_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerDevice_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_clearMessageBox_args = class {
  constructor(args) {
    this.channelId = null;
    this.messageBoxId = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_clearMessageBox_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 2);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 3);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_clearMessageBox_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_clearMessageBox_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithIdentityCredentialForCertificate_args = class {
  constructor(args) {
    this.identifier = null;
    this.password = null;
    this.keepLoggedIn = null;
    this.accessLocation = null;
    this.systemName = null;
    this.identityProvider = null;
    this.certificate = null;
    if (args) {
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.keepLoggedIn !== undefined && args.keepLoggedIn !== null) {
        this.keepLoggedIn = args.keepLoggedIn;
      }
      if (args.accessLocation !== undefined && args.accessLocation !== null) {
        this.accessLocation = args.accessLocation;
      }
      if (args.systemName !== undefined && args.systemName !== null) {
        this.systemName = args.systemName;
      }
      if (args.identityProvider !== undefined && args.identityProvider !== null) {
        this.identityProvider = args.identityProvider;
      }
      if (args.certificate !== undefined && args.certificate !== null) {
        this.certificate = args.certificate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.keepLoggedIn = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.accessLocation = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.systemName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.identityProvider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.certificate = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithIdentityCredentialForCertificate_args');
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 3);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 4);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.keepLoggedIn !== null && this.keepLoggedIn !== undefined) {
      output.writeFieldBegin('keepLoggedIn', Thrift.Type.BOOL, 5);
      output.writeBool(this.keepLoggedIn);
      output.writeFieldEnd();
    }
    if (this.accessLocation !== null && this.accessLocation !== undefined) {
      output.writeFieldBegin('accessLocation', Thrift.Type.STRING, 6);
      output.writeString(this.accessLocation);
      output.writeFieldEnd();
    }
    if (this.systemName !== null && this.systemName !== undefined) {
      output.writeFieldBegin('systemName', Thrift.Type.STRING, 7);
      output.writeString(this.systemName);
      output.writeFieldEnd();
    }
    if (this.identityProvider !== null && this.identityProvider !== undefined) {
      output.writeFieldBegin('identityProvider', Thrift.Type.I32, 8);
      output.writeI32(this.identityProvider);
      output.writeFieldEnd();
    }
    if (this.certificate !== null && this.certificate !== undefined) {
      output.writeFieldBegin('certificate', Thrift.Type.STRING, 9);
      output.writeString(this.certificate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithIdentityCredentialForCertificate_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.LoginResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.LoginResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithIdentityCredentialForCertificate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSuggestSettings_args = class {
  constructor(args) {
    this.locale = null;
    if (args) {
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSuggestSettings_args');
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 2);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSuggestSettings_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.SuggestDictionarySettings(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.SuggestDictionarySettings();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSuggestSettings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateAndGetNearby_args = class {
  constructor(args) {
    this.latitude = null;
    this.longitude = null;
    if (args) {
      if (args.latitude !== undefined && args.latitude !== null) {
        this.latitude = args.latitude;
      }
      if (args.longitude !== undefined && args.longitude !== null) {
        this.longitude = args.longitude;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.DOUBLE) {
          this.latitude = input.readDouble();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.DOUBLE) {
          this.longitude = input.readDouble();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateAndGetNearby_args');
    if (this.latitude !== null && this.latitude !== undefined) {
      output.writeFieldBegin('latitude', Thrift.Type.DOUBLE, 2);
      output.writeDouble(this.latitude);
      output.writeFieldEnd();
    }
    if (this.longitude !== null && this.longitude !== undefined) {
      output.writeFieldBegin('longitude', Thrift.Type.DOUBLE, 3);
      output.writeDouble(this.longitude);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateAndGetNearby_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.NearbyEntry]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3964 = input.readListBegin();
          const _size963 = _rtmp3964.size || 0;
          for (let _i965 = 0; _i965 < _size963; ++_i965) {
            let elem966 = null;
            elem966 = new ttypes.NearbyEntry();
            elem966.read(input);
            this.success.push(elem966);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateAndGetNearby_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter967 in this.success) {
        if (this.success.hasOwnProperty(iter967)) {
          iter967 = this.success[iter967];
          iter967.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_syncContactBySnsIds_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.modifications = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.modifications !== undefined && args.modifications !== null) {
        this.modifications = Thrift.copyList(args.modifications, [ttypes.SnsFriendModification]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.modifications = [];
          const _rtmp3969 = input.readListBegin();
          const _size968 = _rtmp3969.size || 0;
          for (let _i970 = 0; _i970 < _size968; ++_i970) {
            let elem971 = null;
            elem971 = new ttypes.SnsFriendModification();
            elem971.read(input);
            this.modifications.push(elem971);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_syncContactBySnsIds_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.modifications !== null && this.modifications !== undefined) {
      output.writeFieldBegin('modifications', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.modifications.length);
      for (let iter972 in this.modifications) {
        if (this.modifications.hasOwnProperty(iter972)) {
          iter972 = this.modifications[iter972];
          iter972.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_syncContactBySnsIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.SnsFriendContactRegistration]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3974 = input.readListBegin();
          const _size973 = _rtmp3974.size || 0;
          for (let _i975 = 0; _i975 < _size973; ++_i975) {
            let elem976 = null;
            elem976 = new ttypes.SnsFriendContactRegistration();
            elem976.read(input);
            this.success.push(elem976);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_syncContactBySnsIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter977 in this.success) {
        if (this.success.hasOwnProperty(iter977)) {
          iter977 = this.success[iter977];
          iter977.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getContacts_args = class {
  constructor(args) {
    this.ids = null;
    if (args) {
      if (args.ids !== undefined && args.ids !== null) {
        this.ids = Thrift.copyList(args.ids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.ids = [];
          const _rtmp3979 = input.readListBegin();
          const _size978 = _rtmp3979.size || 0;
          for (let _i980 = 0; _i980 < _size978; ++_i980) {
            let elem981 = null;
            elem981 = input.readString();
            this.ids.push(elem981);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getContacts_args');
    if (this.ids !== null && this.ids !== undefined) {
      output.writeFieldBegin('ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.ids.length);
      for (let iter982 in this.ids) {
        if (this.ids.hasOwnProperty(iter982)) {
          iter982 = this.ids[iter982];
          output.writeString(iter982);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getContacts_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Contact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3984 = input.readListBegin();
          const _size983 = _rtmp3984.size || 0;
          for (let _i985 = 0; _i985 < _size983; ++_i985) {
            let elem986 = null;
            elem986 = new ttypes.Contact();
            elem986.read(input);
            this.success.push(elem986);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getContacts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter987 in this.success) {
        if (this.success.hasOwnProperty(iter987)) {
          iter987 = this.success[iter987];
          iter987.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxCompactWrapUpList_args = class {
  constructor(args) {
    this.start = null;
    this.messageBoxCount = null;
    if (args) {
      if (args.start !== undefined && args.start !== null) {
        this.start = args.start;
      }
      if (args.messageBoxCount !== undefined && args.messageBoxCount !== null) {
        this.messageBoxCount = args.messageBoxCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.start = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.messageBoxCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxCompactWrapUpList_args');
    if (this.start !== null && this.start !== undefined) {
      output.writeFieldBegin('start', Thrift.Type.I32, 2);
      output.writeI32(this.start);
      output.writeFieldEnd();
    }
    if (this.messageBoxCount !== null && this.messageBoxCount !== undefined) {
      output.writeFieldBegin('messageBoxCount', Thrift.Type.I32, 3);
      output.writeI32(this.messageBoxCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxCompactWrapUpList_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBoxWrapUpResponse(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBoxWrapUpResponse();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxCompactWrapUpList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getProximityMatchCandidates_args = class {
  constructor(args) {
    this.sessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getProximityMatchCandidates_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getProximityMatchCandidates_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Contact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.SET) {
          this.success = [];
          const _rtmp3989 = input.readSetBegin();
          const _size988 = _rtmp3989.size || 0;
          for (let _i990 = 0; _i990 < _size988; ++_i990) {
            let elem991 = null;
            elem991 = new ttypes.Contact();
            elem991.read(input);
            this.success.push(elem991);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getProximityMatchCandidates_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.SET, 0);
      output.writeSetBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter992 in this.success) {
        if (this.success.hasOwnProperty(iter992)) {
          iter992 = this.success[iter992];
          iter992.write(output);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateExtendedProfileAttribute_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.attr = null;
    this.extendedProfile = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.attr !== undefined && args.attr !== null) {
        this.attr = args.attr;
      }
      if (args.extendedProfile !== undefined && args.extendedProfile !== null) {
        this.extendedProfile = new ttypes.ExtendedProfile(args.extendedProfile);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.attr = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.extendedProfile = new ttypes.ExtendedProfile();
          this.extendedProfile.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateExtendedProfileAttribute_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.attr !== null && this.attr !== undefined) {
      output.writeFieldBegin('attr', Thrift.Type.I32, 2);
      output.writeI32(this.attr);
      output.writeFieldEnd();
    }
    if (this.extendedProfile !== null && this.extendedProfile !== undefined) {
      output.writeFieldBegin('extendedProfile', Thrift.Type.STRUCT, 3);
      this.extendedProfile.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateExtendedProfileAttribute_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateExtendedProfileAttribute_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_resendPinCode_args = class {
  constructor(args) {
    this.sessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_resendPinCode_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_resendPinCode_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_resendPinCode_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportSettings_args = class {
  constructor(args) {
    this.syncOpRevision = null;
    this.settings = null;
    if (args) {
      if (args.syncOpRevision !== undefined && args.syncOpRevision !== null) {
        this.syncOpRevision = args.syncOpRevision;
      }
      if (args.settings !== undefined && args.settings !== null) {
        this.settings = new ttypes.Settings(args.settings);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.syncOpRevision = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.settings = new ttypes.Settings();
          this.settings.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportSettings_args');
    if (this.syncOpRevision !== null && this.syncOpRevision !== undefined) {
      output.writeFieldBegin('syncOpRevision', Thrift.Type.I64, 2);
      output.writeI64(this.syncOpRevision);
      output.writeFieldEnd();
    }
    if (this.settings !== null && this.settings !== undefined) {
      output.writeFieldBegin('settings', Thrift.Type.STRUCT, 3);
      this.settings.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportSettings_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportSettings_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerBuddyUserid_args = class {
  constructor(args) {
    this.seq = null;
    this.userid = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.userid !== undefined && args.userid !== null) {
        this.userid = args.userid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerBuddyUserid_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 2);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.userid !== null && this.userid !== undefined) {
      output.writeFieldBegin('userid', Thrift.Type.STRING, 3);
      output.writeString(this.userid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerBuddyUserid_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerBuddyUserid_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findGroupByTicket_args = class {
  constructor(args) {
    this.ticketId = null;
    if (args) {
      if (args.ticketId !== undefined && args.ticketId !== null) {
        this.ticketId = args.ticketId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.ticketId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findGroupByTicket_args');
    if (this.ticketId !== null && this.ticketId !== undefined) {
      output.writeFieldBegin('ticketId', Thrift.Type.STRING, 1);
      output.writeString(this.ticketId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findGroupByTicket_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Group(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Group();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findGroupByTicket_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerDeviceWithIdentityCredential_args = class {
  constructor(args) {
    this.sessionId = null;
    this.identifier = null;
    this.verifier = null;
    this.provider = null;
    this.migrationPincodeSessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
      if (args.provider !== undefined && args.provider !== null) {
        this.provider = args.provider;
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.provider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerDeviceWithIdentityCredential_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 3);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 4);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    if (this.provider !== null && this.provider !== undefined) {
      output.writeFieldBegin('provider', Thrift.Type.I32, 5);
      output.writeI32(this.provider);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 6);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerDeviceWithIdentityCredential_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerDeviceWithIdentityCredential_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_invalidateUserTicket_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_invalidateUserTicket_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_invalidateUserTicket_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_invalidateUserTicket_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendEvent_args = class {
  constructor(args) {
    this.seq = null;
    this.message = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = new ttypes.Message(args.message);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.message = new ttypes.Message();
          this.message.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendEvent_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRUCT, 2);
      this.message.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendEvent_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Message(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Message();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendEvent_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessageToMyHome_args = class {
  constructor(args) {
    this.seq = null;
    this.message = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = new ttypes.Message(args.message);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.message = new ttypes.Message();
          this.message.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessageToMyHome_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRUCT, 2);
      this.message.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessageToMyHome_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Message(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Message();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessageToMyHome_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendContentPreviewUpdated_args = class {
  constructor(args) {
    this.esq = null;
    this.messageId = null;
    this.receiverMids = null;
    if (args) {
      if (args.esq !== undefined && args.esq !== null) {
        this.esq = args.esq;
      }
      if (args.messageId !== undefined && args.messageId !== null) {
        this.messageId = args.messageId;
      }
      if (args.receiverMids !== undefined && args.receiverMids !== null) {
        this.receiverMids = Thrift.copyList(args.receiverMids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.esq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.receiverMids = [];
          const _rtmp3994 = input.readListBegin();
          const _size993 = _rtmp3994.size || 0;
          for (let _i995 = 0; _i995 < _size993; ++_i995) {
            let elem996 = null;
            elem996 = input.readString();
            this.receiverMids.push(elem996);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendContentPreviewUpdated_args');
    if (this.esq !== null && this.esq !== undefined) {
      output.writeFieldBegin('esq', Thrift.Type.I32, 1);
      output.writeI32(this.esq);
      output.writeFieldEnd();
    }
    if (this.messageId !== null && this.messageId !== undefined) {
      output.writeFieldBegin('messageId', Thrift.Type.STRING, 2);
      output.writeString(this.messageId);
      output.writeFieldEnd();
    }
    if (this.receiverMids !== null && this.receiverMids !== undefined) {
      output.writeFieldBegin('receiverMids', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.receiverMids.length);
      for (let iter997 in this.receiverMids) {
        if (this.receiverMids.hasOwnProperty(iter997)) {
          iter997 = this.receiverMids[iter997];
          output.writeString(iter997);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendContentPreviewUpdated_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3999 = input.readMapBegin();
          const _size998 = _rtmp3999.size || 0;
          for (let _i1000 = 0; _i1000 < _size998; ++_i1000) {
            let key1001 = null;
            let val1002 = null;
            key1001 = input.readString();
            val1002 = input.readString();
            this.success[key1001] = val1002;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendContentPreviewUpdated_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter1003 in this.success) {
        if (this.success.hasOwnProperty(kiter1003)) {
          let viter1004 = this.success[kiter1003];
          output.writeString(kiter1003);
          output.writeString(viter1004);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithVerifier_args = class {
  constructor(args) {
    this.verifier = null;
    if (args) {
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithVerifier_args');
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 3);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithVerifier_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithVerifier_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_args = class {
  constructor(args) {
    this.subscriberMids = null;
    if (args) {
      if (args.subscriberMids !== undefined && args.subscriberMids !== null) {
        this.subscriberMids = Thrift.copyList(args.subscriberMids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.subscriberMids = [];
          const _rtmp31006 = input.readListBegin();
          const _size1005 = _rtmp31006.size || 0;
          for (let _i1007 = 0; _i1007 < _size1005; ++_i1007) {
            let elem1008 = null;
            elem1008 = input.readString();
            this.subscriberMids.push(elem1008);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_args');
    if (this.subscriberMids !== null && this.subscriberMids !== undefined) {
      output.writeFieldBegin('subscriberMids', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRING, this.subscriberMids.length);
      for (let iter1009 in this.subscriberMids) {
        if (this.subscriberMids.hasOwnProperty(iter1009)) {
          iter1009 = this.subscriberMids[iter1009];
          output.writeString(iter1009);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_unblockContact_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.id = null;
    this.reference = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.reference !== undefined && args.reference !== null) {
        this.reference = args.reference;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.reference = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_unblockContact_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.reference !== null && this.reference !== undefined) {
      output.writeFieldBegin('reference', Thrift.Type.STRING, 3);
      output.writeString(this.reference);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_unblockContact_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_unblockContact_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeBuddyLocation_args = class {
  constructor(args) {
    this.mid = null;
    this.index = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.index !== undefined && args.index !== null) {
        this.index = args.index;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.index = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeBuddyLocation_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.index !== null && this.index !== undefined) {
      output.writeFieldBegin('index', Thrift.Type.I32, 3);
      output.writeI32(this.index);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeBuddyLocation_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeBuddyLocation_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRingbackTone_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRingbackTone_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRingbackTone_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.RingbackTone(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.RingbackTone();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRingbackTone_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getConfigurations_args = class {
  constructor(args) {
    this.revision = null;
    this.regionOfUsim = null;
    this.regionOfTelephone = null;
    this.regionOfLocale = null;
    this.carrier = null;
    if (args) {
      if (args.revision !== undefined && args.revision !== null) {
        this.revision = args.revision;
      }
      if (args.regionOfUsim !== undefined && args.regionOfUsim !== null) {
        this.regionOfUsim = args.regionOfUsim;
      }
      if (args.regionOfTelephone !== undefined && args.regionOfTelephone !== null) {
        this.regionOfTelephone = args.regionOfTelephone;
      }
      if (args.regionOfLocale !== undefined && args.regionOfLocale !== null) {
        this.regionOfLocale = args.regionOfLocale;
      }
      if (args.carrier !== undefined && args.carrier !== null) {
        this.carrier = args.carrier;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.revision = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.regionOfUsim = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.regionOfTelephone = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.regionOfLocale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.carrier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getConfigurations_args');
    if (this.revision !== null && this.revision !== undefined) {
      output.writeFieldBegin('revision', Thrift.Type.I64, 2);
      output.writeI64(this.revision);
      output.writeFieldEnd();
    }
    if (this.regionOfUsim !== null && this.regionOfUsim !== undefined) {
      output.writeFieldBegin('regionOfUsim', Thrift.Type.STRING, 3);
      output.writeString(this.regionOfUsim);
      output.writeFieldEnd();
    }
    if (this.regionOfTelephone !== null && this.regionOfTelephone !== undefined) {
      output.writeFieldBegin('regionOfTelephone', Thrift.Type.STRING, 4);
      output.writeString(this.regionOfTelephone);
      output.writeFieldEnd();
    }
    if (this.regionOfLocale !== null && this.regionOfLocale !== undefined) {
      output.writeFieldBegin('regionOfLocale', Thrift.Type.STRING, 5);
      output.writeString(this.regionOfLocale);
      output.writeFieldEnd();
    }
    if (this.carrier !== null && this.carrier !== undefined) {
      output.writeFieldBegin('carrier', Thrift.Type.STRING, 6);
      output.writeString(this.carrier);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getConfigurations_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Configurations(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Configurations();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getConfigurations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getProximityMatchCandidateList_args = class {
  constructor(args) {
    this.sessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getProximityMatchCandidateList_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getProximityMatchCandidateList_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ProximityMatchCandidateResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ProximityMatchCandidateResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getProximityMatchCandidateList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestAccountPasswordReset_args = class {
  constructor(args) {
    this.identifier = null;
    this.provider = null;
    this.locale = null;
    if (args) {
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.provider !== undefined && args.provider !== null) {
        this.provider = args.provider;
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.provider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestAccountPasswordReset_args');
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 2);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.provider !== null && this.provider !== undefined) {
      output.writeFieldBegin('provider', Thrift.Type.I32, 4);
      output.writeI32(this.provider);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 5);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestAccountPasswordReset_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestAccountPasswordReset_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getNextMessages_args = class {
  constructor(args) {
    this.messageBoxId = null;
    this.startSeq = null;
    this.messagesCount = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.startSeq !== undefined && args.startSeq !== null) {
        this.startSeq = args.startSeq;
      }
      if (args.messagesCount !== undefined && args.messagesCount !== null) {
        this.messagesCount = args.messagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.startSeq = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.messagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getNextMessages_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.startSeq !== null && this.startSeq !== undefined) {
      output.writeFieldBegin('startSeq', Thrift.Type.I64, 3);
      output.writeI64(this.startSeq);
      output.writeFieldEnd();
    }
    if (this.messagesCount !== null && this.messagesCount !== undefined) {
      output.writeFieldBegin('messagesCount', Thrift.Type.I32, 4);
      output.writeI32(this.messagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getNextMessages_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Message]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31011 = input.readListBegin();
          const _size1010 = _rtmp31011.size || 0;
          for (let _i1012 = 0; _i1012 < _size1010; ++_i1012) {
            let elem1013 = null;
            elem1013 = new ttypes.Message();
            elem1013.read(input);
            this.success.push(elem1013);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getNextMessages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1014 in this.success) {
        if (this.success.hasOwnProperty(iter1014)) {
          iter1014 = this.success[iter1014];
          iter1014.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportProfile_args = class {
  constructor(args) {
    this.syncOpRevision = null;
    this.profile = null;
    if (args) {
      if (args.syncOpRevision !== undefined && args.syncOpRevision !== null) {
        this.syncOpRevision = args.syncOpRevision;
      }
      if (args.profile !== undefined && args.profile !== null) {
        this.profile = new ttypes.Profile(args.profile);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.syncOpRevision = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.profile = new ttypes.Profile();
          this.profile.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportProfile_args');
    if (this.syncOpRevision !== null && this.syncOpRevision !== undefined) {
      output.writeFieldBegin('syncOpRevision', Thrift.Type.I64, 2);
      output.writeI64(this.syncOpRevision);
      output.writeFieldEnd();
    }
    if (this.profile !== null && this.profile !== undefined) {
      output.writeFieldBegin('profile', Thrift.Type.STRUCT, 3);
      this.profile.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportProfile_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportProfile_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactRoom_args = class {
  constructor(args) {
    this.roomId = null;
    if (args) {
      if (args.roomId !== undefined && args.roomId !== null) {
        this.roomId = args.roomId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.roomId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactRoom_args');
    if (this.roomId !== null && this.roomId !== undefined) {
      output.writeFieldBegin('roomId', Thrift.Type.STRING, 2);
      output.writeString(this.roomId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactRoom_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Room(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Room();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactRoom_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getLastOpRevision_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getLastOpRevision_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getLastOpRevision_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getLastOpRevision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getPreviousMessagesV2_args = class {
  constructor(args) {
    this.messageBoxId = null;
    this.endMessageId = null;
    this.messagesCount = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.endMessageId !== undefined && args.endMessageId !== null) {
        this.endMessageId = new ttypes.MessageBoxV2MessageId(args.endMessageId);
      }
      if (args.messagesCount !== undefined && args.messagesCount !== null) {
        this.messagesCount = args.messagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.endMessageId = new ttypes.MessageBoxV2MessageId();
          this.endMessageId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.messagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getPreviousMessagesV2_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.endMessageId !== null && this.endMessageId !== undefined) {
      output.writeFieldBegin('endMessageId', Thrift.Type.STRUCT, 3);
      this.endMessageId.write(output);
      output.writeFieldEnd();
    }
    if (this.messagesCount !== null && this.messagesCount !== undefined) {
      output.writeFieldBegin('messagesCount', Thrift.Type.I32, 4);
      output.writeI32(this.messagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getPreviousMessagesV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Message]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31016 = input.readListBegin();
          const _size1015 = _rtmp31016.size || 0;
          for (let _i1017 = 0; _i1017 < _size1015; ++_i1017) {
            let elem1018 = null;
            elem1018 = new ttypes.Message();
            elem1018.read(input);
            this.success.push(elem1018);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getPreviousMessagesV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1019 in this.success) {
        if (this.success.hasOwnProperty(iter1019)) {
          iter1019 = this.success[iter1019];
          iter1019.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_fetchAnnouncements_args = class {
  constructor(args) {
    this.lastFetchedIndex = null;
    if (args) {
      if (args.lastFetchedIndex !== undefined && args.lastFetchedIndex !== null) {
        this.lastFetchedIndex = args.lastFetchedIndex;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.lastFetchedIndex = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_fetchAnnouncements_args');
    if (this.lastFetchedIndex !== null && this.lastFetchedIndex !== undefined) {
      output.writeFieldBegin('lastFetchedIndex', Thrift.Type.I32, 2);
      output.writeI32(this.lastFetchedIndex);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_fetchAnnouncements_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Announcement]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31021 = input.readListBegin();
          const _size1020 = _rtmp31021.size || 0;
          for (let _i1022 = 0; _i1022 < _size1020; ++_i1022) {
            let elem1023 = null;
            elem1023 = new ttypes.Announcement();
            elem1023.read(input);
            this.success.push(elem1023);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_fetchAnnouncements_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1024 in this.success) {
        if (this.success.hasOwnProperty(iter1024)) {
          iter1024 = this.success[iter1024];
          iter1024.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acquireCallRoute_args = class {
  constructor(args) {
    this.to = null;
    if (args) {
      if (args.to !== undefined && args.to !== null) {
        this.to = args.to;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.to = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acquireCallRoute_args');
    if (this.to !== null && this.to !== undefined) {
      output.writeFieldBegin('to', Thrift.Type.STRING, 2);
      output.writeString(this.to);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acquireCallRoute_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31026 = input.readListBegin();
          const _size1025 = _rtmp31026.size || 0;
          for (let _i1027 = 0; _i1027 < _size1025; ++_i1027) {
            let elem1028 = null;
            elem1028 = input.readString();
            this.success.push(elem1028);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acquireCallRoute_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1029 in this.success) {
        if (this.success.hasOwnProperty(iter1029)) {
          iter1029 = this.success[iter1029];
          output.writeString(iter1029);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateSettingsAttribute_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.attr = null;
    this.value = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.attr !== undefined && args.attr !== null) {
        this.attr = args.attr;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.attr = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateSettingsAttribute_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.attr !== null && this.attr !== undefined) {
      output.writeFieldBegin('attr', Thrift.Type.I32, 2);
      output.writeI32(this.attr);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateSettingsAttribute_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateSettingsAttribute_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createGroupV2_args = class {
  constructor(args) {
    this.seq = null;
    this.name = null;
    this.contactIds = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.contactIds !== undefined && args.contactIds !== null) {
        this.contactIds = Thrift.copyList(args.contactIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.contactIds = [];
          const _rtmp31031 = input.readListBegin();
          const _size1030 = _rtmp31031.size || 0;
          for (let _i1032 = 0; _i1032 < _size1030; ++_i1032) {
            let elem1033 = null;
            elem1033 = input.readString();
            this.contactIds.push(elem1033);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createGroupV2_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 2);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.contactIds !== null && this.contactIds !== undefined) {
      output.writeFieldBegin('contactIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.contactIds.length);
      for (let iter1034 in this.contactIds) {
        if (this.contactIds.hasOwnProperty(iter1034)) {
          iter1034 = this.contactIds[iter1034];
          output.writeString(iter1034);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createGroupV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Group(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Group();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createGroupV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_isIdentityIdentifierAvailable_args = class {
  constructor(args) {
    this.identifier = null;
    this.provider = null;
    if (args) {
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.provider !== undefined && args.provider !== null) {
        this.provider = args.provider;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.provider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_isIdentityIdentifierAvailable_args');
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 2);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.provider !== null && this.provider !== undefined) {
      output.writeFieldBegin('provider', Thrift.Type.I32, 3);
      output.writeI32(this.provider);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_isIdentityIdentifierAvailable_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_isIdentityIdentifierAvailable_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_blockContact_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.id = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_blockContact_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_blockContact_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_blockContact_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_commitUpdateProfile_args = class {
  constructor(args) {
    this.seq = null;
    this.attrs = null;
    this.receiverMids = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.attrs !== undefined && args.attrs !== null) {
        this.attrs = Thrift.copyList(args.attrs, [null]);
      }
      if (args.receiverMids !== undefined && args.receiverMids !== null) {
        this.receiverMids = Thrift.copyList(args.receiverMids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.attrs = [];
          const _rtmp31036 = input.readListBegin();
          const _size1035 = _rtmp31036.size || 0;
          for (let _i1037 = 0; _i1037 < _size1035; ++_i1037) {
            let elem1038 = null;
            elem1038 = input.readI32();
            this.attrs.push(elem1038);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.receiverMids = [];
          const _rtmp31040 = input.readListBegin();
          const _size1039 = _rtmp31040.size || 0;
          for (let _i1041 = 0; _i1041 < _size1039; ++_i1041) {
            let elem1042 = null;
            elem1042 = input.readString();
            this.receiverMids.push(elem1042);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_commitUpdateProfile_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.attrs !== null && this.attrs !== undefined) {
      output.writeFieldBegin('attrs', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.attrs.length);
      for (let iter1043 in this.attrs) {
        if (this.attrs.hasOwnProperty(iter1043)) {
          iter1043 = this.attrs[iter1043];
          output.writeI32(iter1043);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.receiverMids !== null && this.receiverMids !== undefined) {
      output.writeFieldBegin('receiverMids', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.receiverMids.length);
      for (let iter1044 in this.receiverMids) {
        if (this.receiverMids.hasOwnProperty(iter1044)) {
          iter1044 = this.receiverMids[iter1044];
          output.writeString(iter1044);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_commitUpdateProfile_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31046 = input.readMapBegin();
          const _size1045 = _rtmp31046.size || 0;
          for (let _i1047 = 0; _i1047 < _size1045; ++_i1047) {
            let key1048 = null;
            let val1049 = null;
            key1048 = input.readString();
            val1049 = input.readString();
            this.success[key1048] = val1049;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_commitUpdateProfile_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter1050 in this.success) {
        if (this.success.hasOwnProperty(kiter1050)) {
          let viter1051 = this.success[kiter1050];
          output.writeString(kiter1050);
          output.writeString(viter1051);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithSnsId_args = class {
  constructor(args) {
    this.snsIdType = null;
    this.snsAccessToken = null;
    this.region = null;
    this.udidHash = null;
    this.deviceInfo = null;
    this.mid = null;
    this.migrationPincodeSessionId = null;
    if (args) {
      if (args.snsIdType !== undefined && args.snsIdType !== null) {
        this.snsIdType = args.snsIdType;
      }
      if (args.snsAccessToken !== undefined && args.snsAccessToken !== null) {
        this.snsAccessToken = args.snsAccessToken;
      }
      if (args.region !== undefined && args.region !== null) {
        this.region = args.region;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.snsIdType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.snsAccessToken = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithSnsId_args');
    if (this.snsIdType !== null && this.snsIdType !== undefined) {
      output.writeFieldBegin('snsIdType', Thrift.Type.I32, 2);
      output.writeI32(this.snsIdType);
      output.writeFieldEnd();
    }
    if (this.snsAccessToken !== null && this.snsAccessToken !== undefined) {
      output.writeFieldBegin('snsAccessToken', Thrift.Type.STRING, 3);
      output.writeString(this.snsAccessToken);
      output.writeFieldEnd();
    }
    if (this.region !== null && this.region !== undefined) {
      output.writeFieldBegin('region', Thrift.Type.STRING, 4);
      output.writeString(this.region);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 5);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 6);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 7);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 8);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithSnsId_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.RegisterWithSnsIdResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.RegisterWithSnsIdResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithSnsId_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updatePublicKeychain_args = class {
  constructor(args) {
    this.publicKeychain = null;
    if (args) {
      if (args.publicKeychain !== undefined && args.publicKeychain !== null) {
        this.publicKeychain = new ttypes.PublicKeychain(args.publicKeychain);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.publicKeychain = new ttypes.PublicKeychain();
          this.publicKeychain.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updatePublicKeychain_args');
    if (this.publicKeychain !== null && this.publicKeychain !== undefined) {
      output.writeFieldBegin('publicKeychain', Thrift.Type.STRUCT, 1);
      this.publicKeychain.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updatePublicKeychain_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.PublicKeychain(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.PublicKeychain();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updatePublicKeychain_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithVerifierForCerificate_args = class {
  constructor(args) {
    this.verifier = null;
    if (args) {
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithVerifierForCerificate_args');
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 3);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithVerifierForCerificate_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.LoginResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.LoginResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithVerifierForCerificate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_tryFriendRequest_args = class {
  constructor(args) {
    this.midOrEMid = null;
    this.method = null;
    this.friendRequestParams = null;
    if (args) {
      if (args.midOrEMid !== undefined && args.midOrEMid !== null) {
        this.midOrEMid = args.midOrEMid;
      }
      if (args.method !== undefined && args.method !== null) {
        this.method = args.method;
      }
      if (args.friendRequestParams !== undefined && args.friendRequestParams !== null) {
        this.friendRequestParams = args.friendRequestParams;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.midOrEMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.method = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.friendRequestParams = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_tryFriendRequest_args');
    if (this.midOrEMid !== null && this.midOrEMid !== undefined) {
      output.writeFieldBegin('midOrEMid', Thrift.Type.STRING, 1);
      output.writeString(this.midOrEMid);
      output.writeFieldEnd();
    }
    if (this.method !== null && this.method !== undefined) {
      output.writeFieldBegin('method', Thrift.Type.I32, 2);
      output.writeI32(this.method);
      output.writeFieldEnd();
    }
    if (this.friendRequestParams !== null && this.friendRequestParams !== undefined) {
      output.writeFieldBegin('friendRequestParams', Thrift.Type.STRING, 3);
      output.writeString(this.friendRequestParams);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_tryFriendRequest_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_tryFriendRequest_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBlockedRecommendationIds_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBlockedRecommendationIds_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBlockedRecommendationIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31053 = input.readListBegin();
          const _size1052 = _rtmp31053.size || 0;
          for (let _i1054 = 0; _i1054 < _size1052; ++_i1054) {
            let elem1055 = null;
            elem1055 = input.readString();
            this.success.push(elem1055);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBlockedRecommendationIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1056 in this.success) {
        if (this.success.hasOwnProperty(iter1056)) {
          iter1056 = this.success[iter1056];
          output.writeString(iter1056);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroupIdsInvited_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroupIdsInvited_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroupIdsInvited_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31058 = input.readListBegin();
          const _size1057 = _rtmp31058.size || 0;
          for (let _i1059 = 0; _i1059 < _size1057; ++_i1059) {
            let elem1060 = null;
            elem1060 = input.readString();
            this.success.push(elem1060);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroupIdsInvited_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1061 in this.success) {
        if (this.success.hasOwnProperty(iter1061)) {
          iter1061 = this.success[iter1061];
          output.writeString(iter1061);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSuggestIncrements_args = class {
  constructor(args) {
    this.revisions = null;
    if (args) {
      if (args.revisions !== undefined && args.revisions !== null) {
        this.revisions = new ttypes.SuggestDictionaryRevisions(args.revisions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.revisions = new ttypes.SuggestDictionaryRevisions();
          this.revisions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSuggestIncrements_args');
    if (this.revisions !== null && this.revisions !== undefined) {
      output.writeFieldBegin('revisions', Thrift.Type.STRUCT, 2);
      this.revisions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSuggestIncrements_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.SuggestDictionaryIncrements(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.SuggestDictionaryIncrements();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSuggestIncrements_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_resendPinCodeBySMS_args = class {
  constructor(args) {
    this.sessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_resendPinCodeBySMS_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_resendPinCodeBySMS_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_resendPinCodeBySMS_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithPhoneNumber_args = class {
  constructor(args) {
    this.sessionId = null;
    this.migrationPincodeSessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithPhoneNumber_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 3);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithPhoneNumber_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.RegisterWithPhoneNumberResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.RegisterWithPhoneNumberResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithPhoneNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getActiveBuddySubscriberIds_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getActiveBuddySubscriberIds_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getActiveBuddySubscriberIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31063 = input.readListBegin();
          const _size1062 = _rtmp31063.size || 0;
          for (let _i1064 = 0; _i1064 < _size1062; ++_i1064) {
            let elem1065 = null;
            elem1065 = input.readString();
            this.success.push(elem1065);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getActiveBuddySubscriberIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1066 in this.success) {
        if (this.success.hasOwnProperty(iter1066)) {
          iter1066 = this.success[iter1066];
          output.writeString(iter1066);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createRoom_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.contactIds = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.contactIds !== undefined && args.contactIds !== null) {
        this.contactIds = Thrift.copyList(args.contactIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.contactIds = [];
          const _rtmp31068 = input.readListBegin();
          const _size1067 = _rtmp31068.size || 0;
          for (let _i1069 = 0; _i1069 < _size1067; ++_i1069) {
            let elem1070 = null;
            elem1070 = input.readString();
            this.contactIds.push(elem1070);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createRoom_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.contactIds !== null && this.contactIds !== undefined) {
      output.writeFieldBegin('contactIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.contactIds.length);
      for (let iter1071 in this.contactIds) {
        if (this.contactIds.hasOwnProperty(iter1071)) {
          iter1071 = this.contactIds[iter1071];
          output.writeString(iter1071);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createRoom_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Room(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Room();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createRoom_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyPhoneNumberForLogin_args = class {
  constructor(args) {
    this.verifierFromPhone = null;
    this.pinCodeForPhone = null;
    this.verifierFromLogin = null;
    if (args) {
      if (args.verifierFromPhone !== undefined && args.verifierFromPhone !== null) {
        this.verifierFromPhone = args.verifierFromPhone;
      }
      if (args.pinCodeForPhone !== undefined && args.pinCodeForPhone !== null) {
        this.pinCodeForPhone = args.pinCodeForPhone;
      }
      if (args.verifierFromLogin !== undefined && args.verifierFromLogin !== null) {
        this.verifierFromLogin = args.verifierFromLogin;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.verifierFromPhone = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pinCodeForPhone = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.verifierFromLogin = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyPhoneNumberForLogin_args');
    if (this.verifierFromPhone !== null && this.verifierFromPhone !== undefined) {
      output.writeFieldBegin('verifierFromPhone', Thrift.Type.STRING, 2);
      output.writeString(this.verifierFromPhone);
      output.writeFieldEnd();
    }
    if (this.pinCodeForPhone !== null && this.pinCodeForPhone !== undefined) {
      output.writeFieldBegin('pinCodeForPhone', Thrift.Type.STRING, 3);
      output.writeString(this.pinCodeForPhone);
      output.writeFieldEnd();
    }
    if (this.verifierFromLogin !== null && this.verifierFromLogin !== undefined) {
      output.writeFieldBegin('verifierFromLogin', Thrift.Type.STRING, 4);
      output.writeString(this.verifierFromLogin);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyPhoneNumberForLogin_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyPhoneNumberForLogin_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_addSnsId_args = class {
  constructor(args) {
    this.snsIdType = null;
    this.snsAccessToken = null;
    if (args) {
      if (args.snsIdType !== undefined && args.snsIdType !== null) {
        this.snsIdType = args.snsIdType;
      }
      if (args.snsAccessToken !== undefined && args.snsAccessToken !== null) {
        this.snsAccessToken = args.snsAccessToken;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.snsIdType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.snsAccessToken = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_addSnsId_args');
    if (this.snsIdType !== null && this.snsIdType !== undefined) {
      output.writeFieldBegin('snsIdType', Thrift.Type.I32, 2);
      output.writeI32(this.snsIdType);
      output.writeFieldEnd();
    }
    if (this.snsAccessToken !== null && this.snsAccessToken !== undefined) {
      output.writeFieldBegin('snsAccessToken', Thrift.Type.STRING, 3);
      output.writeString(this.snsAccessToken);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_addSnsId_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_addSnsId_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_finishUpdateVerification_args = class {
  constructor(args) {
    this.sessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_finishUpdateVerification_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_finishUpdateVerification_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_finishUpdateVerification_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_validateContactsOnBot_args = class {
  constructor(args) {
    this.contacts = null;
    if (args) {
      if (args.contacts !== undefined && args.contacts !== null) {
        this.contacts = Thrift.copyList(args.contacts, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.contacts = [];
          const _rtmp31073 = input.readListBegin();
          const _size1072 = _rtmp31073.size || 0;
          for (let _i1074 = 0; _i1074 < _size1072; ++_i1074) {
            let elem1075 = null;
            elem1075 = input.readString();
            this.contacts.push(elem1075);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_validateContactsOnBot_args');
    if (this.contacts !== null && this.contacts !== undefined) {
      output.writeFieldBegin('contacts', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.contacts.length);
      for (let iter1076 in this.contacts) {
        if (this.contacts.hasOwnProperty(iter1076)) {
          iter1076 = this.contacts[iter1076];
          output.writeString(iter1076);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_validateContactsOnBot_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31078 = input.readMapBegin();
          const _size1077 = _rtmp31078.size || 0;
          for (let _i1079 = 0; _i1079 < _size1077; ++_i1079) {
            let key1080 = null;
            let val1081 = null;
            key1080 = input.readString();
            val1081 = input.readString();
            this.success[key1080] = val1081;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_validateContactsOnBot_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter1082 in this.success) {
        if (this.success.hasOwnProperty(kiter1082)) {
          let viter1083 = this.success[kiter1082];
          output.writeString(kiter1082);
          output.writeString(viter1083);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRoom_args = class {
  constructor(args) {
    this.roomId = null;
    if (args) {
      if (args.roomId !== undefined && args.roomId !== null) {
        this.roomId = args.roomId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.roomId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRoom_args');
    if (this.roomId !== null && this.roomId !== undefined) {
      output.writeFieldBegin('roomId', Thrift.Type.STRING, 2);
      output.writeString(this.roomId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRoom_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Room(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Room();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRoom_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_closeProximityMatch_args = class {
  constructor(args) {
    this.sessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_closeProximityMatch_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_closeProximityMatch_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_closeProximityMatch_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactGroup_args = class {
  constructor(args) {
    this.groupId = null;
    if (args) {
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactGroup_args');
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactGroup_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Group(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Group();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBlockedContactIdsByRange_args = class {
  constructor(args) {
    this.start = null;
    this.count = null;
    if (args) {
      if (args.start !== undefined && args.start !== null) {
        this.start = args.start;
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.start = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.count = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBlockedContactIdsByRange_args');
    if (this.start !== null && this.start !== undefined) {
      output.writeFieldBegin('start', Thrift.Type.I32, 2);
      output.writeI32(this.start);
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 3);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBlockedContactIdsByRange_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31085 = input.readListBegin();
          const _size1084 = _rtmp31085.size || 0;
          for (let _i1086 = 0; _i1086 < _size1084; ++_i1086) {
            let elem1087 = null;
            elem1087 = input.readString();
            this.success.push(elem1087);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBlockedContactIdsByRange_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1088 in this.success) {
        if (this.success.hasOwnProperty(iter1088)) {
          iter1088 = this.success[iter1088];
          output.writeString(iter1088);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRecentMessagesV2_args = class {
  constructor(args) {
    this.messageBoxId = null;
    this.messagesCount = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.messagesCount !== undefined && args.messagesCount !== null) {
        this.messagesCount = args.messagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.messagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRecentMessagesV2_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.messagesCount !== null && this.messagesCount !== undefined) {
      output.writeFieldBegin('messagesCount', Thrift.Type.I32, 3);
      output.writeI32(this.messagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRecentMessagesV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Message]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31090 = input.readListBegin();
          const _size1089 = _rtmp31090.size || 0;
          for (let _i1091 = 0; _i1091 < _size1089; ++_i1091) {
            let elem1092 = null;
            elem1092 = new ttypes.Message();
            elem1092.read(input);
            this.success.push(elem1092);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRecentMessagesV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1093 in this.success) {
        if (this.success.hasOwnProperty(iter1093)) {
          iter1093 = this.success[iter1093];
          iter1093.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reissueUserTicket_args = class {
  constructor(args) {
    this.expirationTime = null;
    this.maxUseCount = null;
    if (args) {
      if (args.expirationTime !== undefined && args.expirationTime !== null) {
        this.expirationTime = args.expirationTime;
      }
      if (args.maxUseCount !== undefined && args.maxUseCount !== null) {
        this.maxUseCount = args.maxUseCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.expirationTime = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.maxUseCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reissueUserTicket_args');
    if (this.expirationTime !== null && this.expirationTime !== undefined) {
      output.writeFieldBegin('expirationTime', Thrift.Type.I64, 3);
      output.writeI64(this.expirationTime);
      output.writeFieldEnd();
    }
    if (this.maxUseCount !== null && this.maxUseCount !== undefined) {
      output.writeFieldBegin('maxUseCount', Thrift.Type.I32, 4);
      output.writeI32(this.maxUseCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reissueUserTicket_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reissueUserTicket_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageReadRange_args = class {
  constructor(args) {
    this.chatIds = null;
    if (args) {
      if (args.chatIds !== undefined && args.chatIds !== null) {
        this.chatIds = Thrift.copyList(args.chatIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.chatIds = [];
          const _rtmp31095 = input.readListBegin();
          const _size1094 = _rtmp31095.size || 0;
          for (let _i1096 = 0; _i1096 < _size1094; ++_i1096) {
            let elem1097 = null;
            elem1097 = input.readString();
            this.chatIds.push(elem1097);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageReadRange_args');
    if (this.chatIds !== null && this.chatIds !== undefined) {
      output.writeFieldBegin('chatIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.chatIds.length);
      for (let iter1098 in this.chatIds) {
        if (this.chatIds.hasOwnProperty(iter1098)) {
          iter1098 = this.chatIds[iter1098];
          output.writeString(iter1098);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageReadRange_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TMessageReadRange]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31100 = input.readListBegin();
          const _size1099 = _rtmp31100.size || 0;
          for (let _i1101 = 0; _i1101 < _size1099; ++_i1101) {
            let elem1102 = null;
            elem1102 = new ttypes.TMessageReadRange();
            elem1102.read(input);
            this.success.push(elem1102);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageReadRange_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1103 in this.success) {
        if (this.success.hasOwnProperty(iter1103)) {
          iter1103 = this.success[iter1103];
          iter1103.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_clearRingbackTone_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_clearRingbackTone_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_clearRingbackTone_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_clearRingbackTone_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_setIdentityCredential_args = class {
  constructor(args) {
    this.identifier = null;
    this.verifier = null;
    this.provider = null;
    if (args) {
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
      if (args.provider !== undefined && args.provider !== null) {
        this.provider = args.provider;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.provider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_setIdentityCredential_args');
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 2);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 3);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    if (this.provider !== null && this.provider !== undefined) {
      output.writeFieldBegin('provider', Thrift.Type.I32, 4);
      output.writeI32(this.provider);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_setIdentityCredential_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_setIdentityCredential_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxCompactWrapUpV2_args = class {
  constructor(args) {
    this.messageBoxId = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxCompactWrapUpV2_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxCompactWrapUpV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBoxWrapUp(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBoxWrapUp();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxCompactWrapUpV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getServerTime_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getServerTime_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getServerTime_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getServerTime_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_trySendMessage_args = class {
  constructor(args) {
    this.seq = null;
    this.message = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = new ttypes.Message(args.message);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.message = new ttypes.Message();
          this.message.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_trySendMessage_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRUCT, 2);
      this.message.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_trySendMessage_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Message(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Message();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_trySendMessage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getNextMessagesV2_args = class {
  constructor(args) {
    this.messageBoxId = null;
    this.startMessageId = null;
    this.messagesCount = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.startMessageId !== undefined && args.startMessageId !== null) {
        this.startMessageId = new ttypes.MessageBoxV2MessageId(args.startMessageId);
      }
      if (args.messagesCount !== undefined && args.messagesCount !== null) {
        this.messagesCount = args.messagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.startMessageId = new ttypes.MessageBoxV2MessageId();
          this.startMessageId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.messagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getNextMessagesV2_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.startMessageId !== null && this.startMessageId !== undefined) {
      output.writeFieldBegin('startMessageId', Thrift.Type.STRUCT, 3);
      this.startMessageId.write(output);
      output.writeFieldEnd();
    }
    if (this.messagesCount !== null && this.messagesCount !== undefined) {
      output.writeFieldBegin('messagesCount', Thrift.Type.I32, 4);
      output.writeI32(this.messagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getNextMessagesV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Message]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31105 = input.readListBegin();
          const _size1104 = _rtmp31105.size || 0;
          for (let _i1106 = 0; _i1106 < _size1104; ++_i1106) {
            let elem1107 = null;
            elem1107 = new ttypes.Message();
            elem1107.read(input);
            this.success.push(elem1107);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getNextMessagesV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1108 in this.success) {
        if (this.success.hasOwnProperty(iter1108)) {
          iter1108 = this.success[iter1108];
          iter1108.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifySleep_args = class {
  constructor(args) {
    this.lastRev = null;
    this.badge = null;
    if (args) {
      if (args.lastRev !== undefined && args.lastRev !== null) {
        this.lastRev = args.lastRev;
      }
      if (args.badge !== undefined && args.badge !== null) {
        this.badge = args.badge;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.lastRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.badge = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifySleep_args');
    if (this.lastRev !== null && this.lastRev !== undefined) {
      output.writeFieldBegin('lastRev', Thrift.Type.I64, 2);
      output.writeI64(this.lastRev);
      output.writeFieldEnd();
    }
    if (this.badge !== null && this.badge !== undefined) {
      output.writeFieldBegin('badge', Thrift.Type.I32, 3);
      output.writeI32(this.badge);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifySleep_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifySleep_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBuddyBlockerIds_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBuddyBlockerIds_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBuddyBlockerIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31110 = input.readListBegin();
          const _size1109 = _rtmp31110.size || 0;
          for (let _i1111 = 0; _i1111 < _size1109; ++_i1111) {
            let elem1112 = null;
            elem1112 = input.readString();
            this.success.push(elem1112);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBuddyBlockerIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1113 in this.success) {
        if (this.success.hasOwnProperty(iter1113)) {
          iter1113 = this.success[iter1113];
          output.writeString(iter1113);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeE2EEPublicKey_args = class {
  constructor(args) {
    this.publicKey = null;
    if (args) {
      if (args.publicKey !== undefined && args.publicKey !== null) {
        this.publicKey = new ttypes.E2EEPublicKey(args.publicKey);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.publicKey = new ttypes.E2EEPublicKey();
          this.publicKey.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeE2EEPublicKey_args');
    if (this.publicKey !== null && this.publicKey !== undefined) {
      output.writeFieldBegin('publicKey', Thrift.Type.STRUCT, 2);
      this.publicKey.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeE2EEPublicKey_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeE2EEPublicKey_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reissueTrackingTicket_args = class {
  constructor(args) {
    this.type = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reissueTrackingTicket_args');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reissueTrackingTicket_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reissueTrackingTicket_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_cancelGroupInvitation_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.groupId = null;
    this.contactIds = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
      if (args.contactIds !== undefined && args.contactIds !== null) {
        this.contactIds = Thrift.copyList(args.contactIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.contactIds = [];
          const _rtmp31115 = input.readListBegin();
          const _size1114 = _rtmp31115.size || 0;
          for (let _i1116 = 0; _i1116 < _size1114; ++_i1116) {
            let elem1117 = null;
            elem1117 = input.readString();
            this.contactIds.push(elem1117);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_cancelGroupInvitation_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    if (this.contactIds !== null && this.contactIds !== undefined) {
      output.writeFieldBegin('contactIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.contactIds.length);
      for (let iter1118 in this.contactIds) {
        if (this.contactIds.hasOwnProperty(iter1118)) {
          iter1118 = this.contactIds[iter1118];
          output.writeString(iter1118);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_cancelGroupInvitation_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_cancelGroupInvitation_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeMessage_args = class {
  constructor(args) {
    this.messageId = null;
    if (args) {
      if (args.messageId !== undefined && args.messageId !== null) {
        this.messageId = args.messageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeMessage_args');
    if (this.messageId !== null && this.messageId !== undefined) {
      output.writeFieldBegin('messageId', Thrift.Type.STRING, 2);
      output.writeString(this.messageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeMessage_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeMessage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAllReadMessageOps_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAllReadMessageOps_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAllReadMessageOps_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Operation]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31120 = input.readListBegin();
          const _size1119 = _rtmp31120.size || 0;
          for (let _i1121 = 0; _i1121 < _size1119; ++_i1121) {
            let elem1122 = null;
            elem1122 = new ttypes.Operation();
            elem1122.read(input);
            this.success.push(elem1122);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAllReadMessageOps_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1123 in this.success) {
        if (this.success.hasOwnProperty(iter1123)) {
          iter1123 = this.success[iter1123];
          iter1123.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_unregisterUserAndDevice_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_unregisterUserAndDevice_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_unregisterUserAndDevice_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_unregisterUserAndDevice_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acceptGroupInvitation_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.groupId = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acceptGroupInvitation_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acceptGroupInvitation_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acceptGroupInvitation_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactContactsModifiedSince_args = class {
  constructor(args) {
    this.timestamp = null;
    if (args) {
      if (args.timestamp !== undefined && args.timestamp !== null) {
        this.timestamp = args.timestamp;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.timestamp = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactContactsModifiedSince_args');
    if (this.timestamp !== null && this.timestamp !== undefined) {
      output.writeFieldBegin('timestamp', Thrift.Type.I64, 2);
      output.writeI64(this.timestamp);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactContactsModifiedSince_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.CompactContact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31125 = input.readListBegin();
          const _size1124 = _rtmp31125.size || 0;
          for (let _i1126 = 0; _i1126 < _size1124; ++_i1126) {
            let elem1127 = null;
            elem1127 = new ttypes.CompactContact();
            elem1127.read(input);
            this.success.push(elem1127);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactContactsModifiedSince_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1128 in this.success) {
        if (this.success.hasOwnProperty(iter1128)) {
          iter1128 = this.success[iter1128];
          iter1128.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_releaseSession_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_releaseSession_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_releaseSession_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_releaseSession_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactsByPhone_args = class {
  constructor(args) {
    this.phones = null;
    if (args) {
      if (args.phones !== undefined && args.phones !== null) {
        this.phones = Thrift.copyList(args.phones, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.SET) {
          this.phones = [];
          const _rtmp31130 = input.readSetBegin();
          const _size1129 = _rtmp31130.size || 0;
          for (let _i1131 = 0; _i1131 < _size1129; ++_i1131) {
            let elem1132 = null;
            elem1132 = input.readString();
            this.phones.push(elem1132);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactsByPhone_args');
    if (this.phones !== null && this.phones !== undefined) {
      output.writeFieldBegin('phones', Thrift.Type.SET, 2);
      output.writeSetBegin(Thrift.Type.STRING, this.phones.length);
      for (let iter1133 in this.phones) {
        if (this.phones.hasOwnProperty(iter1133)) {
          iter1133 = this.phones[iter1133];
          output.writeString(iter1133);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactsByPhone_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [ttypes.Contact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31135 = input.readMapBegin();
          const _size1134 = _rtmp31135.size || 0;
          for (let _i1136 = 0; _i1136 < _size1134; ++_i1136) {
            let key1137 = null;
            let val1138 = null;
            key1137 = input.readString();
            val1138 = new ttypes.Contact();
            val1138.read(input);
            this.success[key1137] = val1138;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactsByPhone_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter1139 in this.success) {
        if (this.success.hasOwnProperty(kiter1139)) {
          let viter1140 = this.success[kiter1139];
          output.writeString(kiter1139);
          viter1140.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getHiddenContactMids_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getHiddenContactMids_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getHiddenContactMids_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31142 = input.readListBegin();
          const _size1141 = _rtmp31142.size || 0;
          for (let _i1143 = 0; _i1143 < _size1141; ++_i1143) {
            let elem1144 = null;
            elem1144 = input.readString();
            this.success.push(elem1144);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getHiddenContactMids_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1145 in this.success) {
        if (this.success.hasOwnProperty(iter1145)) {
          iter1145 = this.success[iter1145];
          output.writeString(iter1145);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getEncryptedIdentity_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getEncryptedIdentity_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getEncryptedIdentity_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getEncryptedIdentity_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateProfile_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.profile = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.profile !== undefined && args.profile !== null) {
        this.profile = new ttypes.Profile(args.profile);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.profile = new ttypes.Profile();
          this.profile.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateProfile_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.profile !== null && this.profile !== undefined) {
      output.writeFieldBegin('profile', Thrift.Type.STRUCT, 2);
      this.profile.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateProfile_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateProfile_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportSpam_args = class {
  constructor(args) {
    this.chatMid = null;
    this.memberMids = null;
    this.spammerReasons = null;
    this.senderMids = null;
    this.spamMessageIds = null;
    this.spamMessages = null;
    if (args) {
      if (args.chatMid !== undefined && args.chatMid !== null) {
        this.chatMid = args.chatMid;
      }
      if (args.memberMids !== undefined && args.memberMids !== null) {
        this.memberMids = Thrift.copyList(args.memberMids, [null]);
      }
      if (args.spammerReasons !== undefined && args.spammerReasons !== null) {
        this.spammerReasons = Thrift.copyList(args.spammerReasons, [null]);
      }
      if (args.senderMids !== undefined && args.senderMids !== null) {
        this.senderMids = Thrift.copyList(args.senderMids, [null]);
      }
      if (args.spamMessageIds !== undefined && args.spamMessageIds !== null) {
        this.spamMessageIds = Thrift.copyList(args.spamMessageIds, [null]);
      }
      if (args.spamMessages !== undefined && args.spamMessages !== null) {
        this.spamMessages = Thrift.copyList(args.spamMessages, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.memberMids = [];
          const _rtmp31147 = input.readListBegin();
          const _size1146 = _rtmp31147.size || 0;
          for (let _i1148 = 0; _i1148 < _size1146; ++_i1148) {
            let elem1149 = null;
            elem1149 = input.readString();
            this.memberMids.push(elem1149);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.spammerReasons = [];
          const _rtmp31151 = input.readListBegin();
          const _size1150 = _rtmp31151.size || 0;
          for (let _i1152 = 0; _i1152 < _size1150; ++_i1152) {
            let elem1153 = null;
            elem1153 = input.readI32();
            this.spammerReasons.push(elem1153);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.senderMids = [];
          const _rtmp31155 = input.readListBegin();
          const _size1154 = _rtmp31155.size || 0;
          for (let _i1156 = 0; _i1156 < _size1154; ++_i1156) {
            let elem1157 = null;
            elem1157 = input.readString();
            this.senderMids.push(elem1157);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.spamMessageIds = [];
          const _rtmp31159 = input.readListBegin();
          const _size1158 = _rtmp31159.size || 0;
          for (let _i1160 = 0; _i1160 < _size1158; ++_i1160) {
            let elem1161 = null;
            elem1161 = input.readString();
            this.spamMessageIds.push(elem1161);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.spamMessages = [];
          const _rtmp31163 = input.readListBegin();
          const _size1162 = _rtmp31163.size || 0;
          for (let _i1164 = 0; _i1164 < _size1162; ++_i1164) {
            let elem1165 = null;
            elem1165 = input.readString();
            this.spamMessages.push(elem1165);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportSpam_args');
    if (this.chatMid !== null && this.chatMid !== undefined) {
      output.writeFieldBegin('chatMid', Thrift.Type.STRING, 2);
      output.writeString(this.chatMid);
      output.writeFieldEnd();
    }
    if (this.memberMids !== null && this.memberMids !== undefined) {
      output.writeFieldBegin('memberMids', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.memberMids.length);
      for (let iter1166 in this.memberMids) {
        if (this.memberMids.hasOwnProperty(iter1166)) {
          iter1166 = this.memberMids[iter1166];
          output.writeString(iter1166);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.spammerReasons !== null && this.spammerReasons !== undefined) {
      output.writeFieldBegin('spammerReasons', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.I32, this.spammerReasons.length);
      for (let iter1167 in this.spammerReasons) {
        if (this.spammerReasons.hasOwnProperty(iter1167)) {
          iter1167 = this.spammerReasons[iter1167];
          output.writeI32(iter1167);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.senderMids !== null && this.senderMids !== undefined) {
      output.writeFieldBegin('senderMids', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRING, this.senderMids.length);
      for (let iter1168 in this.senderMids) {
        if (this.senderMids.hasOwnProperty(iter1168)) {
          iter1168 = this.senderMids[iter1168];
          output.writeString(iter1168);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.spamMessageIds !== null && this.spamMessageIds !== undefined) {
      output.writeFieldBegin('spamMessageIds', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.spamMessageIds.length);
      for (let iter1169 in this.spamMessageIds) {
        if (this.spamMessageIds.hasOwnProperty(iter1169)) {
          iter1169 = this.spamMessageIds[iter1169];
          output.writeString(iter1169);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.spamMessages !== null && this.spamMessages !== undefined) {
      output.writeFieldBegin('spamMessages', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRING, this.spamMessages.length);
      for (let iter1170 in this.spamMessages) {
        if (this.spamMessages.hasOwnProperty(iter1170)) {
          iter1170 = this.spamMessages[iter1170];
          output.writeString(iter1170);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportSpam_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportSpam_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSuggestRevisions_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSuggestRevisions_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSuggestRevisions_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.SuggestDictionaryRevisions(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.SuggestDictionaryRevisions();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSuggestRevisions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getPreviousMessagesV2WithReadCount_args = class {
  constructor(args) {
    this.messageBoxId = null;
    this.endMessageId = null;
    this.messagesCount = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.endMessageId !== undefined && args.endMessageId !== null) {
        this.endMessageId = new ttypes.MessageBoxV2MessageId(args.endMessageId);
      }
      if (args.messagesCount !== undefined && args.messagesCount !== null) {
        this.messagesCount = args.messagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.endMessageId = new ttypes.MessageBoxV2MessageId();
          this.endMessageId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.messagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getPreviousMessagesV2WithReadCount_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.endMessageId !== null && this.endMessageId !== undefined) {
      output.writeFieldBegin('endMessageId', Thrift.Type.STRUCT, 3);
      this.endMessageId.write(output);
      output.writeFieldEnd();
    }
    if (this.messagesCount !== null && this.messagesCount !== undefined) {
      output.writeFieldBegin('messagesCount', Thrift.Type.I32, 4);
      output.writeI32(this.messagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getPreviousMessagesV2WithReadCount_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Message]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31172 = input.readListBegin();
          const _size1171 = _rtmp31172.size || 0;
          for (let _i1173 = 0; _i1173 < _size1171; ++_i1173) {
            let elem1174 = null;
            elem1174 = new ttypes.Message();
            elem1174.read(input);
            this.success.push(elem1174);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getPreviousMessagesV2WithReadCount_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1175 in this.success) {
        if (this.success.hasOwnProperty(iter1175)) {
          iter1175 = this.success[iter1175];
          iter1175.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_fetchOperations_args = class {
  constructor(args) {
    this.localRev = null;
    this.count = null;
    if (args) {
      if (args.localRev !== undefined && args.localRev !== null) {
        this.localRev = args.localRev;
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.localRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.count = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_fetchOperations_args');
    if (this.localRev !== null && this.localRev !== undefined) {
      output.writeFieldBegin('localRev', Thrift.Type.I64, 2);
      output.writeI64(this.localRev);
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 3);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_fetchOperations_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.ShouldSyncException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Operation]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31177 = input.readListBegin();
          const _size1176 = _rtmp31177.size || 0;
          for (let _i1178 = 0; _i1178 < _size1176; ++_i1178) {
            let elem1179 = null;
            elem1179 = new ttypes.Operation();
            elem1179.read(input);
            this.success.push(elem1179);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.ShouldSyncException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_fetchOperations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1180 in this.success) {
        if (this.success.hasOwnProperty(iter1180)) {
          iter1180 = this.success[iter1180];
          iter1180.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWapDevice_args = class {
  constructor(args) {
    this.invitationHash = null;
    this.guidHash = null;
    this.email = null;
    this.deviceInfo = null;
    if (args) {
      if (args.invitationHash !== undefined && args.invitationHash !== null) {
        this.invitationHash = args.invitationHash;
      }
      if (args.guidHash !== undefined && args.guidHash !== null) {
        this.guidHash = args.guidHash;
      }
      if (args.email !== undefined && args.email !== null) {
        this.email = args.email;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.invitationHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.guidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.email = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWapDevice_args');
    if (this.invitationHash !== null && this.invitationHash !== undefined) {
      output.writeFieldBegin('invitationHash', Thrift.Type.STRING, 2);
      output.writeString(this.invitationHash);
      output.writeFieldEnd();
    }
    if (this.guidHash !== null && this.guidHash !== undefined) {
      output.writeFieldBegin('guidHash', Thrift.Type.STRING, 3);
      output.writeString(this.guidHash);
      output.writeFieldEnd();
    }
    if (this.email !== null && this.email !== undefined) {
      output.writeFieldBegin('email', Thrift.Type.STRING, 4);
      output.writeString(this.email);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 5);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWapDevice_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWapDevice_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRecentFriendRequests_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRecentFriendRequests_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRecentFriendRequests_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.FriendRequestsInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.FriendRequestsInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRecentFriendRequests_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyBuddyOnAir_args = class {
  constructor(args) {
    this.seq = null;
    this.receiverMids = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.receiverMids !== undefined && args.receiverMids !== null) {
        this.receiverMids = Thrift.copyList(args.receiverMids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.receiverMids = [];
          const _rtmp31182 = input.readListBegin();
          const _size1181 = _rtmp31182.size || 0;
          for (let _i1183 = 0; _i1183 < _size1181; ++_i1183) {
            let elem1184 = null;
            elem1184 = input.readString();
            this.receiverMids.push(elem1184);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyBuddyOnAir_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.receiverMids !== null && this.receiverMids !== undefined) {
      output.writeFieldBegin('receiverMids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.receiverMids.length);
      for (let iter1185 in this.receiverMids) {
        if (this.receiverMids.hasOwnProperty(iter1185)) {
          iter1185 = this.receiverMids[iter1185];
          output.writeString(iter1185);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyBuddyOnAir_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31187 = input.readMapBegin();
          const _size1186 = _rtmp31187.size || 0;
          for (let _i1188 = 0; _i1188 < _size1186; ++_i1188) {
            let key1189 = null;
            let val1190 = null;
            key1189 = input.readString();
            val1190 = input.readString();
            this.success[key1189] = val1190;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyBuddyOnAir_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter1191 in this.success) {
        if (this.success.hasOwnProperty(kiter1191)) {
          let viter1192 = this.success[kiter1191];
          output.writeString(kiter1191);
          output.writeString(viter1192);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getLastAnnouncementIndex_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getLastAnnouncementIndex_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getLastAnnouncementIndex_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getLastAnnouncementIndex_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessageAwaitCommit_args = class {
  constructor(args) {
    this.seq = null;
    this.message = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = new ttypes.Message(args.message);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.message = new ttypes.Message();
          this.message.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessageAwaitCommit_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRUCT, 2);
      this.message.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessageAwaitCommit_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.CommitMessageResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.CommitMessageResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessageAwaitCommit_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_negotiateE2EEPublicKey_args = class {
  constructor(args) {
    this.mid = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_negotiateE2EEPublicKey_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_negotiateE2EEPublicKey_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.E2EENegotiationResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.E2EENegotiationResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_negotiateE2EEPublicKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerE2EEGroupKey_args = class {
  constructor(args) {
    this.version = null;
    this.chatMid = null;
    this.members = null;
    this.keyIds = null;
    this.encryptedSharedKeys = null;
    if (args) {
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      }
      if (args.chatMid !== undefined && args.chatMid !== null) {
        this.chatMid = args.chatMid;
      }
      if (args.members !== undefined && args.members !== null) {
        this.members = Thrift.copyList(args.members, [null]);
      }
      if (args.keyIds !== undefined && args.keyIds !== null) {
        this.keyIds = Thrift.copyList(args.keyIds, [null]);
      }
      if (args.encryptedSharedKeys !== undefined && args.encryptedSharedKeys !== null) {
        this.encryptedSharedKeys = Thrift.copyList(args.encryptedSharedKeys, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.version = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.chatMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.members = [];
          const _rtmp31194 = input.readListBegin();
          const _size1193 = _rtmp31194.size || 0;
          for (let _i1195 = 0; _i1195 < _size1193; ++_i1195) {
            let elem1196 = null;
            elem1196 = input.readString();
            this.members.push(elem1196);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.keyIds = [];
          const _rtmp31198 = input.readListBegin();
          const _size1197 = _rtmp31198.size || 0;
          for (let _i1199 = 0; _i1199 < _size1197; ++_i1199) {
            let elem1200 = null;
            elem1200 = input.readI32();
            this.keyIds.push(elem1200);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.encryptedSharedKeys = [];
          const _rtmp31202 = input.readListBegin();
          const _size1201 = _rtmp31202.size || 0;
          for (let _i1203 = 0; _i1203 < _size1201; ++_i1203) {
            let elem1204 = null;
            elem1204 = input.readBinary();
            this.encryptedSharedKeys.push(elem1204);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerE2EEGroupKey_args');
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.I32, 2);
      output.writeI32(this.version);
      output.writeFieldEnd();
    }
    if (this.chatMid !== null && this.chatMid !== undefined) {
      output.writeFieldBegin('chatMid', Thrift.Type.STRING, 3);
      output.writeString(this.chatMid);
      output.writeFieldEnd();
    }
    if (this.members !== null && this.members !== undefined) {
      output.writeFieldBegin('members', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.members.length);
      for (let iter1205 in this.members) {
        if (this.members.hasOwnProperty(iter1205)) {
          iter1205 = this.members[iter1205];
          output.writeString(iter1205);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.keyIds !== null && this.keyIds !== undefined) {
      output.writeFieldBegin('keyIds', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.I32, this.keyIds.length);
      for (let iter1206 in this.keyIds) {
        if (this.keyIds.hasOwnProperty(iter1206)) {
          iter1206 = this.keyIds[iter1206];
          output.writeI32(iter1206);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.encryptedSharedKeys !== null && this.encryptedSharedKeys !== undefined) {
      output.writeFieldBegin('encryptedSharedKeys', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.encryptedSharedKeys.length);
      for (let iter1207 in this.encryptedSharedKeys) {
        if (this.encryptedSharedKeys.hasOwnProperty(iter1207)) {
          iter1207 = this.encryptedSharedKeys[iter1207];
          output.writeBinary(iter1207);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerE2EEGroupKey_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.E2EEGroupSharedKey(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.E2EEGroupSharedKey();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerE2EEGroupKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findSnsIdUserStatus_args = class {
  constructor(args) {
    this.snsIdType = null;
    this.snsAccessToken = null;
    this.udidHash = null;
    this.migrationPincodeSessionId = null;
    this.oldUdidHash = null;
    if (args) {
      if (args.snsIdType !== undefined && args.snsIdType !== null) {
        this.snsIdType = args.snsIdType;
      }
      if (args.snsAccessToken !== undefined && args.snsAccessToken !== null) {
        this.snsAccessToken = args.snsAccessToken;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
      if (args.oldUdidHash !== undefined && args.oldUdidHash !== null) {
        this.oldUdidHash = args.oldUdidHash;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.snsIdType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.snsAccessToken = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.oldUdidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findSnsIdUserStatus_args');
    if (this.snsIdType !== null && this.snsIdType !== undefined) {
      output.writeFieldBegin('snsIdType', Thrift.Type.I32, 2);
      output.writeI32(this.snsIdType);
      output.writeFieldEnd();
    }
    if (this.snsAccessToken !== null && this.snsAccessToken !== undefined) {
      output.writeFieldBegin('snsAccessToken', Thrift.Type.STRING, 3);
      output.writeString(this.snsAccessToken);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 4);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 5);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    if (this.oldUdidHash !== null && this.oldUdidHash !== undefined) {
      output.writeFieldBegin('oldUdidHash', Thrift.Type.STRING, 6);
      output.writeString(this.oldUdidHash);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findSnsIdUserStatus_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.SnsIdUserStatus(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.SnsIdUserStatus();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findSnsIdUserStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyUpdated_args = class {
  constructor(args) {
    this.lastRev = null;
    this.deviceInfo = null;
    this.udidHash = null;
    this.oldUdidHash = null;
    if (args) {
      if (args.lastRev !== undefined && args.lastRev !== null) {
        this.lastRev = args.lastRev;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.oldUdidHash !== undefined && args.oldUdidHash !== null) {
        this.oldUdidHash = args.oldUdidHash;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.lastRev = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.oldUdidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyUpdated_args');
    if (this.lastRev !== null && this.lastRev !== undefined) {
      output.writeFieldBegin('lastRev', Thrift.Type.I64, 2);
      output.writeI64(this.lastRev);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 3);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 4);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.oldUdidHash !== null && this.oldUdidHash !== undefined) {
      output.writeFieldBegin('oldUdidHash', Thrift.Type.STRING, 5);
      output.writeString(this.oldUdidHash);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyUpdated_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyUpdated_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportGroups_args = class {
  constructor(args) {
    this.syncOpRevision = null;
    this.groups = null;
    if (args) {
      if (args.syncOpRevision !== undefined && args.syncOpRevision !== null) {
        this.syncOpRevision = args.syncOpRevision;
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [ttypes.Group]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.syncOpRevision = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp31209 = input.readListBegin();
          const _size1208 = _rtmp31209.size || 0;
          for (let _i1210 = 0; _i1210 < _size1208; ++_i1210) {
            let elem1211 = null;
            elem1211 = new ttypes.Group();
            elem1211.read(input);
            this.groups.push(elem1211);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportGroups_args');
    if (this.syncOpRevision !== null && this.syncOpRevision !== undefined) {
      output.writeFieldBegin('syncOpRevision', Thrift.Type.I64, 2);
      output.writeI64(this.syncOpRevision);
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.groups.length);
      for (let iter1212 in this.groups) {
        if (this.groups.hasOwnProperty(iter1212)) {
          iter1212 = this.groups[iter1212];
          iter1212.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportGroups_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportGroups_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getNotificationPolicy_args = class {
  constructor(args) {
    this.carrier = null;
    if (args) {
      if (args.carrier !== undefined && args.carrier !== null) {
        this.carrier = args.carrier;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.carrier = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getNotificationPolicy_args');
    if (this.carrier !== null && this.carrier !== undefined) {
      output.writeFieldBegin('carrier', Thrift.Type.I32, 2);
      output.writeI32(this.carrier);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getNotificationPolicy_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31214 = input.readListBegin();
          const _size1213 = _rtmp31214.size || 0;
          for (let _i1215 = 0; _i1215 < _size1213; ++_i1215) {
            let elem1216 = null;
            elem1216 = input.readI32();
            this.success.push(elem1216);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getNotificationPolicy_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.I32, this.success.length);
      for (let iter1217 in this.success) {
        if (this.success.hasOwnProperty(iter1217)) {
          iter1217 = this.success[iter1217];
          output.writeI32(iter1217);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactsByUserid_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.userid = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.userid !== undefined && args.userid !== null) {
        this.userid = args.userid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactsByUserid_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.userid !== null && this.userid !== undefined) {
      output.writeFieldBegin('userid', Thrift.Type.STRING, 2);
      output.writeString(this.userid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactsByUserid_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [ttypes.Contact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31219 = input.readMapBegin();
          const _size1218 = _rtmp31219.size || 0;
          for (let _i1220 = 0; _i1220 < _size1218; ++_i1220) {
            let key1221 = null;
            let val1222 = null;
            key1221 = input.readString();
            val1222 = new ttypes.Contact();
            val1222.read(input);
            this.success[key1221] = val1222;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactsByUserid_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter1223 in this.success) {
        if (this.success.hasOwnProperty(kiter1223)) {
          let viter1224 = this.success[kiter1223];
          output.writeString(kiter1223);
          viter1224.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getLastE2EEGroupSharedKey_args = class {
  constructor(args) {
    this.version = null;
    this.chatMid = null;
    if (args) {
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      }
      if (args.chatMid !== undefined && args.chatMid !== null) {
        this.chatMid = args.chatMid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.version = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.chatMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getLastE2EEGroupSharedKey_args');
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.I32, 2);
      output.writeI32(this.version);
      output.writeFieldEnd();
    }
    if (this.chatMid !== null && this.chatMid !== undefined) {
      output.writeFieldBegin('chatMid', Thrift.Type.STRING, 3);
      output.writeString(this.chatMid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getLastE2EEGroupSharedKey_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.E2EEGroupSharedKey(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.E2EEGroupSharedKey();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getLastE2EEGroupSharedKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyUpdatePublicKeychain_args = class {
  constructor(args) {
    this.mid = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyUpdatePublicKeychain_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 1);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyUpdatePublicKeychain_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyUpdatePublicKeychain_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_report_args = class {
  constructor(args) {
    this.syncOpRevision = null;
    this.category = null;
    this.report = null;
    if (args) {
      if (args.syncOpRevision !== undefined && args.syncOpRevision !== null) {
        this.syncOpRevision = args.syncOpRevision;
      }
      if (args.category !== undefined && args.category !== null) {
        this.category = args.category;
      }
      if (args.report !== undefined && args.report !== null) {
        this.report = args.report;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.syncOpRevision = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.category = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.report = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_report_args');
    if (this.syncOpRevision !== null && this.syncOpRevision !== undefined) {
      output.writeFieldBegin('syncOpRevision', Thrift.Type.I64, 2);
      output.writeI64(this.syncOpRevision);
      output.writeFieldEnd();
    }
    if (this.category !== null && this.category !== undefined) {
      output.writeFieldBegin('category', Thrift.Type.I32, 3);
      output.writeI32(this.category);
      output.writeFieldEnd();
    }
    if (this.report !== null && this.report !== undefined) {
      output.writeFieldBegin('report', Thrift.Type.STRING, 4);
      output.writeString(this.report);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_report_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_report_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acceptGroupInvitationByTicket_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.groupMid = null;
    this.ticketId = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.groupMid !== undefined && args.groupMid !== null) {
        this.groupMid = args.groupMid;
      }
      if (args.ticketId !== undefined && args.ticketId !== null) {
        this.ticketId = args.ticketId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.ticketId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acceptGroupInvitationByTicket_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.groupMid !== null && this.groupMid !== undefined) {
      output.writeFieldBegin('groupMid', Thrift.Type.STRING, 2);
      output.writeString(this.groupMid);
      output.writeFieldEnd();
    }
    if (this.ticketId !== null && this.ticketId !== undefined) {
      output.writeFieldBegin('ticketId', Thrift.Type.STRING, 3);
      output.writeString(this.ticketId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acceptGroupInvitationByTicket_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acceptGroupInvitationByTicket_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getContactRegistration_args = class {
  constructor(args) {
    this.id = null;
    this.type = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getContactRegistration_args');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 2);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getContactRegistration_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ContactRegistration(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ContactRegistration();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getContactRegistration_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateContactSetting_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.mid = null;
    this.flag = null;
    this.value = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.flag !== undefined && args.flag !== null) {
        this.flag = args.flag;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.flag = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateContactSetting_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.flag !== null && this.flag !== undefined) {
      output.writeFieldBegin('flag', Thrift.Type.I32, 3);
      output.writeI32(this.flag);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 4);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateContactSetting_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateContactSetting_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getContactWithFriendRequestStatus_args = class {
  constructor(args) {
    this.id = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getContactWithFriendRequestStatus_args');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getContactWithFriendRequestStatus_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Contact(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Contact();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getContactWithFriendRequestStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxListByStatus_args = class {
  constructor(args) {
    this.channelId = null;
    this.lastMessagesCount = null;
    this.status = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.lastMessagesCount !== undefined && args.lastMessagesCount !== null) {
        this.lastMessagesCount = args.lastMessagesCount;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.lastMessagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxListByStatus_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 2);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.lastMessagesCount !== null && this.lastMessagesCount !== undefined) {
      output.writeFieldBegin('lastMessagesCount', Thrift.Type.I32, 3);
      output.writeI32(this.lastMessagesCount);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 4);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxListByStatus_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TMessageBox]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31226 = input.readListBegin();
          const _size1225 = _rtmp31226.size || 0;
          for (let _i1227 = 0; _i1227 < _size1225; ++_i1227) {
            let elem1228 = null;
            elem1228 = new ttypes.TMessageBox();
            elem1228.read(input);
            this.success.push(elem1228);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxListByStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1229 in this.success) {
        if (this.success.hasOwnProperty(iter1229)) {
          iter1229 = this.success[iter1229];
          iter1229.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_openProximityMatch_args = class {
  constructor(args) {
    this.location = null;
    if (args) {
      if (args.location !== undefined && args.location !== null) {
        this.location = new ttypes.Location(args.location);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.location = new ttypes.Location();
          this.location.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_openProximityMatch_args');
    if (this.location !== null && this.location !== undefined) {
      output.writeFieldBegin('location', Thrift.Type.STRUCT, 2);
      this.location.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_openProximityMatch_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_openProximityMatch_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_logout_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_logout_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_logout_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_logout_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getE2EEPublicKey_args = class {
  constructor(args) {
    this.mid = null;
    this.version = null;
    this.keyId = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      }
      if (args.keyId !== undefined && args.keyId !== null) {
        this.keyId = args.keyId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.version = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.keyId = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getE2EEPublicKey_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.I32, 3);
      output.writeI32(this.version);
      output.writeFieldEnd();
    }
    if (this.keyId !== null && this.keyId !== undefined) {
      output.writeFieldBegin('keyId', Thrift.Type.I32, 4);
      output.writeI32(this.keyId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getE2EEPublicKey_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.E2EEPublicKey(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.E2EEPublicKey();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getE2EEPublicKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerUserid_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.userid = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.userid !== undefined && args.userid !== null) {
        this.userid = args.userid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerUserid_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.userid !== null && this.userid !== undefined) {
      output.writeFieldBegin('userid', Thrift.Type.STRING, 2);
      output.writeString(this.userid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerUserid_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerUserid_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportContacts_args = class {
  constructor(args) {
    this.syncOpRevision = null;
    this.category = null;
    this.contactReports = null;
    this.actionType = null;
    if (args) {
      if (args.syncOpRevision !== undefined && args.syncOpRevision !== null) {
        this.syncOpRevision = args.syncOpRevision;
      }
      if (args.category !== undefined && args.category !== null) {
        this.category = args.category;
      }
      if (args.contactReports !== undefined && args.contactReports !== null) {
        this.contactReports = Thrift.copyList(args.contactReports, [ttypes.ContactReport]);
      }
      if (args.actionType !== undefined && args.actionType !== null) {
        this.actionType = args.actionType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.syncOpRevision = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.category = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.contactReports = [];
          const _rtmp31231 = input.readListBegin();
          const _size1230 = _rtmp31231.size || 0;
          for (let _i1232 = 0; _i1232 < _size1230; ++_i1232) {
            let elem1233 = null;
            elem1233 = new ttypes.ContactReport();
            elem1233.read(input);
            this.contactReports.push(elem1233);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.actionType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportContacts_args');
    if (this.syncOpRevision !== null && this.syncOpRevision !== undefined) {
      output.writeFieldBegin('syncOpRevision', Thrift.Type.I64, 2);
      output.writeI64(this.syncOpRevision);
      output.writeFieldEnd();
    }
    if (this.category !== null && this.category !== undefined) {
      output.writeFieldBegin('category', Thrift.Type.I32, 3);
      output.writeI32(this.category);
      output.writeFieldEnd();
    }
    if (this.contactReports !== null && this.contactReports !== undefined) {
      output.writeFieldBegin('contactReports', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.contactReports.length);
      for (let iter1234 in this.contactReports) {
        if (this.contactReports.hasOwnProperty(iter1234)) {
          iter1234 = this.contactReports[iter1234];
          iter1234.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.actionType !== null && this.actionType !== undefined) {
      output.writeFieldBegin('actionType', Thrift.Type.I32, 5);
      output.writeI32(this.actionType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportContacts_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.ContactReportResult]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31236 = input.readListBegin();
          const _size1235 = _rtmp31236.size || 0;
          for (let _i1237 = 0; _i1237 < _size1235; ++_i1237) {
            let elem1238 = null;
            elem1238 = new ttypes.ContactReportResult();
            elem1238.read(input);
            this.success.push(elem1238);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportContacts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1239 in this.success) {
        if (this.success.hasOwnProperty(iter1239)) {
          iter1239 = this.success[iter1239];
          iter1239.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getPublicKeychain_args = class {
  constructor(args) {
    this.mid = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getPublicKeychain_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 1);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getPublicKeychain_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.PublicKeychain(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.PublicKeychain();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getPublicKeychain_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendContentReceipt_args = class {
  constructor(args) {
    this.seq = null;
    this.consumer = null;
    this.messageId = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.consumer !== undefined && args.consumer !== null) {
        this.consumer = args.consumer;
      }
      if (args.messageId !== undefined && args.messageId !== null) {
        this.messageId = args.messageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.consumer = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.messageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendContentReceipt_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.consumer !== null && this.consumer !== undefined) {
      output.writeFieldBegin('consumer', Thrift.Type.STRING, 2);
      output.writeString(this.consumer);
      output.writeFieldEnd();
    }
    if (this.messageId !== null && this.messageId !== undefined) {
      output.writeFieldBegin('messageId', Thrift.Type.STRING, 3);
      output.writeString(this.messageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendContentReceipt_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendContentReceipt_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_respondResendMessage_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.receiverMid = null;
    this.originalMessageId = null;
    this.resendMessage = null;
    this.errorCode = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.receiverMid !== undefined && args.receiverMid !== null) {
        this.receiverMid = args.receiverMid;
      }
      if (args.originalMessageId !== undefined && args.originalMessageId !== null) {
        this.originalMessageId = args.originalMessageId;
      }
      if (args.resendMessage !== undefined && args.resendMessage !== null) {
        this.resendMessage = new ttypes.Message(args.resendMessage);
      }
      if (args.errorCode !== undefined && args.errorCode !== null) {
        this.errorCode = args.errorCode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.receiverMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.originalMessageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.resendMessage = new ttypes.Message();
          this.resendMessage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.errorCode = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_respondResendMessage_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.receiverMid !== null && this.receiverMid !== undefined) {
      output.writeFieldBegin('receiverMid', Thrift.Type.STRING, 2);
      output.writeString(this.receiverMid);
      output.writeFieldEnd();
    }
    if (this.originalMessageId !== null && this.originalMessageId !== undefined) {
      output.writeFieldBegin('originalMessageId', Thrift.Type.STRING, 3);
      output.writeString(this.originalMessageId);
      output.writeFieldEnd();
    }
    if (this.resendMessage !== null && this.resendMessage !== undefined) {
      output.writeFieldBegin('resendMessage', Thrift.Type.STRUCT, 4);
      this.resendMessage.write(output);
      output.writeFieldEnd();
    }
    if (this.errorCode !== null && this.errorCode !== undefined) {
      output.writeFieldBegin('errorCode', Thrift.Type.I32, 5);
      output.writeI32(this.errorCode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_respondResendMessage_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_respondResendMessage_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAllRoomIds_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAllRoomIds_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAllRoomIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.SET) {
          this.success = [];
          const _rtmp31241 = input.readSetBegin();
          const _size1240 = _rtmp31241.size || 0;
          for (let _i1242 = 0; _i1242 < _size1240; ++_i1242) {
            let elem1243 = null;
            elem1243 = input.readString();
            this.success.push(elem1243);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAllRoomIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.SET, 0);
      output.writeSetBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1244 in this.success) {
        if (this.success.hasOwnProperty(iter1244)) {
          iter1244 = this.success[iter1244];
          output.writeString(iter1244);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestE2EEKeyExchange_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.temporalPublicKey = null;
    this.publicKey = null;
    this.verifier = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.temporalPublicKey !== undefined && args.temporalPublicKey !== null) {
        this.temporalPublicKey = args.temporalPublicKey;
      }
      if (args.publicKey !== undefined && args.publicKey !== null) {
        this.publicKey = new ttypes.E2EEPublicKey(args.publicKey);
      }
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.temporalPublicKey = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.publicKey = new ttypes.E2EEPublicKey();
          this.publicKey.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestE2EEKeyExchange_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.temporalPublicKey !== null && this.temporalPublicKey !== undefined) {
      output.writeFieldBegin('temporalPublicKey', Thrift.Type.STRING, 2);
      output.writeBinary(this.temporalPublicKey);
      output.writeFieldEnd();
    }
    if (this.publicKey !== null && this.publicKey !== undefined) {
      output.writeFieldBegin('publicKey', Thrift.Type.STRUCT, 3);
      this.publicKey.write(output);
      output.writeFieldEnd();
    }
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 4);
      output.writeBinary(this.verifier);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_requestE2EEKeyExchange_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_requestE2EEKeyExchange_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_disableNearby_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_disableNearby_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_disableNearby_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_disableNearby_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createQrcodeBase64Image_args = class {
  constructor(args) {
    this.url = null;
    this.characterSet = null;
    this.imageSize = null;
    this.x = null;
    this.y = null;
    this.width = null;
    this.height = null;
    if (args) {
      if (args.url !== undefined && args.url !== null) {
        this.url = args.url;
      }
      if (args.characterSet !== undefined && args.characterSet !== null) {
        this.characterSet = args.characterSet;
      }
      if (args.imageSize !== undefined && args.imageSize !== null) {
        this.imageSize = args.imageSize;
      }
      if (args.x !== undefined && args.x !== null) {
        this.x = args.x;
      }
      if (args.y !== undefined && args.y !== null) {
        this.y = args.y;
      }
      if (args.width !== undefined && args.width !== null) {
        this.width = args.width;
      }
      if (args.height !== undefined && args.height !== null) {
        this.height = args.height;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.url = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.characterSet = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.imageSize = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.x = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.y = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.width = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.height = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createQrcodeBase64Image_args');
    if (this.url !== null && this.url !== undefined) {
      output.writeFieldBegin('url', Thrift.Type.STRING, 2);
      output.writeString(this.url);
      output.writeFieldEnd();
    }
    if (this.characterSet !== null && this.characterSet !== undefined) {
      output.writeFieldBegin('characterSet', Thrift.Type.STRING, 3);
      output.writeString(this.characterSet);
      output.writeFieldEnd();
    }
    if (this.imageSize !== null && this.imageSize !== undefined) {
      output.writeFieldBegin('imageSize', Thrift.Type.I32, 4);
      output.writeI32(this.imageSize);
      output.writeFieldEnd();
    }
    if (this.x !== null && this.x !== undefined) {
      output.writeFieldBegin('x', Thrift.Type.I32, 5);
      output.writeI32(this.x);
      output.writeFieldEnd();
    }
    if (this.y !== null && this.y !== undefined) {
      output.writeFieldBegin('y', Thrift.Type.I32, 6);
      output.writeI32(this.y);
      output.writeFieldEnd();
    }
    if (this.width !== null && this.width !== undefined) {
      output.writeFieldBegin('width', Thrift.Type.I32, 7);
      output.writeI32(this.width);
      output.writeFieldEnd();
    }
    if (this.height !== null && this.height !== undefined) {
      output.writeFieldBegin('height', Thrift.Type.I32, 8);
      output.writeI32(this.height);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createQrcodeBase64Image_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createQrcodeBase64Image_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxList_args = class {
  constructor(args) {
    this.channelId = null;
    this.lastMessagesCount = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.lastMessagesCount !== undefined && args.lastMessagesCount !== null) {
        this.lastMessagesCount = args.lastMessagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.lastMessagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxList_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 2);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.lastMessagesCount !== null && this.lastMessagesCount !== undefined) {
      output.writeFieldBegin('lastMessagesCount', Thrift.Type.I32, 3);
      output.writeI32(this.lastMessagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxList_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TMessageBox]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31246 = input.readListBegin();
          const _size1245 = _rtmp31246.size || 0;
          for (let _i1247 = 0; _i1247 < _size1245; ++_i1247) {
            let elem1248 = null;
            elem1248 = new ttypes.TMessageBox();
            elem1248.read(input);
            this.success.push(elem1248);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1249 in this.success) {
        if (this.success.hasOwnProperty(iter1249)) {
          iter1249 = this.success[iter1249];
          iter1249.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_respondE2EEKeyExchange_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.encryptedKeyChain = null;
    this.hashKeyChain = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.encryptedKeyChain !== undefined && args.encryptedKeyChain !== null) {
        this.encryptedKeyChain = args.encryptedKeyChain;
      }
      if (args.hashKeyChain !== undefined && args.hashKeyChain !== null) {
        this.hashKeyChain = args.hashKeyChain;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.encryptedKeyChain = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.hashKeyChain = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_respondE2EEKeyExchange_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.encryptedKeyChain !== null && this.encryptedKeyChain !== undefined) {
      output.writeFieldBegin('encryptedKeyChain', Thrift.Type.STRING, 2);
      output.writeBinary(this.encryptedKeyChain);
      output.writeFieldEnd();
    }
    if (this.hashKeyChain !== null && this.hashKeyChain !== undefined) {
      output.writeFieldBegin('hashKeyChain', Thrift.Type.STRING, 3);
      output.writeBinary(this.hashKeyChain);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_respondE2EEKeyExchange_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_respondE2EEKeyExchange_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyQrcode_args = class {
  constructor(args) {
    this.verifier = null;
    this.pinCode = null;
    if (args) {
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
      if (args.pinCode !== undefined && args.pinCode !== null) {
        this.pinCode = args.pinCode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pinCode = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyQrcode_args');
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 2);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    if (this.pinCode !== null && this.pinCode !== undefined) {
      output.writeFieldBegin('pinCode', Thrift.Type.STRING, 3);
      output.writeString(this.pinCode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyQrcode_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyQrcode_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateNotificationTokenWithBytes_args = class {
  constructor(args) {
    this.token = null;
    this.type = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateNotificationTokenWithBytes_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 2);
      output.writeBinary(this.token);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateNotificationTokenWithBytes_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateNotificationTokenWithBytes_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getPreviousMessages_args = class {
  constructor(args) {
    this.messageBoxId = null;
    this.endSeq = null;
    this.messagesCount = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.endSeq !== undefined && args.endSeq !== null) {
        this.endSeq = args.endSeq;
      }
      if (args.messagesCount !== undefined && args.messagesCount !== null) {
        this.messagesCount = args.messagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endSeq = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.messagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getPreviousMessages_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.endSeq !== null && this.endSeq !== undefined) {
      output.writeFieldBegin('endSeq', Thrift.Type.I64, 3);
      output.writeI64(this.endSeq);
      output.writeFieldEnd();
    }
    if (this.messagesCount !== null && this.messagesCount !== undefined) {
      output.writeFieldBegin('messagesCount', Thrift.Type.I32, 4);
      output.writeI32(this.messagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getPreviousMessages_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Message]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31251 = input.readListBegin();
          const _size1250 = _rtmp31251.size || 0;
          for (let _i1252 = 0; _i1252 < _size1250; ++_i1252) {
            let elem1253 = null;
            elem1253 = new ttypes.Message();
            elem1253.read(input);
            this.success.push(elem1253);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getPreviousMessages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1254 in this.success) {
        if (this.success.hasOwnProperty(iter1254)) {
          iter1254 = this.success[iter1254];
          iter1254.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSettings_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSettings_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSettings_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Settings(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Settings();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSettings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getLastE2EEPublicKeys_args = class {
  constructor(args) {
    this.chatMid = null;
    if (args) {
      if (args.chatMid !== undefined && args.chatMid !== null) {
        this.chatMid = args.chatMid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getLastE2EEPublicKeys_args');
    if (this.chatMid !== null && this.chatMid !== undefined) {
      output.writeFieldBegin('chatMid', Thrift.Type.STRING, 2);
      output.writeString(this.chatMid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getLastE2EEPublicKeys_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [ttypes.E2EEPublicKey]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31256 = input.readMapBegin();
          const _size1255 = _rtmp31256.size || 0;
          for (let _i1257 = 0; _i1257 < _size1255; ++_i1257) {
            let key1258 = null;
            let val1259 = null;
            key1258 = input.readString();
            val1259 = new ttypes.E2EEPublicKey();
            val1259.read(input);
            this.success[key1258] = val1259;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getLastE2EEPublicKeys_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter1260 in this.success) {
        if (this.success.hasOwnProperty(kiter1260)) {
          let viter1261 = this.success[kiter1260];
          output.writeString(kiter1260);
          viter1261.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerE2EEPublicKey_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.publicKey = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.publicKey !== undefined && args.publicKey !== null) {
        this.publicKey = new ttypes.E2EEPublicKey(args.publicKey);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.publicKey = new ttypes.E2EEPublicKey();
          this.publicKey.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerE2EEPublicKey_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.publicKey !== null && this.publicKey !== undefined) {
      output.writeFieldBegin('publicKey', Thrift.Type.STRUCT, 2);
      this.publicKey.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerE2EEPublicKey_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.E2EEPublicKey(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.E2EEPublicKey();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerE2EEPublicKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acquireCallTicket_args = class {
  constructor(args) {
    this.to = null;
    if (args) {
      if (args.to !== undefined && args.to !== null) {
        this.to = args.to;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.to = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acquireCallTicket_args');
    if (this.to !== null && this.to !== undefined) {
      output.writeFieldBegin('to', Thrift.Type.STRING, 2);
      output.writeString(this.to);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acquireCallTicket_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acquireCallTicket_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_inviteIntoGroup_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.groupId = null;
    this.contactIds = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
      if (args.contactIds !== undefined && args.contactIds !== null) {
        this.contactIds = Thrift.copyList(args.contactIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.contactIds = [];
          const _rtmp31263 = input.readListBegin();
          const _size1262 = _rtmp31263.size || 0;
          for (let _i1264 = 0; _i1264 < _size1262; ++_i1264) {
            let elem1265 = null;
            elem1265 = input.readString();
            this.contactIds.push(elem1265);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_inviteIntoGroup_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    if (this.contactIds !== null && this.contactIds !== undefined) {
      output.writeFieldBegin('contactIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.contactIds.length);
      for (let iter1266 in this.contactIds) {
        if (this.contactIds.hasOwnProperty(iter1266)) {
          iter1266 = this.contactIds[iter1266];
          output.writeString(iter1266);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_inviteIntoGroup_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_inviteIntoGroup_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_makeUserAddMyselfAsContact_args = class {
  constructor(args) {
    this.contactOwnerMid = null;
    if (args) {
      if (args.contactOwnerMid !== undefined && args.contactOwnerMid !== null) {
        this.contactOwnerMid = args.contactOwnerMid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.contactOwnerMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_makeUserAddMyselfAsContact_args');
    if (this.contactOwnerMid !== null && this.contactOwnerMid !== undefined) {
      output.writeFieldBegin('contactOwnerMid', Thrift.Type.STRING, 1);
      output.writeString(this.contactOwnerMid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_makeUserAddMyselfAsContact_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ContactTransition(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ContactTransition();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_makeUserAddMyselfAsContact_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeMessageFromMyHome_args = class {
  constructor(args) {
    this.messageId = null;
    if (args) {
      if (args.messageId !== undefined && args.messageId !== null) {
        this.messageId = args.messageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeMessageFromMyHome_args');
    if (this.messageId !== null && this.messageId !== undefined) {
      output.writeFieldBegin('messageId', Thrift.Type.STRING, 2);
      output.writeString(this.messageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeMessageFromMyHome_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeMessageFromMyHome_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_commitSendMessages_args = class {
  constructor(args) {
    this.seq = null;
    this.messageIds = null;
    this.receiverMids = null;
    this.onlyToFollowers = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.messageIds !== undefined && args.messageIds !== null) {
        this.messageIds = Thrift.copyList(args.messageIds, [null]);
      }
      if (args.receiverMids !== undefined && args.receiverMids !== null) {
        this.receiverMids = Thrift.copyList(args.receiverMids, [null]);
      }
      if (args.onlyToFollowers !== undefined && args.onlyToFollowers !== null) {
        this.onlyToFollowers = args.onlyToFollowers;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.messageIds = [];
          const _rtmp31268 = input.readListBegin();
          const _size1267 = _rtmp31268.size || 0;
          for (let _i1269 = 0; _i1269 < _size1267; ++_i1269) {
            let elem1270 = null;
            elem1270 = input.readString();
            this.messageIds.push(elem1270);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.receiverMids = [];
          const _rtmp31272 = input.readListBegin();
          const _size1271 = _rtmp31272.size || 0;
          for (let _i1273 = 0; _i1273 < _size1271; ++_i1273) {
            let elem1274 = null;
            elem1274 = input.readString();
            this.receiverMids.push(elem1274);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.onlyToFollowers = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_commitSendMessages_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.messageIds !== null && this.messageIds !== undefined) {
      output.writeFieldBegin('messageIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.messageIds.length);
      for (let iter1275 in this.messageIds) {
        if (this.messageIds.hasOwnProperty(iter1275)) {
          iter1275 = this.messageIds[iter1275];
          output.writeString(iter1275);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.receiverMids !== null && this.receiverMids !== undefined) {
      output.writeFieldBegin('receiverMids', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.receiverMids.length);
      for (let iter1276 in this.receiverMids) {
        if (this.receiverMids.hasOwnProperty(iter1276)) {
          iter1276 = this.receiverMids[iter1276];
          output.writeString(iter1276);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.onlyToFollowers !== null && this.onlyToFollowers !== undefined) {
      output.writeFieldBegin('onlyToFollowers', Thrift.Type.BOOL, 4);
      output.writeBool(this.onlyToFollowers);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_commitSendMessages_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31278 = input.readMapBegin();
          const _size1277 = _rtmp31278.size || 0;
          for (let _i1279 = 0; _i1279 < _size1277; ++_i1279) {
            let key1280 = null;
            let val1281 = null;
            key1280 = input.readString();
            val1281 = input.readString();
            this.success[key1280] = val1281;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_commitSendMessages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter1282 in this.success) {
        if (this.success.hasOwnProperty(kiter1282)) {
          let viter1283 = this.success[kiter1282];
          output.writeString(kiter1282);
          output.writeString(viter1283);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithPhoneNumberAndPassword_args = class {
  constructor(args) {
    this.sessionId = null;
    this.keynm = null;
    this.encrypted = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.keynm !== undefined && args.keynm !== null) {
        this.keynm = args.keynm;
      }
      if (args.encrypted !== undefined && args.encrypted !== null) {
        this.encrypted = args.encrypted;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.keynm = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.encrypted = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithPhoneNumberAndPassword_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.keynm !== null && this.keynm !== undefined) {
      output.writeFieldBegin('keynm', Thrift.Type.STRING, 3);
      output.writeString(this.keynm);
      output.writeFieldEnd();
    }
    if (this.encrypted !== null && this.encrypted !== undefined) {
      output.writeFieldBegin('encrypted', Thrift.Type.STRING, 4);
      output.writeString(this.encrypted);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerWithPhoneNumberAndPassword_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.RegisterWithPhoneNumberResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.RegisterWithPhoneNumberResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerWithPhoneNumberAndPassword_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_leaveGroup_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.groupId = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_leaveGroup_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_leaveGroup_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_leaveGroup_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAnalyticsInfo_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAnalyticsInfo_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAnalyticsInfo_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.AnalyticsInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.AnalyticsInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAnalyticsInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportClientStatistics_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.category = null;
    this.count = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.category !== undefined && args.category !== null) {
        this.category = args.category;
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.category = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.count = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportClientStatistics_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.category !== null && this.category !== undefined) {
      output.writeFieldBegin('category', Thrift.Type.I32, 2);
      output.writeI32(this.category);
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 3);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportClientStatistics_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportClientStatistics_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acceptProximityMatches_args = class {
  constructor(args) {
    this.sessionId = null;
    this.ids = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.ids !== undefined && args.ids !== null) {
        this.ids = Thrift.copyList(args.ids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.ids = [];
          const _rtmp31285 = input.readSetBegin();
          const _size1284 = _rtmp31285.size || 0;
          for (let _i1286 = 0; _i1286 < _size1284; ++_i1286) {
            let elem1287 = null;
            elem1287 = input.readString();
            this.ids.push(elem1287);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acceptProximityMatches_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.ids !== null && this.ids !== undefined) {
      output.writeFieldBegin('ids', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.STRING, this.ids.length);
      for (let iter1288 in this.ids) {
        if (this.ids.hasOwnProperty(iter1288)) {
          iter1288 = this.ids[iter1288];
          output.writeString(iter1288);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acceptProximityMatches_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acceptProximityMatches_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroup_args = class {
  constructor(args) {
    this.groupId = null;
    if (args) {
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroup_args');
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroup_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Group(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Group();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_clearIdentityCredential_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_clearIdentityCredential_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_clearIdentityCredential_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_clearIdentityCredential_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getUpdatedMessageBoxIds_args = class {
  constructor(args) {
    this.startMessageId = null;
    this.startMessageBoxId = null;
    this.messageBoxCount = null;
    if (args) {
      if (args.startMessageId !== undefined && args.startMessageId !== null) {
        this.startMessageId = new ttypes.MessageBoxV2MessageId(args.startMessageId);
      }
      if (args.startMessageBoxId !== undefined && args.startMessageBoxId !== null) {
        this.startMessageBoxId = args.startMessageBoxId;
      }
      if (args.messageBoxCount !== undefined && args.messageBoxCount !== null) {
        this.messageBoxCount = args.messageBoxCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.startMessageId = new ttypes.MessageBoxV2MessageId();
          this.startMessageId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.startMessageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.messageBoxCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getUpdatedMessageBoxIds_args');
    if (this.startMessageId !== null && this.startMessageId !== undefined) {
      output.writeFieldBegin('startMessageId', Thrift.Type.STRUCT, 2);
      this.startMessageId.write(output);
      output.writeFieldEnd();
    }
    if (this.startMessageBoxId !== null && this.startMessageBoxId !== undefined) {
      output.writeFieldBegin('startMessageBoxId', Thrift.Type.STRING, 3);
      output.writeString(this.startMessageBoxId);
      output.writeFieldEnd();
    }
    if (this.messageBoxCount !== null && this.messageBoxCount !== undefined) {
      output.writeFieldBegin('messageBoxCount', Thrift.Type.I32, 4);
      output.writeI32(this.messageBoxCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getUpdatedMessageBoxIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31290 = input.readListBegin();
          const _size1289 = _rtmp31290.size || 0;
          for (let _i1291 = 0; _i1291 < _size1289; ++_i1291) {
            let elem1292 = null;
            elem1292 = input.readString();
            this.success.push(elem1292);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getUpdatedMessageBoxIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1293 in this.success) {
        if (this.success.hasOwnProperty(iter1293)) {
          iter1293 = this.success[iter1293];
          output.writeString(iter1293);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroups_args = class {
  constructor(args) {
    this.groupIds = null;
    if (args) {
      if (args.groupIds !== undefined && args.groupIds !== null) {
        this.groupIds = Thrift.copyList(args.groupIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.groupIds = [];
          const _rtmp31295 = input.readListBegin();
          const _size1294 = _rtmp31295.size || 0;
          for (let _i1296 = 0; _i1296 < _size1294; ++_i1296) {
            let elem1297 = null;
            elem1297 = input.readString();
            this.groupIds.push(elem1297);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroups_args');
    if (this.groupIds !== null && this.groupIds !== undefined) {
      output.writeFieldBegin('groupIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.groupIds.length);
      for (let iter1298 in this.groupIds) {
        if (this.groupIds.hasOwnProperty(iter1298)) {
          iter1298 = this.groupIds[iter1298];
          output.writeString(iter1298);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroups_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Group]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31300 = input.readListBegin();
          const _size1299 = _rtmp31300.size || 0;
          for (let _i1301 = 0; _i1301 < _size1299; ++_i1301) {
            let elem1302 = null;
            elem1302 = new ttypes.Group();
            elem1302.read(input);
            this.success.push(elem1302);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1303 in this.success) {
        if (this.success.hasOwnProperty(iter1303)) {
          iter1303 = this.success[iter1303];
          iter1303.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessageReceipt_args = class {
  constructor(args) {
    this.seq = null;
    this.consumer = null;
    this.messageIds = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.consumer !== undefined && args.consumer !== null) {
        this.consumer = args.consumer;
      }
      if (args.messageIds !== undefined && args.messageIds !== null) {
        this.messageIds = Thrift.copyList(args.messageIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.consumer = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.messageIds = [];
          const _rtmp31305 = input.readListBegin();
          const _size1304 = _rtmp31305.size || 0;
          for (let _i1306 = 0; _i1306 < _size1304; ++_i1306) {
            let elem1307 = null;
            elem1307 = input.readString();
            this.messageIds.push(elem1307);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessageReceipt_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.consumer !== null && this.consumer !== undefined) {
      output.writeFieldBegin('consumer', Thrift.Type.STRING, 2);
      output.writeString(this.consumer);
      output.writeFieldEnd();
    }
    if (this.messageIds !== null && this.messageIds !== undefined) {
      output.writeFieldBegin('messageIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.messageIds.length);
      for (let iter1308 in this.messageIds) {
        if (this.messageIds.hasOwnProperty(iter1308)) {
          iter1308 = this.messageIds[iter1308];
          output.writeString(iter1308);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendMessageReceipt_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendMessageReceipt_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactByMetaTag_args = class {
  constructor(args) {
    this.userid = null;
    this.reference = null;
    if (args) {
      if (args.userid !== undefined && args.userid !== null) {
        this.userid = args.userid;
      }
      if (args.reference !== undefined && args.reference !== null) {
        this.reference = args.reference;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.reference = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactByMetaTag_args');
    if (this.userid !== null && this.userid !== undefined) {
      output.writeFieldBegin('userid', Thrift.Type.STRING, 2);
      output.writeString(this.userid);
      output.writeFieldEnd();
    }
    if (this.reference !== null && this.reference !== undefined) {
      output.writeFieldBegin('reference', Thrift.Type.STRING, 3);
      output.writeString(this.reference);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactByMetaTag_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Contact(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Contact();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactByMetaTag_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_destroyMessage_args = class {
  constructor(args) {
    this.seq = null;
    this.chatId = null;
    this.messageId = null;
    this.sessionId = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.chatId !== undefined && args.chatId !== null) {
        this.chatId = args.chatId;
      }
      if (args.messageId !== undefined && args.messageId !== null) {
        this.messageId = args.messageId;
      }
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.messageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BYTE) {
          this.sessionId = input.readByte();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_destroyMessage_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.chatId !== null && this.chatId !== undefined) {
      output.writeFieldBegin('chatId', Thrift.Type.STRING, 2);
      output.writeString(this.chatId);
      output.writeFieldEnd();
    }
    if (this.messageId !== null && this.messageId !== undefined) {
      output.writeFieldBegin('messageId', Thrift.Type.STRING, 3);
      output.writeString(this.messageId);
      output.writeFieldEnd();
    }
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.BYTE, 4);
      output.writeByte(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_destroyMessage_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_destroyMessage_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_generateUserTicket_args = class {
  constructor(args) {
    this.expirationTime = null;
    this.maxUseCount = null;
    if (args) {
      if (args.expirationTime !== undefined && args.expirationTime !== null) {
        this.expirationTime = args.expirationTime;
      }
      if (args.maxUseCount !== undefined && args.maxUseCount !== null) {
        this.maxUseCount = args.maxUseCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.expirationTime = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.maxUseCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_generateUserTicket_args');
    if (this.expirationTime !== null && this.expirationTime !== undefined) {
      output.writeFieldBegin('expirationTime', Thrift.Type.I64, 3);
      output.writeI64(this.expirationTime);
      output.writeFieldEnd();
    }
    if (this.maxUseCount !== null && this.maxUseCount !== undefined) {
      output.writeFieldBegin('maxUseCount', Thrift.Type.I32, 4);
      output.writeI32(this.maxUseCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_generateUserTicket_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Ticket(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Ticket();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_generateUserTicket_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args = class {
  constructor(args) {
    this.region = null;
    this.udidHash = null;
    this.deviceInfo = null;
    this.provider = null;
    this.identifier = null;
    this.verifier = null;
    this.mid = null;
    this.migrationPincodeSessionId = null;
    if (args) {
      if (args.region !== undefined && args.region !== null) {
        this.region = args.region;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
      if (args.provider !== undefined && args.provider !== null) {
        this.provider = args.provider;
      }
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.provider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args');
    if (this.region !== null && this.region !== undefined) {
      output.writeFieldBegin('region', Thrift.Type.STRING, 2);
      output.writeString(this.region);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 3);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 4);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.provider !== null && this.provider !== undefined) {
      output.writeFieldBegin('provider', Thrift.Type.I32, 5);
      output.writeI32(this.provider);
      output.writeFieldEnd();
    }
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 6);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 7);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 8);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 9);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getFavoriteMids_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getFavoriteMids_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getFavoriteMids_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31310 = input.readListBegin();
          const _size1309 = _rtmp31310.size || 0;
          for (let _i1311 = 0; _i1311 < _size1309; ++_i1311) {
            let elem1312 = null;
            elem1312 = input.readString();
            this.success.push(elem1312);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getFavoriteMids_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1313 in this.success) {
        if (this.success.hasOwnProperty(iter1313)) {
          iter1313 = this.success[iter1313];
          output.writeString(iter1313);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAcceptedProximityMatches_args = class {
  constructor(args) {
    this.sessionId = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAcceptedProximityMatches_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAcceptedProximityMatches_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.SET) {
          this.success = [];
          const _rtmp31315 = input.readSetBegin();
          const _size1314 = _rtmp31315.size || 0;
          for (let _i1316 = 0; _i1316 < _size1314; ++_i1316) {
            let elem1317 = null;
            elem1317 = input.readString();
            this.success.push(elem1317);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAcceptedProximityMatches_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.SET, 0);
      output.writeSetBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1318 in this.success) {
        if (this.success.hasOwnProperty(iter1318)) {
          iter1318 = this.success[iter1318];
          output.writeString(iter1318);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyInstalled_args = class {
  constructor(args) {
    this.udidHash = null;
    this.applicationTypeWithExtensions = null;
    if (args) {
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.applicationTypeWithExtensions !== undefined && args.applicationTypeWithExtensions !== null) {
        this.applicationTypeWithExtensions = args.applicationTypeWithExtensions;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.applicationTypeWithExtensions = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyInstalled_args');
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 2);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.applicationTypeWithExtensions !== null && this.applicationTypeWithExtensions !== undefined) {
      output.writeFieldBegin('applicationTypeWithExtensions', Thrift.Type.STRING, 3);
      output.writeString(this.applicationTypeWithExtensions);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyInstalled_result = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyInstalled_result');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCountryWithRequestIp_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCountryWithRequestIp_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCountryWithRequestIp_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCountryWithRequestIp_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroupsV2_args = class {
  constructor(args) {
    this.groupIds = null;
    if (args) {
      if (args.groupIds !== undefined && args.groupIds !== null) {
        this.groupIds = Thrift.copyList(args.groupIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.groupIds = [];
          const _rtmp31320 = input.readListBegin();
          const _size1319 = _rtmp31320.size || 0;
          for (let _i1321 = 0; _i1321 < _size1319; ++_i1321) {
            let elem1322 = null;
            elem1322 = input.readString();
            this.groupIds.push(elem1322);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroupsV2_args');
    if (this.groupIds !== null && this.groupIds !== undefined) {
      output.writeFieldBegin('groupIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.groupIds.length);
      for (let iter1323 in this.groupIds) {
        if (this.groupIds.hasOwnProperty(iter1323)) {
          iter1323 = this.groupIds[iter1323];
          output.writeString(iter1323);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroupsV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Group]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31325 = input.readListBegin();
          const _size1324 = _rtmp31325.size || 0;
          for (let _i1326 = 0; _i1326 < _size1324; ++_i1326) {
            let elem1327 = null;
            elem1327 = new ttypes.Group();
            elem1327.read(input);
            this.success.push(elem1327);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroupsV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1328 in this.success) {
        if (this.success.hasOwnProperty(iter1328)) {
          iter1328 = this.success[iter1328];
          iter1328.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithIdentityCredential_args = class {
  constructor(args) {
    this.identifier = null;
    this.password = null;
    this.keepLoggedIn = null;
    this.accessLocation = null;
    this.systemName = null;
    this.identityProvider = null;
    this.certificate = null;
    if (args) {
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.keepLoggedIn !== undefined && args.keepLoggedIn !== null) {
        this.keepLoggedIn = args.keepLoggedIn;
      }
      if (args.accessLocation !== undefined && args.accessLocation !== null) {
        this.accessLocation = args.accessLocation;
      }
      if (args.systemName !== undefined && args.systemName !== null) {
        this.systemName = args.systemName;
      }
      if (args.identityProvider !== undefined && args.identityProvider !== null) {
        this.identityProvider = args.identityProvider;
      }
      if (args.certificate !== undefined && args.certificate !== null) {
        this.certificate = args.certificate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.keepLoggedIn = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.accessLocation = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.systemName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.identityProvider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.certificate = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithIdentityCredential_args');
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 3);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 4);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.keepLoggedIn !== null && this.keepLoggedIn !== undefined) {
      output.writeFieldBegin('keepLoggedIn', Thrift.Type.BOOL, 5);
      output.writeBool(this.keepLoggedIn);
      output.writeFieldEnd();
    }
    if (this.accessLocation !== null && this.accessLocation !== undefined) {
      output.writeFieldBegin('accessLocation', Thrift.Type.STRING, 6);
      output.writeString(this.accessLocation);
      output.writeFieldEnd();
    }
    if (this.systemName !== null && this.systemName !== undefined) {
      output.writeFieldBegin('systemName', Thrift.Type.STRING, 7);
      output.writeString(this.systemName);
      output.writeFieldEnd();
    }
    if (this.identityProvider !== null && this.identityProvider !== undefined) {
      output.writeFieldBegin('identityProvider', Thrift.Type.I32, 8);
      output.writeI32(this.identityProvider);
      output.writeFieldEnd();
    }
    if (this.certificate !== null && this.certificate !== undefined) {
      output.writeFieldBegin('certificate', Thrift.Type.STRING, 9);
      output.writeString(this.certificate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithIdentityCredential_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithIdentityCredential_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_startUpdateVerification_args = class {
  constructor(args) {
    this.region = null;
    this.carrier = null;
    this.phone = null;
    this.udidHash = null;
    this.deviceInfo = null;
    this.networkCode = null;
    this.locale = null;
    this.simInfo = null;
    if (args) {
      if (args.region !== undefined && args.region !== null) {
        this.region = args.region;
      }
      if (args.carrier !== undefined && args.carrier !== null) {
        this.carrier = args.carrier;
      }
      if (args.phone !== undefined && args.phone !== null) {
        this.phone = args.phone;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
      if (args.networkCode !== undefined && args.networkCode !== null) {
        this.networkCode = args.networkCode;
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
      if (args.simInfo !== undefined && args.simInfo !== null) {
        this.simInfo = new ttypes.SIMInfo(args.simInfo);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.carrier = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.phone = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.networkCode = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.simInfo = new ttypes.SIMInfo();
          this.simInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_startUpdateVerification_args');
    if (this.region !== null && this.region !== undefined) {
      output.writeFieldBegin('region', Thrift.Type.STRING, 2);
      output.writeString(this.region);
      output.writeFieldEnd();
    }
    if (this.carrier !== null && this.carrier !== undefined) {
      output.writeFieldBegin('carrier', Thrift.Type.I32, 3);
      output.writeI32(this.carrier);
      output.writeFieldEnd();
    }
    if (this.phone !== null && this.phone !== undefined) {
      output.writeFieldBegin('phone', Thrift.Type.STRING, 4);
      output.writeString(this.phone);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 5);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 6);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.networkCode !== null && this.networkCode !== undefined) {
      output.writeFieldBegin('networkCode', Thrift.Type.STRING, 7);
      output.writeString(this.networkCode);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 8);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    if (this.simInfo !== null && this.simInfo !== undefined) {
      output.writeFieldBegin('simInfo', Thrift.Type.STRUCT, 9);
      this.simInfo.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_startUpdateVerification_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.VerificationSessionData(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.VerificationSessionData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_startUpdateVerification_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSessions_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSessions_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSessions_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.LoginSession]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31330 = input.readListBegin();
          const _size1329 = _rtmp31330.size || 0;
          for (let _i1331 = 0; _i1331 < _size1329; ++_i1331) {
            let elem1332 = null;
            elem1332 = new ttypes.LoginSession();
            elem1332.read(input);
            this.success.push(elem1332);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSessions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1333 in this.success) {
        if (this.success.hasOwnProperty(iter1333)) {
          iter1333 = this.success[iter1333];
          iter1333.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateSettings_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.settings = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.settings !== undefined && args.settings !== null) {
        this.settings = new ttypes.Settings(args.settings);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.settings = new ttypes.Settings();
          this.settings.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateSettings_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.settings !== null && this.settings !== undefined) {
      output.writeFieldBegin('settings', Thrift.Type.STRUCT, 2);
      this.settings.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateSettings_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateSettings_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getContact_args = class {
  constructor(args) {
    this.id = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getContact_args');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getContact_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Contact(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Contact();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getContact_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBlockedContactIds_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBlockedContactIds_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getBlockedContactIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31335 = input.readListBegin();
          const _size1334 = _rtmp31335.size || 0;
          for (let _i1336 = 0; _i1336 < _size1334; ++_i1336) {
            let elem1337 = null;
            elem1337 = input.readString();
            this.success.push(elem1337);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getBlockedContactIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1338 in this.success) {
        if (this.success.hasOwnProperty(iter1338)) {
          iter1338 = this.success[iter1338];
          output.writeString(iter1338);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithVerifierForCertificate_args = class {
  constructor(args) {
    this.verifier = null;
    if (args) {
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithVerifierForCertificate_args');
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 3);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_loginWithVerifierForCertificate_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.LoginResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.LoginResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_loginWithVerifierForCertificate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getProfile_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getProfile_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getProfile_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Profile(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Profile();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getProfile_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactsByEmail_args = class {
  constructor(args) {
    this.emails = null;
    if (args) {
      if (args.emails !== undefined && args.emails !== null) {
        this.emails = Thrift.copyList(args.emails, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.SET) {
          this.emails = [];
          const _rtmp31340 = input.readSetBegin();
          const _size1339 = _rtmp31340.size || 0;
          for (let _i1341 = 0; _i1341 < _size1339; ++_i1341) {
            let elem1342 = null;
            elem1342 = input.readString();
            this.emails.push(elem1342);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactsByEmail_args');
    if (this.emails !== null && this.emails !== undefined) {
      output.writeFieldBegin('emails', Thrift.Type.SET, 2);
      output.writeSetBegin(Thrift.Type.STRING, this.emails.length);
      for (let iter1343 in this.emails) {
        if (this.emails.hasOwnProperty(iter1343)) {
          iter1343 = this.emails[iter1343];
          output.writeString(iter1343);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactsByEmail_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [ttypes.Contact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31345 = input.readMapBegin();
          const _size1344 = _rtmp31345.size || 0;
          for (let _i1346 = 0; _i1346 < _size1344; ++_i1346) {
            let key1347 = null;
            let val1348 = null;
            key1347 = input.readString();
            val1348 = new ttypes.Contact();
            val1348.read(input);
            this.success[key1347] = val1348;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactsByEmail_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter1349 in this.success) {
        if (this.success.hasOwnProperty(kiter1349)) {
          let viter1350 = this.success[kiter1349];
          output.writeString(kiter1349);
          viter1350.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSystemConfiguration_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSystemConfiguration_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getSystemConfiguration_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.SystemConfiguration(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.SystemConfiguration();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getSystemConfiguration_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRecentMessages_args = class {
  constructor(args) {
    this.messageBoxId = null;
    this.messagesCount = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.messagesCount !== undefined && args.messagesCount !== null) {
        this.messagesCount = args.messagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.messagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRecentMessages_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.messagesCount !== null && this.messagesCount !== undefined) {
      output.writeFieldBegin('messagesCount', Thrift.Type.I32, 3);
      output.writeI32(this.messagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getRecentMessages_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Message]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31352 = input.readListBegin();
          const _size1351 = _rtmp31352.size || 0;
          for (let _i1353 = 0; _i1353 < _size1351; ++_i1353) {
            let elem1354 = null;
            elem1354 = new ttypes.Message();
            elem1354.read(input);
            this.success.push(elem1354);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getRecentMessages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1355 in this.success) {
        if (this.success.hasOwnProperty(iter1355)) {
          iter1355 = this.success[iter1355];
          iter1355.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyPhone_args = class {
  constructor(args) {
    this.sessionId = null;
    this.pinCode = null;
    this.udidHash = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.pinCode !== undefined && args.pinCode !== null) {
        this.pinCode = args.pinCode;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pinCode = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyPhone_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.pinCode !== null && this.pinCode !== undefined) {
      output.writeFieldBegin('pinCode', Thrift.Type.STRING, 3);
      output.writeString(this.pinCode);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 4);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyPhone_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyPhone_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createGroup_args = class {
  constructor(args) {
    this.seq = null;
    this.name = null;
    this.contactIds = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.contactIds !== undefined && args.contactIds !== null) {
        this.contactIds = Thrift.copyList(args.contactIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.contactIds = [];
          const _rtmp31357 = input.readListBegin();
          const _size1356 = _rtmp31357.size || 0;
          for (let _i1358 = 0; _i1358 < _size1356; ++_i1358) {
            let elem1359 = null;
            elem1359 = input.readString();
            this.contactIds.push(elem1359);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createGroup_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 2);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.contactIds !== null && this.contactIds !== undefined) {
      output.writeFieldBegin('contactIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.contactIds.length);
      for (let iter1360 in this.contactIds) {
        if (this.contactIds.hasOwnProperty(iter1360)) {
          iter1360 = this.contactIds[iter1360];
          output.writeString(iter1360);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createGroup_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Group(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Group();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateBuddySetting_args = class {
  constructor(args) {
    this.key = null;
    this.value = null;
    if (args) {
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateBuddySetting_args');
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateBuddySetting_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateBuddySetting_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateRegion_args = class {
  constructor(args) {
    this.region = null;
    if (args) {
      if (args.region !== undefined && args.region !== null) {
        this.region = args.region;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateRegion_args');
    if (this.region !== null && this.region !== undefined) {
      output.writeFieldBegin('region', Thrift.Type.STRING, 2);
      output.writeString(this.region);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateRegion_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateRegion_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyIdentityCredential_args = class {
  constructor(args) {
    this.identifier = null;
    this.password = null;
    this.identityProvider = null;
    if (args) {
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.identityProvider !== undefined && args.identityProvider !== null) {
        this.identityProvider = args.identityProvider;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.identityProvider = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyIdentityCredential_args');
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 3);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 4);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.identityProvider !== null && this.identityProvider !== undefined) {
      output.writeFieldBegin('identityProvider', Thrift.Type.I32, 8);
      output.writeI32(this.identityProvider);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyIdentityCredential_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyIdentityCredential_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendChatRemoved_args = class {
  constructor(args) {
    this.seq = null;
    this.consumer = null;
    this.lastMessageId = null;
    this.sessionId = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.consumer !== undefined && args.consumer !== null) {
        this.consumer = args.consumer;
      }
      if (args.lastMessageId !== undefined && args.lastMessageId !== null) {
        this.lastMessageId = args.lastMessageId;
      }
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.consumer = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.lastMessageId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BYTE) {
          this.sessionId = input.readByte();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendChatRemoved_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.consumer !== null && this.consumer !== undefined) {
      output.writeFieldBegin('consumer', Thrift.Type.STRING, 2);
      output.writeString(this.consumer);
      output.writeFieldEnd();
    }
    if (this.lastMessageId !== null && this.lastMessageId !== undefined) {
      output.writeFieldBegin('lastMessageId', Thrift.Type.STRING, 3);
      output.writeString(this.lastMessageId);
      output.writeFieldEnd();
    }
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.BYTE, 4);
      output.writeByte(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendChatRemoved_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendChatRemoved_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroupIdsJoined_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroupIdsJoined_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getGroupIdsJoined_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31362 = input.readListBegin();
          const _size1361 = _rtmp31362.size || 0;
          for (let _i1363 = 0; _i1363 < _size1361; ++_i1363) {
            let elem1364 = null;
            elem1364 = input.readString();
            this.success.push(elem1364);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getGroupIdsJoined_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1365 in this.success) {
        if (this.success.hasOwnProperty(iter1365)) {
          iter1365 = this.success[iter1365];
          output.writeString(iter1365);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactByUserid_args = class {
  constructor(args) {
    this.userid = null;
    if (args) {
      if (args.userid !== undefined && args.userid !== null) {
        this.userid = args.userid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactByUserid_args');
    if (this.userid !== null && this.userid !== undefined) {
      output.writeFieldBegin('userid', Thrift.Type.STRING, 2);
      output.writeString(this.userid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findContactByUserid_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Contact(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Contact();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findContactByUserid_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getE2EEPublicKeys_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getE2EEPublicKeys_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getE2EEPublicKeys_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.E2EEPublicKey]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31367 = input.readListBegin();
          const _size1366 = _rtmp31367.size || 0;
          for (let _i1368 = 0; _i1368 < _size1366; ++_i1368) {
            let elem1369 = null;
            elem1369 = new ttypes.E2EEPublicKey();
            elem1369.read(input);
            this.success.push(elem1369);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getE2EEPublicKeys_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1370 in this.success) {
        if (this.success.hasOwnProperty(iter1370)) {
          iter1370 = this.success[iter1370];
          iter1370.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxWrapUpList_args = class {
  constructor(args) {
    this.start = null;
    this.messageBoxCount = null;
    if (args) {
      if (args.start !== undefined && args.start !== null) {
        this.start = args.start;
      }
      if (args.messageBoxCount !== undefined && args.messageBoxCount !== null) {
        this.messageBoxCount = args.messageBoxCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.start = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.messageBoxCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxWrapUpList_args');
    if (this.start !== null && this.start !== undefined) {
      output.writeFieldBegin('start', Thrift.Type.I32, 2);
      output.writeI32(this.start);
      output.writeFieldEnd();
    }
    if (this.messageBoxCount !== null && this.messageBoxCount !== undefined) {
      output.writeFieldBegin('messageBoxCount', Thrift.Type.I32, 3);
      output.writeI32(this.messageBoxCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxWrapUpList_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBoxWrapUpResponse(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBoxWrapUpResponse();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxWrapUpList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_leaveRoom_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.roomId = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.roomId !== undefined && args.roomId !== null) {
        this.roomId = args.roomId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.roomId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_leaveRoom_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.roomId !== null && this.roomId !== undefined) {
      output.writeFieldBegin('roomId', Thrift.Type.STRING, 2);
      output.writeString(this.roomId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_leaveRoom_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_leaveRoom_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_unblockRecommendation_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.id = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_unblockRecommendation_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_unblockRecommendation_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_unblockRecommendation_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactsByPhone_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.phones = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.phones !== undefined && args.phones !== null) {
        this.phones = Thrift.copyList(args.phones, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.SET) {
          this.phones = [];
          const _rtmp31372 = input.readSetBegin();
          const _size1371 = _rtmp31372.size || 0;
          for (let _i1373 = 0; _i1373 < _size1371; ++_i1373) {
            let elem1374 = null;
            elem1374 = input.readString();
            this.phones.push(elem1374);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactsByPhone_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.phones !== null && this.phones !== undefined) {
      output.writeFieldBegin('phones', Thrift.Type.SET, 2);
      output.writeSetBegin(Thrift.Type.STRING, this.phones.length);
      for (let iter1375 in this.phones) {
        if (this.phones.hasOwnProperty(iter1375)) {
          iter1375 = this.phones[iter1375];
          output.writeString(iter1375);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactsByPhone_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [ttypes.Contact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31377 = input.readMapBegin();
          const _size1376 = _rtmp31377.size || 0;
          for (let _i1378 = 0; _i1378 < _size1376; ++_i1378) {
            let key1379 = null;
            let val1380 = null;
            key1379 = input.readString();
            val1380 = new ttypes.Contact();
            val1380.read(input);
            this.success[key1379] = val1380;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactsByPhone_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter1381 in this.success) {
        if (this.success.hasOwnProperty(kiter1381)) {
          let viter1382 = this.success[kiter1381];
          output.writeString(kiter1381);
          viter1382.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAuthQrcode_args = class {
  constructor(args) {
    this.keepLoggedIn = null;
    this.systemName = null;
    this.returnCallbackUrl = null;
    if (args) {
      if (args.keepLoggedIn !== undefined && args.keepLoggedIn !== null) {
        this.keepLoggedIn = args.keepLoggedIn;
      }
      if (args.systemName !== undefined && args.systemName !== null) {
        this.systemName = args.systemName;
      }
      if (args.returnCallbackUrl !== undefined && args.returnCallbackUrl !== null) {
        this.returnCallbackUrl = args.returnCallbackUrl;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.keepLoggedIn = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.systemName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.returnCallbackUrl = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAuthQrcode_args');
    if (this.keepLoggedIn !== null && this.keepLoggedIn !== undefined) {
      output.writeFieldBegin('keepLoggedIn', Thrift.Type.BOOL, 2);
      output.writeBool(this.keepLoggedIn);
      output.writeFieldEnd();
    }
    if (this.systemName !== null && this.systemName !== undefined) {
      output.writeFieldBegin('systemName', Thrift.Type.STRING, 3);
      output.writeString(this.systemName);
      output.writeFieldEnd();
    }
    if (this.returnCallbackUrl !== null && this.returnCallbackUrl !== undefined) {
      output.writeFieldBegin('returnCallbackUrl', Thrift.Type.BOOL, 4);
      output.writeBool(this.returnCallbackUrl);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAuthQrcode_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.AuthQrcode(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.AuthQrcode();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAuthQrcode_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getE2EEGroupSharedKey_args = class {
  constructor(args) {
    this.version = null;
    this.chatMid = null;
    this.groupKeyId = null;
    if (args) {
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      }
      if (args.chatMid !== undefined && args.chatMid !== null) {
        this.chatMid = args.chatMid;
      }
      if (args.groupKeyId !== undefined && args.groupKeyId !== null) {
        this.groupKeyId = args.groupKeyId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.version = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.chatMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.groupKeyId = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getE2EEGroupSharedKey_args');
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.I32, 2);
      output.writeI32(this.version);
      output.writeFieldEnd();
    }
    if (this.chatMid !== null && this.chatMid !== undefined) {
      output.writeFieldBegin('chatMid', Thrift.Type.STRING, 3);
      output.writeString(this.chatMid);
      output.writeFieldEnd();
    }
    if (this.groupKeyId !== null && this.groupKeyId !== undefined) {
      output.writeFieldBegin('groupKeyId', Thrift.Type.I32, 4);
      output.writeI32(this.groupKeyId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getE2EEGroupSharedKey_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.E2EEGroupSharedKey(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.E2EEGroupSharedKey();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getE2EEGroupSharedKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxWrapUp_args = class {
  constructor(args) {
    this.mid = null;
    if (args) {
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxWrapUp_args');
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxWrapUp_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBoxWrapUp(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBoxWrapUp();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxWrapUp_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateSettingsAttributes_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.attrBitset = null;
    this.settings = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.attrBitset !== undefined && args.attrBitset !== null) {
        this.attrBitset = args.attrBitset;
      }
      if (args.settings !== undefined && args.settings !== null) {
        this.settings = new ttypes.Settings(args.settings);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.attrBitset = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.settings = new ttypes.Settings();
          this.settings.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateSettingsAttributes_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.attrBitset !== null && this.attrBitset !== undefined) {
      output.writeFieldBegin('attrBitset', Thrift.Type.I32, 2);
      output.writeI32(this.attrBitset);
      output.writeFieldEnd();
    }
    if (this.settings !== null && this.settings !== undefined) {
      output.writeFieldBegin('settings', Thrift.Type.STRUCT, 3);
      this.settings.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateSettingsAttributes_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateSettingsAttributes_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_startVerification_args = class {
  constructor(args) {
    this.region = null;
    this.carrier = null;
    this.phone = null;
    this.udidHash = null;
    this.deviceInfo = null;
    this.networkCode = null;
    this.mid = null;
    this.locale = null;
    this.simInfo = null;
    this.oldUdidHash = null;
    if (args) {
      if (args.region !== undefined && args.region !== null) {
        this.region = args.region;
      }
      if (args.carrier !== undefined && args.carrier !== null) {
        this.carrier = args.carrier;
      }
      if (args.phone !== undefined && args.phone !== null) {
        this.phone = args.phone;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
      if (args.networkCode !== undefined && args.networkCode !== null) {
        this.networkCode = args.networkCode;
      }
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.locale !== undefined && args.locale !== null) {
        this.locale = args.locale;
      }
      if (args.simInfo !== undefined && args.simInfo !== null) {
        this.simInfo = new ttypes.SIMInfo(args.simInfo);
      }
      if (args.oldUdidHash !== undefined && args.oldUdidHash !== null) {
        this.oldUdidHash = args.oldUdidHash;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.carrier = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.phone = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.networkCode = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.locale = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRUCT) {
          this.simInfo = new ttypes.SIMInfo();
          this.simInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.oldUdidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_startVerification_args');
    if (this.region !== null && this.region !== undefined) {
      output.writeFieldBegin('region', Thrift.Type.STRING, 2);
      output.writeString(this.region);
      output.writeFieldEnd();
    }
    if (this.carrier !== null && this.carrier !== undefined) {
      output.writeFieldBegin('carrier', Thrift.Type.I32, 3);
      output.writeI32(this.carrier);
      output.writeFieldEnd();
    }
    if (this.phone !== null && this.phone !== undefined) {
      output.writeFieldBegin('phone', Thrift.Type.STRING, 4);
      output.writeString(this.phone);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 5);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 6);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.networkCode !== null && this.networkCode !== undefined) {
      output.writeFieldBegin('networkCode', Thrift.Type.STRING, 7);
      output.writeString(this.networkCode);
      output.writeFieldEnd();
    }
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 8);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.locale !== null && this.locale !== undefined) {
      output.writeFieldBegin('locale', Thrift.Type.STRING, 9);
      output.writeString(this.locale);
      output.writeFieldEnd();
    }
    if (this.simInfo !== null && this.simInfo !== undefined) {
      output.writeFieldBegin('simInfo', Thrift.Type.STRUCT, 10);
      this.simInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.oldUdidHash !== null && this.oldUdidHash !== undefined) {
      output.writeFieldBegin('oldUdidHash', Thrift.Type.STRING, 11);
      output.writeString(this.oldUdidHash);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_startVerification_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.VerificationSessionData(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.VerificationSessionData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_startVerification_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportRooms_args = class {
  constructor(args) {
    this.syncOpRevision = null;
    this.rooms = null;
    if (args) {
      if (args.syncOpRevision !== undefined && args.syncOpRevision !== null) {
        this.syncOpRevision = args.syncOpRevision;
      }
      if (args.rooms !== undefined && args.rooms !== null) {
        this.rooms = Thrift.copyList(args.rooms, [ttypes.Room]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.syncOpRevision = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.rooms = [];
          const _rtmp31384 = input.readListBegin();
          const _size1383 = _rtmp31384.size || 0;
          for (let _i1385 = 0; _i1385 < _size1383; ++_i1385) {
            let elem1386 = null;
            elem1386 = new ttypes.Room();
            elem1386.read(input);
            this.rooms.push(elem1386);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportRooms_args');
    if (this.syncOpRevision !== null && this.syncOpRevision !== undefined) {
      output.writeFieldBegin('syncOpRevision', Thrift.Type.I64, 2);
      output.writeI64(this.syncOpRevision);
      output.writeFieldEnd();
    }
    if (this.rooms !== null && this.rooms !== undefined) {
      output.writeFieldBegin('rooms', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.rooms.length);
      for (let iter1387 in this.rooms) {
        if (this.rooms.hasOwnProperty(iter1387)) {
          iter1387 = this.rooms[iter1387];
          iter1387.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_reportRooms_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_reportRooms_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateGroupPreferenceAttribute_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.groupMid = null;
    this.updatedAttrs = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.groupMid !== undefined && args.groupMid !== null) {
        this.groupMid = args.groupMid;
      }
      if (args.updatedAttrs !== undefined && args.updatedAttrs !== null) {
        this.updatedAttrs = Thrift.copyMap(args.updatedAttrs, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.updatedAttrs = {};
          const _rtmp31389 = input.readMapBegin();
          const _size1388 = _rtmp31389.size || 0;
          for (let _i1390 = 0; _i1390 < _size1388; ++_i1390) {
            let key1391 = null;
            let val1392 = null;
            key1391 = input.readI32();
            val1392 = input.readString();
            this.updatedAttrs[key1391] = val1392;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateGroupPreferenceAttribute_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.groupMid !== null && this.groupMid !== undefined) {
      output.writeFieldBegin('groupMid', Thrift.Type.STRING, 2);
      output.writeString(this.groupMid);
      output.writeFieldEnd();
    }
    if (this.updatedAttrs !== null && this.updatedAttrs !== undefined) {
      output.writeFieldBegin('updatedAttrs', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRING, Thrift.objectLength(this.updatedAttrs));
      for (let kiter1393 in this.updatedAttrs) {
        if (this.updatedAttrs.hasOwnProperty(kiter1393)) {
          let viter1394 = this.updatedAttrs[kiter1393];
          output.writeI32(kiter1393);
          output.writeString(viter1394);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateGroupPreferenceAttribute_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateGroupPreferenceAttribute_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxWrapUpV2_args = class {
  constructor(args) {
    this.messageBoxId = null;
    if (args) {
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxWrapUpV2_args');
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 2);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBoxWrapUpV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBoxWrapUp(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBoxWrapUp();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBoxWrapUpV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactRooms_args = class {
  constructor(args) {
    this.roomIds = null;
    if (args) {
      if (args.roomIds !== undefined && args.roomIds !== null) {
        this.roomIds = Thrift.copyList(args.roomIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.roomIds = [];
          const _rtmp31396 = input.readListBegin();
          const _size1395 = _rtmp31396.size || 0;
          for (let _i1397 = 0; _i1397 < _size1395; ++_i1397) {
            let elem1398 = null;
            elem1398 = input.readString();
            this.roomIds.push(elem1398);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactRooms_args');
    if (this.roomIds !== null && this.roomIds !== undefined) {
      output.writeFieldBegin('roomIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.roomIds.length);
      for (let iter1399 in this.roomIds) {
        if (this.roomIds.hasOwnProperty(iter1399)) {
          iter1399 = this.roomIds[iter1399];
          output.writeString(iter1399);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getCompactRooms_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.Room]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31401 = input.readListBegin();
          const _size1400 = _rtmp31401.size || 0;
          for (let _i1402 = 0; _i1402 < _size1400; ++_i1402) {
            let elem1403 = null;
            elem1403 = new ttypes.Room();
            elem1403.read(input);
            this.success.push(elem1403);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getCompactRooms_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1404 in this.success) {
        if (this.success.hasOwnProperty(iter1404)) {
          iter1404 = this.success[iter1404];
          iter1404.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactByMetaTag_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.userid = null;
    this.reference = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.userid !== undefined && args.userid !== null) {
        this.userid = args.userid;
      }
      if (args.reference !== undefined && args.reference !== null) {
        this.reference = args.reference;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.reference = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactByMetaTag_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.userid !== null && this.userid !== undefined) {
      output.writeFieldBegin('userid', Thrift.Type.STRING, 2);
      output.writeString(this.userid);
      output.writeFieldEnd();
    }
    if (this.reference !== null && this.reference !== undefined) {
      output.writeFieldBegin('reference', Thrift.Type.STRING, 3);
      output.writeString(this.reference);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactByMetaTag_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Contact(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Contact();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactByMetaTag_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_storeUpdateProfileAttribute_args = class {
  constructor(args) {
    this.seq = null;
    this.profileAttribute = null;
    this.value = null;
    if (args) {
      if (args.seq !== undefined && args.seq !== null) {
        this.seq = args.seq;
      }
      if (args.profileAttribute !== undefined && args.profileAttribute !== null) {
        this.profileAttribute = args.profileAttribute;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.seq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.profileAttribute = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_storeUpdateProfileAttribute_args');
    if (this.seq !== null && this.seq !== undefined) {
      output.writeFieldBegin('seq', Thrift.Type.I32, 1);
      output.writeI32(this.seq);
      output.writeFieldEnd();
    }
    if (this.profileAttribute !== null && this.profileAttribute !== undefined) {
      output.writeFieldBegin('profileAttribute', Thrift.Type.I32, 2);
      output.writeI32(this.profileAttribute);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_storeUpdateProfileAttribute_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_storeUpdateProfileAttribute_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_resendEmailConfirmation_args = class {
  constructor(args) {
    this.verifier = null;
    if (args) {
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_resendEmailConfirmation_args');
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 2);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_resendEmailConfirmation_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.EmailConfirmationSession(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.EmailConfirmationSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_resendEmailConfirmation_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_confirmEmail_args = class {
  constructor(args) {
    this.verifier = null;
    this.pinCode = null;
    if (args) {
      if (args.verifier !== undefined && args.verifier !== null) {
        this.verifier = args.verifier;
      }
      if (args.pinCode !== undefined && args.pinCode !== null) {
        this.pinCode = args.pinCode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.verifier = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pinCode = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_confirmEmail_args');
    if (this.verifier !== null && this.verifier !== undefined) {
      output.writeFieldBegin('verifier', Thrift.Type.STRING, 2);
      output.writeString(this.verifier);
      output.writeFieldEnd();
    }
    if (this.pinCode !== null && this.pinCode !== undefined) {
      output.writeFieldBegin('pinCode', Thrift.Type.STRING, 3);
      output.writeString(this.pinCode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_confirmEmail_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.EmailConfirmationResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.EmailConfirmationResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_confirmEmail_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getExtendedProfile_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getExtendedProfile_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getExtendedProfile_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.ExtendedProfile(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.ExtendedProfile();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getExtendedProfile_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_isUseridAvailable_args = class {
  constructor(args) {
    this.userid = null;
    if (args) {
      if (args.userid !== undefined && args.userid !== null) {
        this.userid = args.userid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_isUseridAvailable_args');
    if (this.userid !== null && this.userid !== undefined) {
      output.writeFieldBegin('userid', Thrift.Type.STRING, 2);
      output.writeString(this.userid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_isUseridAvailable_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_isUseridAvailable_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyRegistrationComplete_args = class {
  constructor(args) {
    this.udidHash = null;
    this.applicationTypeWithExtensions = null;
    if (args) {
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.applicationTypeWithExtensions !== undefined && args.applicationTypeWithExtensions !== null) {
        this.applicationTypeWithExtensions = args.applicationTypeWithExtensions;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.applicationTypeWithExtensions = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyRegistrationComplete_args');
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 2);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.applicationTypeWithExtensions !== null && this.applicationTypeWithExtensions !== undefined) {
      output.writeFieldBegin('applicationTypeWithExtensions', Thrift.Type.STRING, 3);
      output.writeString(this.applicationTypeWithExtensions);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_notifyRegistrationComplete_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_notifyRegistrationComplete_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateDeviceInfo_args = class {
  constructor(args) {
    this.deviceUid = null;
    this.deviceInfo = null;
    if (args) {
      if (args.deviceUid !== undefined && args.deviceUid !== null) {
        this.deviceUid = args.deviceUid;
      }
      if (args.deviceInfo !== undefined && args.deviceInfo !== null) {
        this.deviceInfo = new ttypes.DeviceInfo(args.deviceInfo);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.deviceUid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.deviceInfo = new ttypes.DeviceInfo();
          this.deviceInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateDeviceInfo_args');
    if (this.deviceUid !== null && this.deviceUid !== undefined) {
      output.writeFieldBegin('deviceUid', Thrift.Type.STRING, 2);
      output.writeString(this.deviceUid);
      output.writeFieldEnd();
    }
    if (this.deviceInfo !== null && this.deviceInfo !== undefined) {
      output.writeFieldBegin('deviceInfo', Thrift.Type.STRUCT, 3);
      this.deviceInfo.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateDeviceInfo_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateDeviceInfo_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_blockRecommendation_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.id = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_blockRecommendation_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_blockRecommendation_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_blockRecommendation_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_rejectGroupInvitation_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.groupId = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_rejectGroupInvitation_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_rejectGroupInvitation_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_rejectGroupInvitation_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateCustomModeSettings_args = class {
  constructor(args) {
    this.customMode = null;
    this.paramMap = null;
    if (args) {
      if (args.customMode !== undefined && args.customMode !== null) {
        this.customMode = args.customMode;
      }
      if (args.paramMap !== undefined && args.paramMap !== null) {
        this.paramMap = Thrift.copyMap(args.paramMap, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.customMode = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.paramMap = {};
          const _rtmp31406 = input.readMapBegin();
          const _size1405 = _rtmp31406.size || 0;
          for (let _i1407 = 0; _i1407 < _size1405; ++_i1407) {
            let key1408 = null;
            let val1409 = null;
            key1408 = input.readString();
            val1409 = input.readString();
            this.paramMap[key1408] = val1409;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateCustomModeSettings_args');
    if (this.customMode !== null && this.customMode !== undefined) {
      output.writeFieldBegin('customMode', Thrift.Type.I32, 2);
      output.writeI32(this.customMode);
      output.writeFieldEnd();
    }
    if (this.paramMap !== null && this.paramMap !== undefined) {
      output.writeFieldBegin('paramMap', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.paramMap));
      for (let kiter1410 in this.paramMap) {
        if (this.paramMap.hasOwnProperty(kiter1410)) {
          let viter1411 = this.paramMap[kiter1410];
          output.writeString(kiter1410);
          output.writeString(viter1411);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_updateCustomModeSettings_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_updateCustomModeSettings_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createRoomV2_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.contactIds = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.contactIds !== undefined && args.contactIds !== null) {
        this.contactIds = Thrift.copyList(args.contactIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.contactIds = [];
          const _rtmp31413 = input.readListBegin();
          const _size1412 = _rtmp31413.size || 0;
          for (let _i1414 = 0; _i1414 < _size1412; ++_i1414) {
            let elem1415 = null;
            elem1415 = input.readString();
            this.contactIds.push(elem1415);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createRoomV2_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.contactIds !== null && this.contactIds !== undefined) {
      output.writeFieldBegin('contactIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.contactIds.length);
      for (let iter1416 in this.contactIds) {
        if (this.contactIds.hasOwnProperty(iter1416)) {
          iter1416 = this.contactIds[iter1416];
          output.writeString(iter1416);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_createRoomV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Room(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Room();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_createRoomV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_noop_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_noop_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_noop_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_noop_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acquireEncryptedAccessToken_args = class {
  constructor(args) {
    this.featureType = null;
    if (args) {
      if (args.featureType !== undefined && args.featureType !== null) {
        this.featureType = args.featureType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.featureType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acquireEncryptedAccessToken_args');
    if (this.featureType !== null && this.featureType !== undefined) {
      output.writeFieldBegin('featureType', Thrift.Type.I32, 2);
      output.writeI32(this.featureType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_acquireEncryptedAccessToken_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_acquireEncryptedAccessToken_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getE2EEPublicKeysEx_args = class {
  constructor(args) {
    this.ignoreE2EEStatus = null;
    if (args) {
      if (args.ignoreE2EEStatus !== undefined && args.ignoreE2EEStatus !== null) {
        this.ignoreE2EEStatus = args.ignoreE2EEStatus;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.ignoreE2EEStatus = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getE2EEPublicKeysEx_args');
    if (this.ignoreE2EEStatus !== null && this.ignoreE2EEStatus !== undefined) {
      output.writeFieldBegin('ignoreE2EEStatus', Thrift.Type.BOOL, 2);
      output.writeBool(this.ignoreE2EEStatus);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getE2EEPublicKeysEx_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.E2EEPublicKey]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31418 = input.readListBegin();
          const _size1417 = _rtmp31418.size || 0;
          for (let _i1419 = 0; _i1419 < _size1417; ++_i1419) {
            let elem1420 = null;
            elem1420 = new ttypes.E2EEPublicKey();
            elem1420.read(input);
            this.success.push(elem1420);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getE2EEPublicKeysEx_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter1421 in this.success) {
        if (this.success.hasOwnProperty(iter1421)) {
          iter1421 = this.success[iter1421];
          iter1421.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_syncContacts_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.localContacts = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.localContacts !== undefined && args.localContacts !== null) {
        this.localContacts = Thrift.copyList(args.localContacts, [ttypes.ContactModification]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.localContacts = [];
          const _rtmp31423 = input.readListBegin();
          const _size1422 = _rtmp31423.size || 0;
          for (let _i1424 = 0; _i1424 < _size1422; ++_i1424) {
            let elem1425 = null;
            elem1425 = new ttypes.ContactModification();
            elem1425.read(input);
            this.localContacts.push(elem1425);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_syncContacts_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.localContacts !== null && this.localContacts !== undefined) {
      output.writeFieldBegin('localContacts', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.localContacts.length);
      for (let iter1426 in this.localContacts) {
        if (this.localContacts.hasOwnProperty(iter1426)) {
          iter1426 = this.localContacts[iter1426];
          iter1426.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_syncContacts_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [ttypes.ContactRegistration]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31428 = input.readMapBegin();
          const _size1427 = _rtmp31428.size || 0;
          for (let _i1429 = 0; _i1429 < _size1427; ++_i1429) {
            let key1430 = null;
            let val1431 = null;
            key1430 = input.readString();
            val1431 = new ttypes.ContactRegistration();
            val1431.read(input);
            this.success[key1430] = val1431;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_syncContacts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter1432 in this.success) {
        if (this.success.hasOwnProperty(kiter1432)) {
          let viter1433 = this.success[kiter1432];
          output.writeString(kiter1432);
          viter1433.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactsByMid_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.mid = null;
    this.type = null;
    this.reference = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.mid !== undefined && args.mid !== null) {
        this.mid = args.mid;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.reference !== undefined && args.reference !== null) {
        this.reference = args.reference;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.reference = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactsByMid_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.mid !== null && this.mid !== undefined) {
      output.writeFieldBegin('mid', Thrift.Type.STRING, 2);
      output.writeString(this.mid);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.reference !== null && this.reference !== undefined) {
      output.writeFieldBegin('reference', Thrift.Type.STRING, 4);
      output.writeString(this.reference);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findAndAddContactsByMid_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [ttypes.Contact]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp31435 = input.readMapBegin();
          const _size1434 = _rtmp31435.size || 0;
          for (let _i1436 = 0; _i1436 < _size1434; ++_i1436) {
            let key1437 = null;
            let val1438 = null;
            key1437 = input.readString();
            val1438 = new ttypes.Contact();
            val1438.read(input);
            this.success[key1437] = val1438;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findAndAddContactsByMid_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter1439 in this.success) {
        if (this.success.hasOwnProperty(kiter1439)) {
          let viter1440 = this.success[kiter1439];
          output.writeString(kiter1439);
          viter1440.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findGroupByTicketV2_args = class {
  constructor(args) {
    this.ticketId = null;
    if (args) {
      if (args.ticketId !== undefined && args.ticketId !== null) {
        this.ticketId = args.ticketId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.ticketId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findGroupByTicketV2_args');
    if (this.ticketId !== null && this.ticketId !== undefined) {
      output.writeFieldBegin('ticketId', Thrift.Type.STRING, 1);
      output.writeString(this.ticketId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_findGroupByTicketV2_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.Group(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.Group();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_findGroupByTicketV2_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeFriendRequest_args = class {
  constructor(args) {
    this.direction = null;
    this.midOrEMid = null;
    if (args) {
      if (args.direction !== undefined && args.direction !== null) {
        this.direction = args.direction;
      }
      if (args.midOrEMid !== undefined && args.midOrEMid !== null) {
        this.midOrEMid = args.midOrEMid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.direction = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.midOrEMid = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeFriendRequest_args');
    if (this.direction !== null && this.direction !== undefined) {
      output.writeFieldBegin('direction', Thrift.Type.I32, 1);
      output.writeI32(this.direction);
      output.writeFieldEnd();
    }
    if (this.midOrEMid !== null && this.midOrEMid !== undefined) {
      output.writeFieldBegin('midOrEMid', Thrift.Type.STRING, 2);
      output.writeString(this.midOrEMid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_removeFriendRequest_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_removeFriendRequest_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyPhoneNumber_args = class {
  constructor(args) {
    this.sessionId = null;
    this.pinCode = null;
    this.udidHash = null;
    this.migrationPincodeSessionId = null;
    this.oldUdidHash = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.pinCode !== undefined && args.pinCode !== null) {
        this.pinCode = args.pinCode;
      }
      if (args.udidHash !== undefined && args.udidHash !== null) {
        this.udidHash = args.udidHash;
      }
      if (args.migrationPincodeSessionId !== undefined && args.migrationPincodeSessionId !== null) {
        this.migrationPincodeSessionId = args.migrationPincodeSessionId;
      }
      if (args.oldUdidHash !== undefined && args.oldUdidHash !== null) {
        this.oldUdidHash = args.oldUdidHash;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pinCode = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.udidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.migrationPincodeSessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.oldUdidHash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyPhoneNumber_args');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.pinCode !== null && this.pinCode !== undefined) {
      output.writeFieldBegin('pinCode', Thrift.Type.STRING, 3);
      output.writeString(this.pinCode);
      output.writeFieldEnd();
    }
    if (this.udidHash !== null && this.udidHash !== undefined) {
      output.writeFieldBegin('udidHash', Thrift.Type.STRING, 4);
      output.writeString(this.udidHash);
      output.writeFieldEnd();
    }
    if (this.migrationPincodeSessionId !== null && this.migrationPincodeSessionId !== undefined) {
      output.writeFieldBegin('migrationPincodeSessionId', Thrift.Type.STRING, 5);
      output.writeString(this.migrationPincodeSessionId);
      output.writeFieldEnd();
    }
    if (this.oldUdidHash !== null && this.oldUdidHash !== undefined) {
      output.writeFieldBegin('oldUdidHash', Thrift.Type.STRING, 6);
      output.writeString(this.oldUdidHash);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_verifyPhoneNumber_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.PhoneVerificationResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.PhoneVerificationResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_verifyPhoneNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_setNotificationsEnabled_args = class {
  constructor(args) {
    this.reqSeq = null;
    this.type = null;
    this.target = null;
    this.enablement = null;
    if (args) {
      if (args.reqSeq !== undefined && args.reqSeq !== null) {
        this.reqSeq = args.reqSeq;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.target !== undefined && args.target !== null) {
        this.target = args.target;
      }
      if (args.enablement !== undefined && args.enablement !== null) {
        this.enablement = args.enablement;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.reqSeq = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.target = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.enablement = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_setNotificationsEnabled_args');
    if (this.reqSeq !== null && this.reqSeq !== undefined) {
      output.writeFieldBegin('reqSeq', Thrift.Type.I32, 1);
      output.writeI32(this.reqSeq);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 2);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.target !== null && this.target !== undefined) {
      output.writeFieldBegin('target', Thrift.Type.STRING, 3);
      output.writeString(this.target);
      output.writeFieldEnd();
    }
    if (this.enablement !== null && this.enablement !== undefined) {
      output.writeFieldBegin('enablement', Thrift.Type.BOOL, 4);
      output.writeBool(this.enablement);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_setNotificationsEnabled_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_setNotificationsEnabled_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAllContactIds_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAllContactIds_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getAllContactIds_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31442 = input.readListBegin();
          const _size1441 = _rtmp31442.size || 0;
          for (let _i1443 = 0; _i1443 < _size1441; ++_i1443) {
            let elem1444 = null;
            elem1444 = input.readString();
            this.success.push(elem1444);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getAllContactIds_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter1445 in this.success) {
        if (this.success.hasOwnProperty(iter1445)) {
          iter1445 = this.success[iter1445];
          output.writeString(iter1445);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getIdentityIdentifier_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getIdentityIdentifier_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getIdentityIdentifier_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getIdentityIdentifier_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendDummyPush_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendDummyPush_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_sendDummyPush_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_sendDummyPush_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_inviteFriendsBySms_args = class {
  constructor(args) {
    this.phoneNumberList = null;
    if (args) {
      if (args.phoneNumberList !== undefined && args.phoneNumberList !== null) {
        this.phoneNumberList = Thrift.copyList(args.phoneNumberList, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.phoneNumberList = [];
          const _rtmp31447 = input.readListBegin();
          const _size1446 = _rtmp31447.size || 0;
          for (let _i1448 = 0; _i1448 < _size1446; ++_i1448) {
            let elem1449 = null;
            elem1449 = input.readString();
            this.phoneNumberList.push(elem1449);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_inviteFriendsBySms_args');
    if (this.phoneNumberList !== null && this.phoneNumberList !== undefined) {
      output.writeFieldBegin('phoneNumberList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.phoneNumberList.length);
      for (let iter1450 in this.phoneNumberList) {
        if (this.phoneNumberList.hasOwnProperty(iter1450)) {
          iter1450 = this.phoneNumberList[iter1450];
          output.writeString(iter1450);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_inviteFriendsBySms_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_inviteFriendsBySms_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBox_args = class {
  constructor(args) {
    this.channelId = null;
    this.messageBoxId = null;
    this.lastMessagesCount = null;
    if (args) {
      if (args.channelId !== undefined && args.channelId !== null) {
        this.channelId = args.channelId;
      }
      if (args.messageBoxId !== undefined && args.messageBoxId !== null) {
        this.messageBoxId = args.messageBoxId;
      }
      if (args.lastMessagesCount !== undefined && args.lastMessagesCount !== null) {
        this.lastMessagesCount = args.lastMessagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.channelId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.messageBoxId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.lastMessagesCount = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBox_args');
    if (this.channelId !== null && this.channelId !== undefined) {
      output.writeFieldBegin('channelId', Thrift.Type.STRING, 2);
      output.writeString(this.channelId);
      output.writeFieldEnd();
    }
    if (this.messageBoxId !== null && this.messageBoxId !== undefined) {
      output.writeFieldBegin('messageBoxId', Thrift.Type.STRING, 3);
      output.writeString(this.messageBoxId);
      output.writeFieldEnd();
    }
    if (this.lastMessagesCount !== null && this.lastMessagesCount !== undefined) {
      output.writeFieldBegin('lastMessagesCount', Thrift.Type.I32, 4);
      output.writeI32(this.lastMessagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkService_getMessageBox_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TalkException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TMessageBox(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TMessageBox();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TalkException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TalkService_getMessageBox_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TalkServiceClient = exports.Client = class {
  constructor(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this._seqid = 0;
    this._reqs = {};
  }
  seqid () { return this._seqid; }
  new_seqid () { return this._seqid += 1; }

  reportDeviceState (booleanState, stringState) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportDeviceState(booleanState, stringState);
    });
  }

  send_reportDeviceState (booleanState, stringState) {
    const output = new this.pClass(this.output);
    const params = {
      booleanState: booleanState,
      stringState: stringState
    };
    const args = new TalkService_reportDeviceState_args(params);
    try {
      output.writeMessageBegin('reportDeviceState', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportDeviceState (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportDeviceState_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  notifySleepV2 (lastStatusMap) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifySleepV2(lastStatusMap);
    });
  }

  send_notifySleepV2 (lastStatusMap) {
    const output = new this.pClass(this.output);
    const params = {
      lastStatusMap: lastStatusMap
    };
    const args = new TalkService_notifySleepV2_args(params);
    try {
      output.writeMessageBegin('notifySleepV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifySleepV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifySleepV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  updateNotificationToken (token, type) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateNotificationToken(token, type);
    });
  }

  send_updateNotificationToken (token, type) {
    const output = new this.pClass(this.output);
    const params = {
      token: token,
      type: type
    };
    const args = new TalkService_updateNotificationToken_args(params);
    try {
      output.writeMessageBegin('updateNotificationToken', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateNotificationToken (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateNotificationToken_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  updateGroup (reqSeq, group) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateGroup(reqSeq, group);
    });
  }

  send_updateGroup (reqSeq, group) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      group: group
    };
    const args = new TalkService_updateGroup_args(params);
    try {
      output.writeMessageBegin('updateGroup', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateGroup (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateGroup_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  verifyAccountMigrationPincode (migrationPincodeSessionId, accountMigrationPincode) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_verifyAccountMigrationPincode(migrationPincodeSessionId, accountMigrationPincode);
    });
  }

  send_verifyAccountMigrationPincode (migrationPincodeSessionId, accountMigrationPincode) {
    const output = new this.pClass(this.output);
    const params = {
      migrationPincodeSessionId: migrationPincodeSessionId,
      accountMigrationPincode: accountMigrationPincode
    };
    const args = new TalkService_verifyAccountMigrationPincode_args(params);
    try {
      output.writeMessageBegin('verifyAccountMigrationPincode', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_verifyAccountMigrationPincode (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_verifyAccountMigrationPincode_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  registerWithExistingSnsIdAndIdentityCredential (identityCredential, region, udidHash, deviceInfo, migrationPincodeSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo, migrationPincodeSessionId);
    });
  }

  send_registerWithExistingSnsIdAndIdentityCredential (identityCredential, region, udidHash, deviceInfo, migrationPincodeSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      identityCredential: identityCredential,
      region: region,
      udidHash: udidHash,
      deviceInfo: deviceInfo,
      migrationPincodeSessionId: migrationPincodeSessionId
    };
    const args = new TalkService_registerWithExistingSnsIdAndIdentityCredential_args(params);
    try {
      output.writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerWithExistingSnsIdAndIdentityCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerWithExistingSnsIdAndIdentityCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerWithExistingSnsIdAndIdentityCredential failed: unknown result');
  }

  registerDeviceWithoutPhoneNumber (region, udidHash, deviceInfo) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo);
    });
  }

  send_registerDeviceWithoutPhoneNumber (region, udidHash, deviceInfo) {
    const output = new this.pClass(this.output);
    const params = {
      region: region,
      udidHash: udidHash,
      deviceInfo: deviceInfo
    };
    const args = new TalkService_registerDeviceWithoutPhoneNumber_args(params);
    try {
      output.writeMessageBegin('registerDeviceWithoutPhoneNumber', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerDeviceWithoutPhoneNumber (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerDeviceWithoutPhoneNumber_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerDeviceWithoutPhoneNumber failed: unknown result');
  }

  changeVerificationMethod (sessionId, method) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_changeVerificationMethod(sessionId, method);
    });
  }

  send_changeVerificationMethod (sessionId, method) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId,
      method: method
    };
    const args = new TalkService_changeVerificationMethod_args(params);
    try {
      output.writeMessageBegin('changeVerificationMethod', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_changeVerificationMethod (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_changeVerificationMethod_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('changeVerificationMethod failed: unknown result');
  }

  setBuddyLocation (mid, index, location) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_setBuddyLocation(mid, index, location);
    });
  }

  send_setBuddyLocation (mid, index, location) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid,
      index: index,
      location: location
    };
    const args = new TalkService_setBuddyLocation_args(params);
    try {
      output.writeMessageBegin('setBuddyLocation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_setBuddyLocation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_setBuddyLocation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getFriendRequests (direction, lastSeenSeqId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getFriendRequests(direction, lastSeenSeqId);
    });
  }

  send_getFriendRequests (direction, lastSeenSeqId) {
    const output = new this.pClass(this.output);
    const params = {
      direction: direction,
      lastSeenSeqId: lastSeenSeqId
    };
    const args = new TalkService_getFriendRequests_args(params);
    try {
      output.writeMessageBegin('getFriendRequests', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getFriendRequests (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getFriendRequests_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getFriendRequests failed: unknown result');
  }

  kickoutFromGroup (reqSeq, groupId, contactIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_kickoutFromGroup(reqSeq, groupId, contactIds);
    });
  }

  send_kickoutFromGroup (reqSeq, groupId, contactIds) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      groupId: groupId,
      contactIds: contactIds
    };
    const args = new TalkService_kickoutFromGroup_args(params);
    try {
      output.writeMessageBegin('kickoutFromGroup', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_kickoutFromGroup (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_kickoutFromGroup_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  verifyIdentityCredentialWithResult (identityCredential, migrationPincodeSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_verifyIdentityCredentialWithResult(identityCredential, migrationPincodeSessionId);
    });
  }

  send_verifyIdentityCredentialWithResult (identityCredential, migrationPincodeSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      identityCredential: identityCredential,
      migrationPincodeSessionId: migrationPincodeSessionId
    };
    const args = new TalkService_verifyIdentityCredentialWithResult_args(params);
    try {
      output.writeMessageBegin('verifyIdentityCredentialWithResult', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_verifyIdentityCredentialWithResult (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_verifyIdentityCredentialWithResult_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('verifyIdentityCredentialWithResult failed: unknown result');
  }

  sendEchoPush (text) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendEchoPush(text);
    });
  }

  send_sendEchoPush (text) {
    const output = new this.pClass(this.output);
    const params = {
      text: text
    };
    const args = new TalkService_sendEchoPush_args(params);
    try {
      output.writeMessageBegin('sendEchoPush', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendEchoPush (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendEchoPush_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  createSession () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_createSession();
    });
  }

  send_createSession () {
    const output = new this.pClass(this.output);
    const args = new TalkService_createSession_args();
    try {
      output.writeMessageBegin('createSession', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_createSession (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_createSession_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('createSession failed: unknown result');
  }

  reissueDeviceCredential () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reissueDeviceCredential();
    });
  }

  send_reissueDeviceCredential () {
    const output = new this.pClass(this.output);
    const args = new TalkService_reissueDeviceCredential_args();
    try {
      output.writeMessageBegin('reissueDeviceCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reissueDeviceCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reissueDeviceCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('reissueDeviceCredential failed: unknown result');
  }

  getRecommendationIds () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRecommendationIds();
    });
  }

  send_getRecommendationIds () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getRecommendationIds_args();
    try {
      output.writeMessageBegin('getRecommendationIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRecommendationIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRecommendationIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRecommendationIds failed: unknown result');
  }

  inviteViaEmail (reqSeq, email, name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_inviteViaEmail(reqSeq, email, name);
    });
  }

  send_inviteViaEmail (reqSeq, email, name) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      email: email,
      name: name
    };
    const args = new TalkService_inviteViaEmail_args(params);
    try {
      output.writeMessageBegin('inviteViaEmail', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_inviteViaEmail (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_inviteViaEmail_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getRoomsV2 (roomIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRoomsV2(roomIds);
    });
  }

  send_getRoomsV2 (roomIds) {
    const output = new this.pClass(this.output);
    const params = {
      roomIds: roomIds
    };
    const args = new TalkService_getRoomsV2_args(params);
    try {
      output.writeMessageBegin('getRoomsV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRoomsV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRoomsV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRoomsV2 failed: unknown result');
  }

  getReadMessageOps (chatId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getReadMessageOps(chatId);
    });
  }

  send_getReadMessageOps (chatId) {
    const output = new this.pClass(this.output);
    const params = {
      chatId: chatId
    };
    const args = new TalkService_getReadMessageOps_args(params);
    try {
      output.writeMessageBegin('getReadMessageOps', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getReadMessageOps (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getReadMessageOps_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getReadMessageOps failed: unknown result');
  }

  getSettingsAttributes (attrBitset) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getSettingsAttributes(attrBitset);
    });
  }

  send_getSettingsAttributes (attrBitset) {
    const output = new this.pClass(this.output);
    const params = {
      attrBitset: attrBitset
    };
    const args = new TalkService_getSettingsAttributes_args(params);
    try {
      output.writeMessageBegin('getSettingsAttributes', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getSettingsAttributes (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getSettingsAttributes_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getSettingsAttributes failed: unknown result');
  }

  requestIdentityUnbind (identifier, provider) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_requestIdentityUnbind(identifier, provider);
    });
  }

  send_requestIdentityUnbind (identifier, provider) {
    const output = new this.pClass(this.output);
    const params = {
      identifier: identifier,
      provider: provider
    };
    const args = new TalkService_requestIdentityUnbind_args(params);
    try {
      output.writeMessageBegin('requestIdentityUnbind', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_requestIdentityUnbind (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_requestIdentityUnbind_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getMessagesBySequenceNumber (channelId, messageBoxId, startSeq, endSeq) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq);
    });
  }

  send_getMessagesBySequenceNumber (channelId, messageBoxId, startSeq, endSeq) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      messageBoxId: messageBoxId,
      startSeq: startSeq,
      endSeq: endSeq
    };
    const args = new TalkService_getMessagesBySequenceNumber_args(params);
    try {
      output.writeMessageBegin('getMessagesBySequenceNumber', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessagesBySequenceNumber (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessagesBySequenceNumber_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessagesBySequenceNumber failed: unknown result');
  }

  inviteIntoRoom (reqSeq, roomId, contactIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_inviteIntoRoom(reqSeq, roomId, contactIds);
    });
  }

  send_inviteIntoRoom (reqSeq, roomId, contactIds) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      roomId: roomId,
      contactIds: contactIds
    };
    const args = new TalkService_inviteIntoRoom_args(params);
    try {
      output.writeMessageBegin('inviteIntoRoom', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_inviteIntoRoom (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_inviteIntoRoom_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  sendChatChecked (seq, consumer, lastMessageId, sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendChatChecked(seq, consumer, lastMessageId, sessionId);
    });
  }

  send_sendChatChecked (seq, consumer, lastMessageId, sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      consumer: consumer,
      lastMessageId: lastMessageId,
      sessionId: sessionId
    };
    const args = new TalkService_sendChatChecked_args(params);
    try {
      output.writeMessageBegin('sendChatChecked', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendChatChecked (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendChatChecked_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  removeSnsId (snsIdType) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_removeSnsId(snsIdType);
    });
  }

  send_removeSnsId (snsIdType) {
    const output = new this.pClass(this.output);
    const params = {
      snsIdType: snsIdType
    };
    const args = new TalkService_removeSnsId_args(params);
    try {
      output.writeMessageBegin('removeSnsId', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_removeSnsId (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_removeSnsId_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('removeSnsId failed: unknown result');
  }

  reportSpammer (spammerMid, spammerReasons, spamMessageIds, spamMessages) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportSpammer(spammerMid, spammerReasons, spamMessageIds, spamMessages);
    });
  }

  send_reportSpammer (spammerMid, spammerReasons, spamMessageIds, spamMessages) {
    const output = new this.pClass(this.output);
    const params = {
      spammerMid: spammerMid,
      spammerReasons: spammerReasons,
      spamMessageIds: spamMessageIds,
      spamMessages: spamMessages
    };
    const args = new TalkService_reportSpammer_args(params);
    try {
      output.writeMessageBegin('reportSpammer', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportSpammer (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportSpammer_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  findAndAddContactsByEmail (reqSeq, emails) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findAndAddContactsByEmail(reqSeq, emails);
    });
  }

  send_findAndAddContactsByEmail (reqSeq, emails) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      emails: emails
    };
    const args = new TalkService_findAndAddContactsByEmail_args(params);
    try {
      output.writeMessageBegin('findAndAddContactsByEmail', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findAndAddContactsByEmail (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findAndAddContactsByEmail_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findAndAddContactsByEmail failed: unknown result');
  }

  getCompactGroups (groupIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getCompactGroups(groupIds);
    });
  }

  send_getCompactGroups (groupIds) {
    const output = new this.pClass(this.output);
    const params = {
      groupIds: groupIds
    };
    const args = new TalkService_getCompactGroups_args(params);
    try {
      output.writeMessageBegin('getCompactGroups', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getCompactGroups (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getCompactGroups_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getCompactGroups failed: unknown result');
  }

  sendMessage (seq, message) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendMessage(seq, message);
    });
  }

  send_sendMessage (seq, message) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      message: message
    };
    const args = new TalkService_sendMessage_args(params);
    try {
      output.writeMessageBegin('sendMessage', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendMessage (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendMessage_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sendMessage failed: unknown result');
  }

  getRooms (roomIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRooms(roomIds);
    });
  }

  send_getRooms (roomIds) {
    const output = new this.pClass(this.output);
    const params = {
      roomIds: roomIds
    };
    const args = new TalkService_getRooms_args(params);
    try {
      output.writeMessageBegin('getRooms', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRooms (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRooms_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRooms failed: unknown result');
  }

  updateC2DMRegistrationId (registrationId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateC2DMRegistrationId(registrationId);
    });
  }

  send_updateC2DMRegistrationId (registrationId) {
    const output = new this.pClass(this.output);
    const params = {
      registrationId: registrationId
    };
    const args = new TalkService_updateC2DMRegistrationId_args(params);
    try {
      output.writeMessageBegin('updateC2DMRegistrationId', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateC2DMRegistrationId (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateC2DMRegistrationId_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  sendPostback (request) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendPostback(request);
    });
  }

  send_sendPostback (request) {
    const output = new this.pClass(this.output);
    const params = {
      request: request
    };
    const args = new TalkService_sendPostback_args(params);
    try {
      output.writeMessageBegin('sendPostback', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendPostback (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendPostback_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getReadMessageOpsInBulk (chatIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getReadMessageOpsInBulk(chatIds);
    });
  }

  send_getReadMessageOpsInBulk (chatIds) {
    const output = new this.pClass(this.output);
    const params = {
      chatIds: chatIds
    };
    const args = new TalkService_getReadMessageOpsInBulk_args(params);
    try {
      output.writeMessageBegin('getReadMessageOpsInBulk', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getReadMessageOpsInBulk (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getReadMessageOpsInBulk_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getReadMessageOpsInBulk failed: unknown result');
  }

  sendMessageIgnored (seq, consumer, messageIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendMessageIgnored(seq, consumer, messageIds);
    });
  }

  send_sendMessageIgnored (seq, consumer, messageIds) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      consumer: consumer,
      messageIds: messageIds
    };
    const args = new TalkService_sendMessageIgnored_args(params);
    try {
      output.writeMessageBegin('sendMessageIgnored', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendMessageIgnored (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendMessageIgnored_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getMessageBoxWrapUpListV2 (messageBoxOffset, messageBoxCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxWrapUpListV2(messageBoxOffset, messageBoxCount);
    });
  }

  send_getMessageBoxWrapUpListV2 (messageBoxOffset, messageBoxCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxOffset: messageBoxOffset,
      messageBoxCount: messageBoxCount
    };
    const args = new TalkService_getMessageBoxWrapUpListV2_args(params);
    try {
      output.writeMessageBegin('getMessageBoxWrapUpListV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxWrapUpListV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxWrapUpListV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxWrapUpListV2 failed: unknown result');
  }

  getOldReadMessageOpsWithRange (startRev, endRev) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getOldReadMessageOpsWithRange(startRev, endRev);
    });
  }

  send_getOldReadMessageOpsWithRange (startRev, endRev) {
    const output = new this.pClass(this.output);
    const params = {
      startRev: startRev,
      endRev: endRev
    };
    const args = new TalkService_getOldReadMessageOpsWithRange_args(params);
    try {
      output.writeMessageBegin('getOldReadMessageOpsWithRange', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getOldReadMessageOpsWithRange (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getOldReadMessageOpsWithRange_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getOldReadMessageOpsWithRange failed: unknown result');
  }

  getRSAKeyInfo (provider) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRSAKeyInfo(provider);
    });
  }

  send_getRSAKeyInfo (provider) {
    const output = new this.pClass(this.output);
    const params = {
      provider: provider
    };
    const args = new TalkService_getRSAKeyInfo_args(params);
    try {
      output.writeMessageBegin('getRSAKeyInfo', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRSAKeyInfo (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRSAKeyInfo_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRSAKeyInfo failed: unknown result');
  }

  updateProfileAttribute (reqSeq, attr, value) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateProfileAttribute(reqSeq, attr, value);
    });
  }

  send_updateProfileAttribute (reqSeq, attr, value) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      attr: attr,
      value: value
    };
    const args = new TalkService_updateProfileAttribute_args(params);
    try {
      output.writeMessageBegin('updateProfileAttribute', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateProfileAttribute (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateProfileAttribute_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  createAccountMigrationPincodeSession () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_createAccountMigrationPincodeSession();
    });
  }

  send_createAccountMigrationPincodeSession () {
    const output = new this.pClass(this.output);
    const args = new TalkService_createAccountMigrationPincodeSession_args();
    try {
      output.writeMessageBegin('createAccountMigrationPincodeSession', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_createAccountMigrationPincodeSession (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_createAccountMigrationPincodeSession_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('createAccountMigrationPincodeSession failed: unknown result');
  }

  notifiedRedirect (paramMap) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifiedRedirect(paramMap);
    });
  }

  send_notifiedRedirect (paramMap) {
    const output = new this.pClass(this.output);
    const params = {
      paramMap: paramMap
    };
    const args = new TalkService_notifiedRedirect_args(params);
    try {
      output.writeMessageBegin('notifiedRedirect', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifiedRedirect (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifiedRedirect_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  notifyIndividualEvent (notificationStatus, receiverMids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifyIndividualEvent(notificationStatus, receiverMids);
    });
  }

  send_notifyIndividualEvent (notificationStatus, receiverMids) {
    const output = new this.pClass(this.output);
    const params = {
      notificationStatus: notificationStatus,
      receiverMids: receiverMids
    };
    const args = new TalkService_notifyIndividualEvent_args(params);
    try {
      output.writeMessageBegin('notifyIndividualEvent', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifyIndividualEvent (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifyIndividualEvent_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  updateApnsDeviceToken (apnsDeviceToken) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateApnsDeviceToken(apnsDeviceToken);
    });
  }

  send_updateApnsDeviceToken (apnsDeviceToken) {
    const output = new this.pClass(this.output);
    const params = {
      apnsDeviceToken: apnsDeviceToken
    };
    const args = new TalkService_updateApnsDeviceToken_args(params);
    try {
      output.writeMessageBegin('updateApnsDeviceToken', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateApnsDeviceToken (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateApnsDeviceToken_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getMessageBoxCompactWrapUpListV2 (messageBoxOffset, messageBoxCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxCompactWrapUpListV2(messageBoxOffset, messageBoxCount);
    });
  }

  send_getMessageBoxCompactWrapUpListV2 (messageBoxOffset, messageBoxCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxOffset: messageBoxOffset,
      messageBoxCount: messageBoxCount
    };
    const args = new TalkService_getMessageBoxCompactWrapUpListV2_args(params);
    try {
      output.writeMessageBegin('getMessageBoxCompactWrapUpListV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxCompactWrapUpListV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxCompactWrapUpListV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxCompactWrapUpListV2 failed: unknown result');
  }

  requestEmailConfirmation (emailConfirmation) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_requestEmailConfirmation(emailConfirmation);
    });
  }

  send_requestEmailConfirmation (emailConfirmation) {
    const output = new this.pClass(this.output);
    const params = {
      emailConfirmation: emailConfirmation
    };
    const args = new TalkService_requestEmailConfirmation_args(params);
    try {
      output.writeMessageBegin('requestEmailConfirmation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_requestEmailConfirmation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_requestEmailConfirmation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('requestEmailConfirmation failed: unknown result');
  }

  registerWithSnsIdAndIdentityCredential (snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo, migrationPincodeSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo, migrationPincodeSessionId);
    });
  }

  send_registerWithSnsIdAndIdentityCredential (snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo, migrationPincodeSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      snsIdType: snsIdType,
      snsAccessToken: snsAccessToken,
      identityCredential: identityCredential,
      region: region,
      udidHash: udidHash,
      deviceInfo: deviceInfo,
      migrationPincodeSessionId: migrationPincodeSessionId
    };
    const args = new TalkService_registerWithSnsIdAndIdentityCredential_args(params);
    try {
      output.writeMessageBegin('registerWithSnsIdAndIdentityCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerWithSnsIdAndIdentityCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerWithSnsIdAndIdentityCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerWithSnsIdAndIdentityCredential failed: unknown result');
  }

  getMessageBoxCompactWrapUp (mid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxCompactWrapUp(mid);
    });
  }

  send_getMessageBoxCompactWrapUp (mid) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid
    };
    const args = new TalkService_getMessageBoxCompactWrapUp_args(params);
    try {
      output.writeMessageBegin('getMessageBoxCompactWrapUp', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxCompactWrapUp (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxCompactWrapUp_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxCompactWrapUp failed: unknown result');
  }

  findContactByUserTicket (ticketIdWithTag) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findContactByUserTicket(ticketIdWithTag);
    });
  }

  send_findContactByUserTicket (ticketIdWithTag) {
    const output = new this.pClass(this.output);
    const params = {
      ticketIdWithTag: ticketIdWithTag
    };
    const args = new TalkService_findContactByUserTicket_args(params);
    try {
      output.writeMessageBegin('findContactByUserTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findContactByUserTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findContactByUserTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findContactByUserTicket failed: unknown result');
  }

  updateAccountMigrationPincode (accountMigrationPincode) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateAccountMigrationPincode(accountMigrationPincode);
    });
  }

  send_updateAccountMigrationPincode (accountMigrationPincode) {
    const output = new this.pClass(this.output);
    const params = {
      accountMigrationPincode: accountMigrationPincode
    };
    const args = new TalkService_updateAccountMigrationPincode_args(params);
    try {
      output.writeMessageBegin('updateAccountMigrationPincode', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateAccountMigrationPincode (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateAccountMigrationPincode_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  registerBuddyUser (buddyId, registrarPassword) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerBuddyUser(buddyId, registrarPassword);
    });
  }

  send_registerBuddyUser (buddyId, registrarPassword) {
    const output = new this.pClass(this.output);
    const params = {
      buddyId: buddyId,
      registrarPassword: registrarPassword
    };
    const args = new TalkService_registerBuddyUser_args(params);
    try {
      output.writeMessageBegin('registerBuddyUser', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerBuddyUser (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerBuddyUser_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerBuddyUser failed: unknown result');
  }

  updateSettings2 (reqSeq, settings) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateSettings2(reqSeq, settings);
    });
  }

  send_updateSettings2 (reqSeq, settings) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      settings: settings
    };
    const args = new TalkService_updateSettings2_args(params);
    try {
      output.writeMessageBegin('updateSettings2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateSettings2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateSettings2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('updateSettings2 failed: unknown result');
  }

  getUserTicket () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getUserTicket();
    });
  }

  send_getUserTicket () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getUserTicket_args();
    try {
      output.writeMessageBegin('getUserTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getUserTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getUserTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getUserTicket failed: unknown result');
  }

  fetchOps (localRev, count, globalRev, individualRev) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_fetchOps(localRev, count, globalRev, individualRev);
    });
  }

  send_fetchOps (localRev, count, globalRev, individualRev) {
    const output = new this.pClass(this.output);
    const params = {
      localRev: localRev,
      count: count,
      globalRev: globalRev,
      individualRev: individualRev
    };
    const args = new TalkService_fetchOps_args(params);
    try {
      output.writeMessageBegin('fetchOps', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_fetchOps (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_fetchOps_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('fetchOps failed: unknown result');
  }

  commitSendMessagesToMid (request) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_commitSendMessagesToMid(request);
    });
  }

  send_commitSendMessagesToMid (request) {
    const output = new this.pClass(this.output);
    const params = {
      request: request
    };
    const args = new TalkService_commitSendMessagesToMid_args(params);
    try {
      output.writeMessageBegin('commitSendMessagesToMid', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_commitSendMessagesToMid (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_commitSendMessagesToMid_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('commitSendMessagesToMid failed: unknown result');
  }

  getMessageBoxV2 (messageBoxId, lastMessagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxV2(messageBoxId, lastMessagesCount);
    });
  }

  send_getMessageBoxV2 (messageBoxId, lastMessagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId,
      lastMessagesCount: lastMessagesCount
    };
    const args = new TalkService_getMessageBoxV2_args(params);
    try {
      output.writeMessageBegin('getMessageBoxV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxV2 failed: unknown result');
  }

  requestResendMessage (reqSeq, senderMid, messageId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_requestResendMessage(reqSeq, senderMid, messageId);
    });
  }

  send_requestResendMessage (reqSeq, senderMid, messageId) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      senderMid: senderMid,
      messageId: messageId
    };
    const args = new TalkService_requestResendMessage_args(params);
    try {
      output.writeMessageBegin('requestResendMessage', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_requestResendMessage (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_requestResendMessage_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getGroupWithoutMembers (groupId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getGroupWithoutMembers(groupId);
    });
  }

  send_getGroupWithoutMembers (groupId) {
    const output = new this.pClass(this.output);
    const params = {
      groupId: groupId
    };
    const args = new TalkService_getGroupWithoutMembers_args(params);
    try {
      output.writeMessageBegin('getGroupWithoutMembers', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getGroupWithoutMembers (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getGroupWithoutMembers_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getGroupWithoutMembers failed: unknown result');
  }

  removeAllMessages (seq, lastMessageId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_removeAllMessages(seq, lastMessageId);
    });
  }

  send_removeAllMessages (seq, lastMessageId) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      lastMessageId: lastMessageId
    };
    const args = new TalkService_removeAllMessages_args(params);
    try {
      output.writeMessageBegin('removeAllMessages', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_removeAllMessages (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_removeAllMessages_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  verifyAccountMigration (migrationSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_verifyAccountMigration(migrationSessionId);
    });
  }

  send_verifyAccountMigration (migrationSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      migrationSessionId: migrationSessionId
    };
    const args = new TalkService_verifyAccountMigration_args(params);
    try {
      output.writeMessageBegin('verifyAccountMigration', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_verifyAccountMigration (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_verifyAccountMigration_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  reissueGroupTicket (groupMid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reissueGroupTicket(groupMid);
    });
  }

  send_reissueGroupTicket (groupMid) {
    const output = new this.pClass(this.output);
    const params = {
      groupMid: groupMid
    };
    const args = new TalkService_reissueGroupTicket_args(params);
    try {
      output.writeMessageBegin('reissueGroupTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reissueGroupTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reissueGroupTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('reissueGroupTicket failed: unknown result');
  }

  logoutSession (tokenKey) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_logoutSession(tokenKey);
    });
  }

  send_logoutSession (tokenKey) {
    const output = new this.pClass(this.output);
    const params = {
      tokenKey: tokenKey
    };
    const args = new TalkService_logoutSession_args(params);
    try {
      output.writeMessageBegin('logoutSession', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_logoutSession (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_logoutSession_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getBuddyLocation (mid, index) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getBuddyLocation(mid, index);
    });
  }

  send_getBuddyLocation (mid, index) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid,
      index: index
    };
    const args = new TalkService_getBuddyLocation_args(params);
    try {
      output.writeMessageBegin('getBuddyLocation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getBuddyLocation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getBuddyLocation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getBuddyLocation failed: unknown result');
  }

  getWapInvitation (invitationHash) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getWapInvitation(invitationHash);
    });
  }

  send_getWapInvitation (invitationHash) {
    const output = new this.pClass(this.output);
    const params = {
      invitationHash: invitationHash
    };
    const args = new TalkService_getWapInvitation_args(params);
    try {
      output.writeMessageBegin('getWapInvitation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getWapInvitation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getWapInvitation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getWapInvitation failed: unknown result');
  }

  registerDevice (sessionId, migrationPincodeSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerDevice(sessionId, migrationPincodeSessionId);
    });
  }

  send_registerDevice (sessionId, migrationPincodeSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId,
      migrationPincodeSessionId: migrationPincodeSessionId
    };
    const args = new TalkService_registerDevice_args(params);
    try {
      output.writeMessageBegin('registerDevice', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerDevice (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerDevice_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerDevice failed: unknown result');
  }

  clearMessageBox (channelId, messageBoxId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clearMessageBox(channelId, messageBoxId);
    });
  }

  send_clearMessageBox (channelId, messageBoxId) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      messageBoxId: messageBoxId
    };
    const args = new TalkService_clearMessageBox_args(params);
    try {
      output.writeMessageBegin('clearMessageBox', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clearMessageBox (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_clearMessageBox_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  loginWithIdentityCredentialForCertificate (identifier, password, keepLoggedIn, accessLocation, systemName, identityProvider, certificate) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_loginWithIdentityCredentialForCertificate(identifier, password, keepLoggedIn, accessLocation, systemName, identityProvider, certificate);
    });
  }

  send_loginWithIdentityCredentialForCertificate (identifier, password, keepLoggedIn, accessLocation, systemName, identityProvider, certificate) {
    const output = new this.pClass(this.output);
    const params = {
      identifier: identifier,
      password: password,
      keepLoggedIn: keepLoggedIn,
      accessLocation: accessLocation,
      systemName: systemName,
      identityProvider: identityProvider,
      certificate: certificate
    };
    const args = new TalkService_loginWithIdentityCredentialForCertificate_args(params);
    try {
      output.writeMessageBegin('loginWithIdentityCredentialForCertificate', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_loginWithIdentityCredentialForCertificate (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_loginWithIdentityCredentialForCertificate_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('loginWithIdentityCredentialForCertificate failed: unknown result');
  }

  getSuggestSettings (locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getSuggestSettings(locale);
    });
  }

  send_getSuggestSettings (locale) {
    const output = new this.pClass(this.output);
    const params = {
      locale: locale
    };
    const args = new TalkService_getSuggestSettings_args(params);
    try {
      output.writeMessageBegin('getSuggestSettings', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getSuggestSettings (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getSuggestSettings_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getSuggestSettings failed: unknown result');
  }

  updateAndGetNearby (latitude, longitude) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateAndGetNearby(latitude, longitude);
    });
  }

  send_updateAndGetNearby (latitude, longitude) {
    const output = new this.pClass(this.output);
    const params = {
      latitude: latitude,
      longitude: longitude
    };
    const args = new TalkService_updateAndGetNearby_args(params);
    try {
      output.writeMessageBegin('updateAndGetNearby', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateAndGetNearby (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateAndGetNearby_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('updateAndGetNearby failed: unknown result');
  }

  syncContactBySnsIds (reqSeq, modifications) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_syncContactBySnsIds(reqSeq, modifications);
    });
  }

  send_syncContactBySnsIds (reqSeq, modifications) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      modifications: modifications
    };
    const args = new TalkService_syncContactBySnsIds_args(params);
    try {
      output.writeMessageBegin('syncContactBySnsIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_syncContactBySnsIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_syncContactBySnsIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('syncContactBySnsIds failed: unknown result');
  }

  getContacts (ids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getContacts(ids);
    });
  }

  send_getContacts (ids) {
    const output = new this.pClass(this.output);
    const params = {
      ids: ids
    };
    const args = new TalkService_getContacts_args(params);
    try {
      output.writeMessageBegin('getContacts', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getContacts (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getContacts_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getContacts failed: unknown result');
  }

  getMessageBoxCompactWrapUpList (start, messageBoxCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxCompactWrapUpList(start, messageBoxCount);
    });
  }

  send_getMessageBoxCompactWrapUpList (start, messageBoxCount) {
    const output = new this.pClass(this.output);
    const params = {
      start: start,
      messageBoxCount: messageBoxCount
    };
    const args = new TalkService_getMessageBoxCompactWrapUpList_args(params);
    try {
      output.writeMessageBegin('getMessageBoxCompactWrapUpList', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxCompactWrapUpList (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxCompactWrapUpList_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxCompactWrapUpList failed: unknown result');
  }

  getProximityMatchCandidates (sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getProximityMatchCandidates(sessionId);
    });
  }

  send_getProximityMatchCandidates (sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId
    };
    const args = new TalkService_getProximityMatchCandidates_args(params);
    try {
      output.writeMessageBegin('getProximityMatchCandidates', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getProximityMatchCandidates (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getProximityMatchCandidates_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getProximityMatchCandidates failed: unknown result');
  }

  updateExtendedProfileAttribute (reqSeq, attr, extendedProfile) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateExtendedProfileAttribute(reqSeq, attr, extendedProfile);
    });
  }

  send_updateExtendedProfileAttribute (reqSeq, attr, extendedProfile) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      attr: attr,
      extendedProfile: extendedProfile
    };
    const args = new TalkService_updateExtendedProfileAttribute_args(params);
    try {
      output.writeMessageBegin('updateExtendedProfileAttribute', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateExtendedProfileAttribute (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateExtendedProfileAttribute_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  resendPinCode (sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_resendPinCode(sessionId);
    });
  }

  send_resendPinCode (sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId
    };
    const args = new TalkService_resendPinCode_args(params);
    try {
      output.writeMessageBegin('resendPinCode', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_resendPinCode (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_resendPinCode_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  reportSettings (syncOpRevision, settings) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportSettings(syncOpRevision, settings);
    });
  }

  send_reportSettings (syncOpRevision, settings) {
    const output = new this.pClass(this.output);
    const params = {
      syncOpRevision: syncOpRevision,
      settings: settings
    };
    const args = new TalkService_reportSettings_args(params);
    try {
      output.writeMessageBegin('reportSettings', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportSettings (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportSettings_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  registerBuddyUserid (seq, userid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerBuddyUserid(seq, userid);
    });
  }

  send_registerBuddyUserid (seq, userid) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      userid: userid
    };
    const args = new TalkService_registerBuddyUserid_args(params);
    try {
      output.writeMessageBegin('registerBuddyUserid', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerBuddyUserid (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerBuddyUserid_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  findGroupByTicket (ticketId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findGroupByTicket(ticketId);
    });
  }

  send_findGroupByTicket (ticketId) {
    const output = new this.pClass(this.output);
    const params = {
      ticketId: ticketId
    };
    const args = new TalkService_findGroupByTicket_args(params);
    try {
      output.writeMessageBegin('findGroupByTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findGroupByTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findGroupByTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findGroupByTicket failed: unknown result');
  }

  registerDeviceWithIdentityCredential (sessionId, identifier, verifier, provider, migrationPincodeSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerDeviceWithIdentityCredential(sessionId, identifier, verifier, provider, migrationPincodeSessionId);
    });
  }

  send_registerDeviceWithIdentityCredential (sessionId, identifier, verifier, provider, migrationPincodeSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId,
      identifier: identifier,
      verifier: verifier,
      provider: provider,
      migrationPincodeSessionId: migrationPincodeSessionId
    };
    const args = new TalkService_registerDeviceWithIdentityCredential_args(params);
    try {
      output.writeMessageBegin('registerDeviceWithIdentityCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerDeviceWithIdentityCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerDeviceWithIdentityCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerDeviceWithIdentityCredential failed: unknown result');
  }

  invalidateUserTicket () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_invalidateUserTicket();
    });
  }

  send_invalidateUserTicket () {
    const output = new this.pClass(this.output);
    const args = new TalkService_invalidateUserTicket_args();
    try {
      output.writeMessageBegin('invalidateUserTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_invalidateUserTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_invalidateUserTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  sendEvent (seq, message) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendEvent(seq, message);
    });
  }

  send_sendEvent (seq, message) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      message: message
    };
    const args = new TalkService_sendEvent_args(params);
    try {
      output.writeMessageBegin('sendEvent', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendEvent (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendEvent_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sendEvent failed: unknown result');
  }

  sendMessageToMyHome (seq, message) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendMessageToMyHome(seq, message);
    });
  }

  send_sendMessageToMyHome (seq, message) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      message: message
    };
    const args = new TalkService_sendMessageToMyHome_args(params);
    try {
      output.writeMessageBegin('sendMessageToMyHome', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendMessageToMyHome (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendMessageToMyHome_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sendMessageToMyHome failed: unknown result');
  }

  sendContentPreviewUpdated (esq, messageId, receiverMids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendContentPreviewUpdated(esq, messageId, receiverMids);
    });
  }

  send_sendContentPreviewUpdated (esq, messageId, receiverMids) {
    const output = new this.pClass(this.output);
    const params = {
      esq: esq,
      messageId: messageId,
      receiverMids: receiverMids
    };
    const args = new TalkService_sendContentPreviewUpdated_args(params);
    try {
      output.writeMessageBegin('sendContentPreviewUpdated', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendContentPreviewUpdated (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendContentPreviewUpdated_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sendContentPreviewUpdated failed: unknown result');
  }

  loginWithVerifier (verifier) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_loginWithVerifier(verifier);
    });
  }

  send_loginWithVerifier (verifier) {
    const output = new this.pClass(this.output);
    const params = {
      verifier: verifier
    };
    const args = new TalkService_loginWithVerifier_args(params);
    try {
      output.writeMessageBegin('loginWithVerifier', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_loginWithVerifier (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_loginWithVerifier_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('loginWithVerifier failed: unknown result');
  }

  removeBuddySubscriptionAndNotifyBuddyUnregistered (subscriberMids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_removeBuddySubscriptionAndNotifyBuddyUnregistered(subscriberMids);
    });
  }

  send_removeBuddySubscriptionAndNotifyBuddyUnregistered (subscriberMids) {
    const output = new this.pClass(this.output);
    const params = {
      subscriberMids: subscriberMids
    };
    const args = new TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_args(params);
    try {
      output.writeMessageBegin('removeBuddySubscriptionAndNotifyBuddyUnregistered', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_removeBuddySubscriptionAndNotifyBuddyUnregistered (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  unblockContact (reqSeq, id, reference) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_unblockContact(reqSeq, id, reference);
    });
  }

  send_unblockContact (reqSeq, id, reference) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      id: id,
      reference: reference
    };
    const args = new TalkService_unblockContact_args(params);
    try {
      output.writeMessageBegin('unblockContact', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_unblockContact (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_unblockContact_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  removeBuddyLocation (mid, index) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_removeBuddyLocation(mid, index);
    });
  }

  send_removeBuddyLocation (mid, index) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid,
      index: index
    };
    const args = new TalkService_removeBuddyLocation_args(params);
    try {
      output.writeMessageBegin('removeBuddyLocation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_removeBuddyLocation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_removeBuddyLocation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getRingbackTone () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRingbackTone();
    });
  }

  send_getRingbackTone () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getRingbackTone_args();
    try {
      output.writeMessageBegin('getRingbackTone', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRingbackTone (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRingbackTone_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRingbackTone failed: unknown result');
  }

  getConfigurations (revision, regionOfUsim, regionOfTelephone, regionOfLocale, carrier) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getConfigurations(revision, regionOfUsim, regionOfTelephone, regionOfLocale, carrier);
    });
  }

  send_getConfigurations (revision, regionOfUsim, regionOfTelephone, regionOfLocale, carrier) {
    const output = new this.pClass(this.output);
    const params = {
      revision: revision,
      regionOfUsim: regionOfUsim,
      regionOfTelephone: regionOfTelephone,
      regionOfLocale: regionOfLocale,
      carrier: carrier
    };
    const args = new TalkService_getConfigurations_args(params);
    try {
      output.writeMessageBegin('getConfigurations', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getConfigurations (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getConfigurations_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getConfigurations failed: unknown result');
  }

  getProximityMatchCandidateList (sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getProximityMatchCandidateList(sessionId);
    });
  }

  send_getProximityMatchCandidateList (sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId
    };
    const args = new TalkService_getProximityMatchCandidateList_args(params);
    try {
      output.writeMessageBegin('getProximityMatchCandidateList', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getProximityMatchCandidateList (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getProximityMatchCandidateList_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getProximityMatchCandidateList failed: unknown result');
  }

  requestAccountPasswordReset (identifier, provider, locale) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_requestAccountPasswordReset(identifier, provider, locale);
    });
  }

  send_requestAccountPasswordReset (identifier, provider, locale) {
    const output = new this.pClass(this.output);
    const params = {
      identifier: identifier,
      provider: provider,
      locale: locale
    };
    const args = new TalkService_requestAccountPasswordReset_args(params);
    try {
      output.writeMessageBegin('requestAccountPasswordReset', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_requestAccountPasswordReset (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_requestAccountPasswordReset_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getNextMessages (messageBoxId, startSeq, messagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getNextMessages(messageBoxId, startSeq, messagesCount);
    });
  }

  send_getNextMessages (messageBoxId, startSeq, messagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId,
      startSeq: startSeq,
      messagesCount: messagesCount
    };
    const args = new TalkService_getNextMessages_args(params);
    try {
      output.writeMessageBegin('getNextMessages', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getNextMessages (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getNextMessages_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getNextMessages failed: unknown result');
  }

  reportProfile (syncOpRevision, profile) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportProfile(syncOpRevision, profile);
    });
  }

  send_reportProfile (syncOpRevision, profile) {
    const output = new this.pClass(this.output);
    const params = {
      syncOpRevision: syncOpRevision,
      profile: profile
    };
    const args = new TalkService_reportProfile_args(params);
    try {
      output.writeMessageBegin('reportProfile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportProfile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportProfile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getCompactRoom (roomId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getCompactRoom(roomId);
    });
  }

  send_getCompactRoom (roomId) {
    const output = new this.pClass(this.output);
    const params = {
      roomId: roomId
    };
    const args = new TalkService_getCompactRoom_args(params);
    try {
      output.writeMessageBegin('getCompactRoom', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getCompactRoom (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getCompactRoom_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getCompactRoom failed: unknown result');
  }

  getLastOpRevision () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getLastOpRevision();
    });
  }

  send_getLastOpRevision () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getLastOpRevision_args();
    try {
      output.writeMessageBegin('getLastOpRevision', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getLastOpRevision (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getLastOpRevision_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getLastOpRevision failed: unknown result');
  }

  getPreviousMessagesV2 (messageBoxId, endMessageId, messagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getPreviousMessagesV2(messageBoxId, endMessageId, messagesCount);
    });
  }

  send_getPreviousMessagesV2 (messageBoxId, endMessageId, messagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId,
      endMessageId: endMessageId,
      messagesCount: messagesCount
    };
    const args = new TalkService_getPreviousMessagesV2_args(params);
    try {
      output.writeMessageBegin('getPreviousMessagesV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getPreviousMessagesV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getPreviousMessagesV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getPreviousMessagesV2 failed: unknown result');
  }

  fetchAnnouncements (lastFetchedIndex) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_fetchAnnouncements(lastFetchedIndex);
    });
  }

  send_fetchAnnouncements (lastFetchedIndex) {
    const output = new this.pClass(this.output);
    const params = {
      lastFetchedIndex: lastFetchedIndex
    };
    const args = new TalkService_fetchAnnouncements_args(params);
    try {
      output.writeMessageBegin('fetchAnnouncements', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_fetchAnnouncements (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_fetchAnnouncements_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('fetchAnnouncements failed: unknown result');
  }

  acquireCallRoute (to) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_acquireCallRoute(to);
    });
  }

  send_acquireCallRoute (to) {
    const output = new this.pClass(this.output);
    const params = {
      to: to
    };
    const args = new TalkService_acquireCallRoute_args(params);
    try {
      output.writeMessageBegin('acquireCallRoute', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_acquireCallRoute (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_acquireCallRoute_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('acquireCallRoute failed: unknown result');
  }

  updateSettingsAttribute (reqSeq, attr, value) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateSettingsAttribute(reqSeq, attr, value);
    });
  }

  send_updateSettingsAttribute (reqSeq, attr, value) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      attr: attr,
      value: value
    };
    const args = new TalkService_updateSettingsAttribute_args(params);
    try {
      output.writeMessageBegin('updateSettingsAttribute', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateSettingsAttribute (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateSettingsAttribute_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  createGroupV2 (seq, name, contactIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_createGroupV2(seq, name, contactIds);
    });
  }

  send_createGroupV2 (seq, name, contactIds) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      name: name,
      contactIds: contactIds
    };
    const args = new TalkService_createGroupV2_args(params);
    try {
      output.writeMessageBegin('createGroupV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_createGroupV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_createGroupV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('createGroupV2 failed: unknown result');
  }

  isIdentityIdentifierAvailable (identifier, provider) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_isIdentityIdentifierAvailable(identifier, provider);
    });
  }

  send_isIdentityIdentifierAvailable (identifier, provider) {
    const output = new this.pClass(this.output);
    const params = {
      identifier: identifier,
      provider: provider
    };
    const args = new TalkService_isIdentityIdentifierAvailable_args(params);
    try {
      output.writeMessageBegin('isIdentityIdentifierAvailable', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_isIdentityIdentifierAvailable (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_isIdentityIdentifierAvailable_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('isIdentityIdentifierAvailable failed: unknown result');
  }

  blockContact (reqSeq, id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_blockContact(reqSeq, id);
    });
  }

  send_blockContact (reqSeq, id) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      id: id
    };
    const args = new TalkService_blockContact_args(params);
    try {
      output.writeMessageBegin('blockContact', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_blockContact (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_blockContact_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  commitUpdateProfile (seq, attrs, receiverMids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_commitUpdateProfile(seq, attrs, receiverMids);
    });
  }

  send_commitUpdateProfile (seq, attrs, receiverMids) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      attrs: attrs,
      receiverMids: receiverMids
    };
    const args = new TalkService_commitUpdateProfile_args(params);
    try {
      output.writeMessageBegin('commitUpdateProfile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_commitUpdateProfile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_commitUpdateProfile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('commitUpdateProfile failed: unknown result');
  }

  registerWithSnsId (snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid, migrationPincodeSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid, migrationPincodeSessionId);
    });
  }

  send_registerWithSnsId (snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid, migrationPincodeSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      snsIdType: snsIdType,
      snsAccessToken: snsAccessToken,
      region: region,
      udidHash: udidHash,
      deviceInfo: deviceInfo,
      mid: mid,
      migrationPincodeSessionId: migrationPincodeSessionId
    };
    const args = new TalkService_registerWithSnsId_args(params);
    try {
      output.writeMessageBegin('registerWithSnsId', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerWithSnsId (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerWithSnsId_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerWithSnsId failed: unknown result');
  }

  updatePublicKeychain (publicKeychain) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updatePublicKeychain(publicKeychain);
    });
  }

  send_updatePublicKeychain (publicKeychain) {
    const output = new this.pClass(this.output);
    const params = {
      publicKeychain: publicKeychain
    };
    const args = new TalkService_updatePublicKeychain_args(params);
    try {
      output.writeMessageBegin('updatePublicKeychain', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updatePublicKeychain (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updatePublicKeychain_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('updatePublicKeychain failed: unknown result');
  }

  loginWithVerifierForCerificate (verifier) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_loginWithVerifierForCerificate(verifier);
    });
  }

  send_loginWithVerifierForCerificate (verifier) {
    const output = new this.pClass(this.output);
    const params = {
      verifier: verifier
    };
    const args = new TalkService_loginWithVerifierForCerificate_args(params);
    try {
      output.writeMessageBegin('loginWithVerifierForCerificate', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_loginWithVerifierForCerificate (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_loginWithVerifierForCerificate_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('loginWithVerifierForCerificate failed: unknown result');
  }

  tryFriendRequest (midOrEMid, method, friendRequestParams) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_tryFriendRequest(midOrEMid, method, friendRequestParams);
    });
  }

  send_tryFriendRequest (midOrEMid, method, friendRequestParams) {
    const output = new this.pClass(this.output);
    const params = {
      midOrEMid: midOrEMid,
      method: method,
      friendRequestParams: friendRequestParams
    };
    const args = new TalkService_tryFriendRequest_args(params);
    try {
      output.writeMessageBegin('tryFriendRequest', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_tryFriendRequest (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_tryFriendRequest_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getBlockedRecommendationIds () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getBlockedRecommendationIds();
    });
  }

  send_getBlockedRecommendationIds () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getBlockedRecommendationIds_args();
    try {
      output.writeMessageBegin('getBlockedRecommendationIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getBlockedRecommendationIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getBlockedRecommendationIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getBlockedRecommendationIds failed: unknown result');
  }

  getGroupIdsInvited () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getGroupIdsInvited();
    });
  }

  send_getGroupIdsInvited () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getGroupIdsInvited_args();
    try {
      output.writeMessageBegin('getGroupIdsInvited', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getGroupIdsInvited (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getGroupIdsInvited_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getGroupIdsInvited failed: unknown result');
  }

  getSuggestIncrements (revisions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getSuggestIncrements(revisions);
    });
  }

  send_getSuggestIncrements (revisions) {
    const output = new this.pClass(this.output);
    const params = {
      revisions: revisions
    };
    const args = new TalkService_getSuggestIncrements_args(params);
    try {
      output.writeMessageBegin('getSuggestIncrements', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getSuggestIncrements (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getSuggestIncrements_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getSuggestIncrements failed: unknown result');
  }

  resendPinCodeBySMS (sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_resendPinCodeBySMS(sessionId);
    });
  }

  send_resendPinCodeBySMS (sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId
    };
    const args = new TalkService_resendPinCodeBySMS_args(params);
    try {
      output.writeMessageBegin('resendPinCodeBySMS', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_resendPinCodeBySMS (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_resendPinCodeBySMS_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  registerWithPhoneNumber (sessionId, migrationPincodeSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerWithPhoneNumber(sessionId, migrationPincodeSessionId);
    });
  }

  send_registerWithPhoneNumber (sessionId, migrationPincodeSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId,
      migrationPincodeSessionId: migrationPincodeSessionId
    };
    const args = new TalkService_registerWithPhoneNumber_args(params);
    try {
      output.writeMessageBegin('registerWithPhoneNumber', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerWithPhoneNumber (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerWithPhoneNumber_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerWithPhoneNumber failed: unknown result');
  }

  getActiveBuddySubscriberIds () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getActiveBuddySubscriberIds();
    });
  }

  send_getActiveBuddySubscriberIds () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getActiveBuddySubscriberIds_args();
    try {
      output.writeMessageBegin('getActiveBuddySubscriberIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getActiveBuddySubscriberIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getActiveBuddySubscriberIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getActiveBuddySubscriberIds failed: unknown result');
  }

  createRoom (reqSeq, contactIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_createRoom(reqSeq, contactIds);
    });
  }

  send_createRoom (reqSeq, contactIds) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      contactIds: contactIds
    };
    const args = new TalkService_createRoom_args(params);
    try {
      output.writeMessageBegin('createRoom', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_createRoom (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_createRoom_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('createRoom failed: unknown result');
  }

  verifyPhoneNumberForLogin (verifierFromPhone, pinCodeForPhone, verifierFromLogin) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_verifyPhoneNumberForLogin(verifierFromPhone, pinCodeForPhone, verifierFromLogin);
    });
  }

  send_verifyPhoneNumberForLogin (verifierFromPhone, pinCodeForPhone, verifierFromLogin) {
    const output = new this.pClass(this.output);
    const params = {
      verifierFromPhone: verifierFromPhone,
      pinCodeForPhone: pinCodeForPhone,
      verifierFromLogin: verifierFromLogin
    };
    const args = new TalkService_verifyPhoneNumberForLogin_args(params);
    try {
      output.writeMessageBegin('verifyPhoneNumberForLogin', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_verifyPhoneNumberForLogin (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_verifyPhoneNumberForLogin_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('verifyPhoneNumberForLogin failed: unknown result');
  }

  addSnsId (snsIdType, snsAccessToken) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_addSnsId(snsIdType, snsAccessToken);
    });
  }

  send_addSnsId (snsIdType, snsAccessToken) {
    const output = new this.pClass(this.output);
    const params = {
      snsIdType: snsIdType,
      snsAccessToken: snsAccessToken
    };
    const args = new TalkService_addSnsId_args(params);
    try {
      output.writeMessageBegin('addSnsId', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_addSnsId (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_addSnsId_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('addSnsId failed: unknown result');
  }

  finishUpdateVerification (sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_finishUpdateVerification(sessionId);
    });
  }

  send_finishUpdateVerification (sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId
    };
    const args = new TalkService_finishUpdateVerification_args(params);
    try {
      output.writeMessageBegin('finishUpdateVerification', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_finishUpdateVerification (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_finishUpdateVerification_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  validateContactsOnBot (contacts) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_validateContactsOnBot(contacts);
    });
  }

  send_validateContactsOnBot (contacts) {
    const output = new this.pClass(this.output);
    const params = {
      contacts: contacts
    };
    const args = new TalkService_validateContactsOnBot_args(params);
    try {
      output.writeMessageBegin('validateContactsOnBot', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_validateContactsOnBot (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_validateContactsOnBot_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('validateContactsOnBot failed: unknown result');
  }

  getRoom (roomId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRoom(roomId);
    });
  }

  send_getRoom (roomId) {
    const output = new this.pClass(this.output);
    const params = {
      roomId: roomId
    };
    const args = new TalkService_getRoom_args(params);
    try {
      output.writeMessageBegin('getRoom', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRoom (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRoom_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRoom failed: unknown result');
  }

  closeProximityMatch (sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_closeProximityMatch(sessionId);
    });
  }

  send_closeProximityMatch (sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId
    };
    const args = new TalkService_closeProximityMatch_args(params);
    try {
      output.writeMessageBegin('closeProximityMatch', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_closeProximityMatch (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_closeProximityMatch_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getCompactGroup (groupId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getCompactGroup(groupId);
    });
  }

  send_getCompactGroup (groupId) {
    const output = new this.pClass(this.output);
    const params = {
      groupId: groupId
    };
    const args = new TalkService_getCompactGroup_args(params);
    try {
      output.writeMessageBegin('getCompactGroup', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getCompactGroup (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getCompactGroup_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getCompactGroup failed: unknown result');
  }

  getBlockedContactIdsByRange (start, count) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getBlockedContactIdsByRange(start, count);
    });
  }

  send_getBlockedContactIdsByRange (start, count) {
    const output = new this.pClass(this.output);
    const params = {
      start: start,
      count: count
    };
    const args = new TalkService_getBlockedContactIdsByRange_args(params);
    try {
      output.writeMessageBegin('getBlockedContactIdsByRange', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getBlockedContactIdsByRange (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getBlockedContactIdsByRange_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getBlockedContactIdsByRange failed: unknown result');
  }

  getRecentMessagesV2 (messageBoxId, messagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRecentMessagesV2(messageBoxId, messagesCount);
    });
  }

  send_getRecentMessagesV2 (messageBoxId, messagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId,
      messagesCount: messagesCount
    };
    const args = new TalkService_getRecentMessagesV2_args(params);
    try {
      output.writeMessageBegin('getRecentMessagesV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRecentMessagesV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRecentMessagesV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRecentMessagesV2 failed: unknown result');
  }

  reissueUserTicket (expirationTime, maxUseCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reissueUserTicket(expirationTime, maxUseCount);
    });
  }

  send_reissueUserTicket (expirationTime, maxUseCount) {
    const output = new this.pClass(this.output);
    const params = {
      expirationTime: expirationTime,
      maxUseCount: maxUseCount
    };
    const args = new TalkService_reissueUserTicket_args(params);
    try {
      output.writeMessageBegin('reissueUserTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reissueUserTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reissueUserTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('reissueUserTicket failed: unknown result');
  }

  getMessageReadRange (chatIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageReadRange(chatIds);
    });
  }

  send_getMessageReadRange (chatIds) {
    const output = new this.pClass(this.output);
    const params = {
      chatIds: chatIds
    };
    const args = new TalkService_getMessageReadRange_args(params);
    try {
      output.writeMessageBegin('getMessageReadRange', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageReadRange (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageReadRange_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageReadRange failed: unknown result');
  }

  clearRingbackTone () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clearRingbackTone();
    });
  }

  send_clearRingbackTone () {
    const output = new this.pClass(this.output);
    const args = new TalkService_clearRingbackTone_args();
    try {
      output.writeMessageBegin('clearRingbackTone', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clearRingbackTone (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_clearRingbackTone_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  setIdentityCredential (identifier, verifier, provider) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_setIdentityCredential(identifier, verifier, provider);
    });
  }

  send_setIdentityCredential (identifier, verifier, provider) {
    const output = new this.pClass(this.output);
    const params = {
      identifier: identifier,
      verifier: verifier,
      provider: provider
    };
    const args = new TalkService_setIdentityCredential_args(params);
    try {
      output.writeMessageBegin('setIdentityCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_setIdentityCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_setIdentityCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getMessageBoxCompactWrapUpV2 (messageBoxId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxCompactWrapUpV2(messageBoxId);
    });
  }

  send_getMessageBoxCompactWrapUpV2 (messageBoxId) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId
    };
    const args = new TalkService_getMessageBoxCompactWrapUpV2_args(params);
    try {
      output.writeMessageBegin('getMessageBoxCompactWrapUpV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxCompactWrapUpV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxCompactWrapUpV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxCompactWrapUpV2 failed: unknown result');
  }

  getServerTime () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getServerTime();
    });
  }

  send_getServerTime () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getServerTime_args();
    try {
      output.writeMessageBegin('getServerTime', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getServerTime (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getServerTime_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getServerTime failed: unknown result');
  }

  trySendMessage (seq, message) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_trySendMessage(seq, message);
    });
  }

  send_trySendMessage (seq, message) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      message: message
    };
    const args = new TalkService_trySendMessage_args(params);
    try {
      output.writeMessageBegin('trySendMessage', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_trySendMessage (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_trySendMessage_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('trySendMessage failed: unknown result');
  }

  getNextMessagesV2 (messageBoxId, startMessageId, messagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getNextMessagesV2(messageBoxId, startMessageId, messagesCount);
    });
  }

  send_getNextMessagesV2 (messageBoxId, startMessageId, messagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId,
      startMessageId: startMessageId,
      messagesCount: messagesCount
    };
    const args = new TalkService_getNextMessagesV2_args(params);
    try {
      output.writeMessageBegin('getNextMessagesV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getNextMessagesV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getNextMessagesV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getNextMessagesV2 failed: unknown result');
  }

  notifySleep (lastRev, badge) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifySleep(lastRev, badge);
    });
  }

  send_notifySleep (lastRev, badge) {
    const output = new this.pClass(this.output);
    const params = {
      lastRev: lastRev,
      badge: badge
    };
    const args = new TalkService_notifySleep_args(params);
    try {
      output.writeMessageBegin('notifySleep', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifySleep (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifySleep_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getBuddyBlockerIds () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getBuddyBlockerIds();
    });
  }

  send_getBuddyBlockerIds () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getBuddyBlockerIds_args();
    try {
      output.writeMessageBegin('getBuddyBlockerIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getBuddyBlockerIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getBuddyBlockerIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getBuddyBlockerIds failed: unknown result');
  }

  removeE2EEPublicKey (publicKey) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_removeE2EEPublicKey(publicKey);
    });
  }

  send_removeE2EEPublicKey (publicKey) {
    const output = new this.pClass(this.output);
    const params = {
      publicKey: publicKey
    };
    const args = new TalkService_removeE2EEPublicKey_args(params);
    try {
      output.writeMessageBegin('removeE2EEPublicKey', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_removeE2EEPublicKey (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_removeE2EEPublicKey_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  reissueTrackingTicket (type) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reissueTrackingTicket(type);
    });
  }

  send_reissueTrackingTicket (type) {
    const output = new this.pClass(this.output);
    const params = {
      type: type
    };
    const args = new TalkService_reissueTrackingTicket_args(params);
    try {
      output.writeMessageBegin('reissueTrackingTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reissueTrackingTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reissueTrackingTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('reissueTrackingTicket failed: unknown result');
  }

  cancelGroupInvitation (reqSeq, groupId, contactIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_cancelGroupInvitation(reqSeq, groupId, contactIds);
    });
  }

  send_cancelGroupInvitation (reqSeq, groupId, contactIds) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      groupId: groupId,
      contactIds: contactIds
    };
    const args = new TalkService_cancelGroupInvitation_args(params);
    try {
      output.writeMessageBegin('cancelGroupInvitation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_cancelGroupInvitation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_cancelGroupInvitation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  removeMessage (messageId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_removeMessage(messageId);
    });
  }

  send_removeMessage (messageId) {
    const output = new this.pClass(this.output);
    const params = {
      messageId: messageId
    };
    const args = new TalkService_removeMessage_args(params);
    try {
      output.writeMessageBegin('removeMessage', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_removeMessage (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_removeMessage_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('removeMessage failed: unknown result');
  }

  getAllReadMessageOps () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getAllReadMessageOps();
    });
  }

  send_getAllReadMessageOps () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getAllReadMessageOps_args();
    try {
      output.writeMessageBegin('getAllReadMessageOps', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getAllReadMessageOps (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getAllReadMessageOps_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getAllReadMessageOps failed: unknown result');
  }

  unregisterUserAndDevice () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_unregisterUserAndDevice();
    });
  }

  send_unregisterUserAndDevice () {
    const output = new this.pClass(this.output);
    const args = new TalkService_unregisterUserAndDevice_args();
    try {
      output.writeMessageBegin('unregisterUserAndDevice', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_unregisterUserAndDevice (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_unregisterUserAndDevice_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('unregisterUserAndDevice failed: unknown result');
  }

  acceptGroupInvitation (reqSeq, groupId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_acceptGroupInvitation(reqSeq, groupId);
    });
  }

  send_acceptGroupInvitation (reqSeq, groupId) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      groupId: groupId
    };
    const args = new TalkService_acceptGroupInvitation_args(params);
    try {
      output.writeMessageBegin('acceptGroupInvitation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_acceptGroupInvitation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_acceptGroupInvitation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getCompactContactsModifiedSince (timestamp) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getCompactContactsModifiedSince(timestamp);
    });
  }

  send_getCompactContactsModifiedSince (timestamp) {
    const output = new this.pClass(this.output);
    const params = {
      timestamp: timestamp
    };
    const args = new TalkService_getCompactContactsModifiedSince_args(params);
    try {
      output.writeMessageBegin('getCompactContactsModifiedSince', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getCompactContactsModifiedSince (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getCompactContactsModifiedSince_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getCompactContactsModifiedSince failed: unknown result');
  }

  releaseSession () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_releaseSession();
    });
  }

  send_releaseSession () {
    const output = new this.pClass(this.output);
    const args = new TalkService_releaseSession_args();
    try {
      output.writeMessageBegin('releaseSession', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_releaseSession (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_releaseSession_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  findContactsByPhone (phones) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findContactsByPhone(phones);
    });
  }

  send_findContactsByPhone (phones) {
    const output = new this.pClass(this.output);
    const params = {
      phones: phones
    };
    const args = new TalkService_findContactsByPhone_args(params);
    try {
      output.writeMessageBegin('findContactsByPhone', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findContactsByPhone (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findContactsByPhone_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findContactsByPhone failed: unknown result');
  }

  getHiddenContactMids () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getHiddenContactMids();
    });
  }

  send_getHiddenContactMids () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getHiddenContactMids_args();
    try {
      output.writeMessageBegin('getHiddenContactMids', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getHiddenContactMids (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getHiddenContactMids_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getHiddenContactMids failed: unknown result');
  }

  getEncryptedIdentity () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getEncryptedIdentity();
    });
  }

  send_getEncryptedIdentity () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getEncryptedIdentity_args();
    try {
      output.writeMessageBegin('getEncryptedIdentity', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getEncryptedIdentity (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getEncryptedIdentity_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getEncryptedIdentity failed: unknown result');
  }

  updateProfile (reqSeq, profile) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateProfile(reqSeq, profile);
    });
  }

  send_updateProfile (reqSeq, profile) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      profile: profile
    };
    const args = new TalkService_updateProfile_args(params);
    try {
      output.writeMessageBegin('updateProfile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateProfile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateProfile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  reportSpam (chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportSpam(chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages);
    });
  }

  send_reportSpam (chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages) {
    const output = new this.pClass(this.output);
    const params = {
      chatMid: chatMid,
      memberMids: memberMids,
      spammerReasons: spammerReasons,
      senderMids: senderMids,
      spamMessageIds: spamMessageIds,
      spamMessages: spamMessages
    };
    const args = new TalkService_reportSpam_args(params);
    try {
      output.writeMessageBegin('reportSpam', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportSpam (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportSpam_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getSuggestRevisions () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getSuggestRevisions();
    });
  }

  send_getSuggestRevisions () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getSuggestRevisions_args();
    try {
      output.writeMessageBegin('getSuggestRevisions', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getSuggestRevisions (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getSuggestRevisions_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getSuggestRevisions failed: unknown result');
  }

  getPreviousMessagesV2WithReadCount (messageBoxId, endMessageId, messagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getPreviousMessagesV2WithReadCount(messageBoxId, endMessageId, messagesCount);
    });
  }

  send_getPreviousMessagesV2WithReadCount (messageBoxId, endMessageId, messagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId,
      endMessageId: endMessageId,
      messagesCount: messagesCount
    };
    const args = new TalkService_getPreviousMessagesV2WithReadCount_args(params);
    try {
      output.writeMessageBegin('getPreviousMessagesV2WithReadCount', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getPreviousMessagesV2WithReadCount (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getPreviousMessagesV2WithReadCount_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getPreviousMessagesV2WithReadCount failed: unknown result');
  }

  fetchOperations (localRev, count) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_fetchOperations(localRev, count);
    });
  }

  send_fetchOperations (localRev, count) {
    const output = new this.pClass(this.output);
    const params = {
      localRev: localRev,
      count: count
    };
    const args = new TalkService_fetchOperations_args(params);
    try {
      output.writeMessageBegin('fetchOperations', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_fetchOperations (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_fetchOperations_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('fetchOperations failed: unknown result');
  }

  registerWapDevice (invitationHash, guidHash, email, deviceInfo) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerWapDevice(invitationHash, guidHash, email, deviceInfo);
    });
  }

  send_registerWapDevice (invitationHash, guidHash, email, deviceInfo) {
    const output = new this.pClass(this.output);
    const params = {
      invitationHash: invitationHash,
      guidHash: guidHash,
      email: email,
      deviceInfo: deviceInfo
    };
    const args = new TalkService_registerWapDevice_args(params);
    try {
      output.writeMessageBegin('registerWapDevice', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerWapDevice (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerWapDevice_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerWapDevice failed: unknown result');
  }

  getRecentFriendRequests () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRecentFriendRequests();
    });
  }

  send_getRecentFriendRequests () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getRecentFriendRequests_args();
    try {
      output.writeMessageBegin('getRecentFriendRequests', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRecentFriendRequests (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRecentFriendRequests_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRecentFriendRequests failed: unknown result');
  }

  notifyBuddyOnAir (seq, receiverMids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifyBuddyOnAir(seq, receiverMids);
    });
  }

  send_notifyBuddyOnAir (seq, receiverMids) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      receiverMids: receiverMids
    };
    const args = new TalkService_notifyBuddyOnAir_args(params);
    try {
      output.writeMessageBegin('notifyBuddyOnAir', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifyBuddyOnAir (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifyBuddyOnAir_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('notifyBuddyOnAir failed: unknown result');
  }

  getLastAnnouncementIndex () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getLastAnnouncementIndex();
    });
  }

  send_getLastAnnouncementIndex () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getLastAnnouncementIndex_args();
    try {
      output.writeMessageBegin('getLastAnnouncementIndex', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getLastAnnouncementIndex (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getLastAnnouncementIndex_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getLastAnnouncementIndex failed: unknown result');
  }

  sendMessageAwaitCommit (seq, message) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendMessageAwaitCommit(seq, message);
    });
  }

  send_sendMessageAwaitCommit (seq, message) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      message: message
    };
    const args = new TalkService_sendMessageAwaitCommit_args(params);
    try {
      output.writeMessageBegin('sendMessageAwaitCommit', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendMessageAwaitCommit (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendMessageAwaitCommit_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sendMessageAwaitCommit failed: unknown result');
  }

  negotiateE2EEPublicKey (mid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_negotiateE2EEPublicKey(mid);
    });
  }

  send_negotiateE2EEPublicKey (mid) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid
    };
    const args = new TalkService_negotiateE2EEPublicKey_args(params);
    try {
      output.writeMessageBegin('negotiateE2EEPublicKey', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_negotiateE2EEPublicKey (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_negotiateE2EEPublicKey_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('negotiateE2EEPublicKey failed: unknown result');
  }

  registerE2EEGroupKey (version, chatMid, members, keyIds, encryptedSharedKeys) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerE2EEGroupKey(version, chatMid, members, keyIds, encryptedSharedKeys);
    });
  }

  send_registerE2EEGroupKey (version, chatMid, members, keyIds, encryptedSharedKeys) {
    const output = new this.pClass(this.output);
    const params = {
      version: version,
      chatMid: chatMid,
      members: members,
      keyIds: keyIds,
      encryptedSharedKeys: encryptedSharedKeys
    };
    const args = new TalkService_registerE2EEGroupKey_args(params);
    try {
      output.writeMessageBegin('registerE2EEGroupKey', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerE2EEGroupKey (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerE2EEGroupKey_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerE2EEGroupKey failed: unknown result');
  }

  findSnsIdUserStatus (snsIdType, snsAccessToken, udidHash, migrationPincodeSessionId, oldUdidHash) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash, migrationPincodeSessionId, oldUdidHash);
    });
  }

  send_findSnsIdUserStatus (snsIdType, snsAccessToken, udidHash, migrationPincodeSessionId, oldUdidHash) {
    const output = new this.pClass(this.output);
    const params = {
      snsIdType: snsIdType,
      snsAccessToken: snsAccessToken,
      udidHash: udidHash,
      migrationPincodeSessionId: migrationPincodeSessionId,
      oldUdidHash: oldUdidHash
    };
    const args = new TalkService_findSnsIdUserStatus_args(params);
    try {
      output.writeMessageBegin('findSnsIdUserStatus', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findSnsIdUserStatus (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findSnsIdUserStatus_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findSnsIdUserStatus failed: unknown result');
  }

  notifyUpdated (lastRev, deviceInfo, udidHash, oldUdidHash) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifyUpdated(lastRev, deviceInfo, udidHash, oldUdidHash);
    });
  }

  send_notifyUpdated (lastRev, deviceInfo, udidHash, oldUdidHash) {
    const output = new this.pClass(this.output);
    const params = {
      lastRev: lastRev,
      deviceInfo: deviceInfo,
      udidHash: udidHash,
      oldUdidHash: oldUdidHash
    };
    const args = new TalkService_notifyUpdated_args(params);
    try {
      output.writeMessageBegin('notifyUpdated', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifyUpdated (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifyUpdated_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  reportGroups (syncOpRevision, groups) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportGroups(syncOpRevision, groups);
    });
  }

  send_reportGroups (syncOpRevision, groups) {
    const output = new this.pClass(this.output);
    const params = {
      syncOpRevision: syncOpRevision,
      groups: groups
    };
    const args = new TalkService_reportGroups_args(params);
    try {
      output.writeMessageBegin('reportGroups', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportGroups (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportGroups_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getNotificationPolicy (carrier) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getNotificationPolicy(carrier);
    });
  }

  send_getNotificationPolicy (carrier) {
    const output = new this.pClass(this.output);
    const params = {
      carrier: carrier
    };
    const args = new TalkService_getNotificationPolicy_args(params);
    try {
      output.writeMessageBegin('getNotificationPolicy', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getNotificationPolicy (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getNotificationPolicy_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getNotificationPolicy failed: unknown result');
  }

  findAndAddContactsByUserid (reqSeq, userid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findAndAddContactsByUserid(reqSeq, userid);
    });
  }

  send_findAndAddContactsByUserid (reqSeq, userid) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      userid: userid
    };
    const args = new TalkService_findAndAddContactsByUserid_args(params);
    try {
      output.writeMessageBegin('findAndAddContactsByUserid', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findAndAddContactsByUserid (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findAndAddContactsByUserid_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findAndAddContactsByUserid failed: unknown result');
  }

  getLastE2EEGroupSharedKey (version, chatMid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getLastE2EEGroupSharedKey(version, chatMid);
    });
  }

  send_getLastE2EEGroupSharedKey (version, chatMid) {
    const output = new this.pClass(this.output);
    const params = {
      version: version,
      chatMid: chatMid
    };
    const args = new TalkService_getLastE2EEGroupSharedKey_args(params);
    try {
      output.writeMessageBegin('getLastE2EEGroupSharedKey', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getLastE2EEGroupSharedKey (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getLastE2EEGroupSharedKey_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getLastE2EEGroupSharedKey failed: unknown result');
  }

  notifyUpdatePublicKeychain (mid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifyUpdatePublicKeychain(mid);
    });
  }

  send_notifyUpdatePublicKeychain (mid) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid
    };
    const args = new TalkService_notifyUpdatePublicKeychain_args(params);
    try {
      output.writeMessageBegin('notifyUpdatePublicKeychain', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifyUpdatePublicKeychain (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifyUpdatePublicKeychain_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  report (syncOpRevision, category, report) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_report(syncOpRevision, category, report);
    });
  }

  send_report (syncOpRevision, category, report) {
    const output = new this.pClass(this.output);
    const params = {
      syncOpRevision: syncOpRevision,
      category: category,
      report: report
    };
    const args = new TalkService_report_args(params);
    try {
      output.writeMessageBegin('report', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_report (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_report_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  acceptGroupInvitationByTicket (reqSeq, groupMid, ticketId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_acceptGroupInvitationByTicket(reqSeq, groupMid, ticketId);
    });
  }

  send_acceptGroupInvitationByTicket (reqSeq, groupMid, ticketId) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      groupMid: groupMid,
      ticketId: ticketId
    };
    const args = new TalkService_acceptGroupInvitationByTicket_args(params);
    try {
      output.writeMessageBegin('acceptGroupInvitationByTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_acceptGroupInvitationByTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_acceptGroupInvitationByTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getContactRegistration (id, type) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getContactRegistration(id, type);
    });
  }

  send_getContactRegistration (id, type) {
    const output = new this.pClass(this.output);
    const params = {
      id: id,
      type: type
    };
    const args = new TalkService_getContactRegistration_args(params);
    try {
      output.writeMessageBegin('getContactRegistration', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getContactRegistration (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getContactRegistration_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getContactRegistration failed: unknown result');
  }

  updateContactSetting (reqSeq, mid, flag, value) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateContactSetting(reqSeq, mid, flag, value);
    });
  }

  send_updateContactSetting (reqSeq, mid, flag, value) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      mid: mid,
      flag: flag,
      value: value
    };
    const args = new TalkService_updateContactSetting_args(params);
    try {
      output.writeMessageBegin('updateContactSetting', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateContactSetting (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateContactSetting_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getContactWithFriendRequestStatus (id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getContactWithFriendRequestStatus(id);
    });
  }

  send_getContactWithFriendRequestStatus (id) {
    const output = new this.pClass(this.output);
    const params = {
      id: id
    };
    const args = new TalkService_getContactWithFriendRequestStatus_args(params);
    try {
      output.writeMessageBegin('getContactWithFriendRequestStatus', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getContactWithFriendRequestStatus (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getContactWithFriendRequestStatus_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getContactWithFriendRequestStatus failed: unknown result');
  }

  getMessageBoxListByStatus (channelId, lastMessagesCount, status) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxListByStatus(channelId, lastMessagesCount, status);
    });
  }

  send_getMessageBoxListByStatus (channelId, lastMessagesCount, status) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      lastMessagesCount: lastMessagesCount,
      status: status
    };
    const args = new TalkService_getMessageBoxListByStatus_args(params);
    try {
      output.writeMessageBegin('getMessageBoxListByStatus', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxListByStatus (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxListByStatus_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxListByStatus failed: unknown result');
  }

  openProximityMatch (location) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_openProximityMatch(location);
    });
  }

  send_openProximityMatch (location) {
    const output = new this.pClass(this.output);
    const params = {
      location: location
    };
    const args = new TalkService_openProximityMatch_args(params);
    try {
      output.writeMessageBegin('openProximityMatch', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_openProximityMatch (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_openProximityMatch_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('openProximityMatch failed: unknown result');
  }

  logout () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_logout();
    });
  }

  send_logout () {
    const output = new this.pClass(this.output);
    const args = new TalkService_logout_args();
    try {
      output.writeMessageBegin('logout', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_logout (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_logout_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getE2EEPublicKey (mid, version, keyId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getE2EEPublicKey(mid, version, keyId);
    });
  }

  send_getE2EEPublicKey (mid, version, keyId) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid,
      version: version,
      keyId: keyId
    };
    const args = new TalkService_getE2EEPublicKey_args(params);
    try {
      output.writeMessageBegin('getE2EEPublicKey', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getE2EEPublicKey (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getE2EEPublicKey_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getE2EEPublicKey failed: unknown result');
  }

  registerUserid (reqSeq, userid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerUserid(reqSeq, userid);
    });
  }

  send_registerUserid (reqSeq, userid) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      userid: userid
    };
    const args = new TalkService_registerUserid_args(params);
    try {
      output.writeMessageBegin('registerUserid', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerUserid (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerUserid_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerUserid failed: unknown result');
  }

  reportContacts (syncOpRevision, category, contactReports, actionType) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportContacts(syncOpRevision, category, contactReports, actionType);
    });
  }

  send_reportContacts (syncOpRevision, category, contactReports, actionType) {
    const output = new this.pClass(this.output);
    const params = {
      syncOpRevision: syncOpRevision,
      category: category,
      contactReports: contactReports,
      actionType: actionType
    };
    const args = new TalkService_reportContacts_args(params);
    try {
      output.writeMessageBegin('reportContacts', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportContacts (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportContacts_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('reportContacts failed: unknown result');
  }

  getPublicKeychain (mid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getPublicKeychain(mid);
    });
  }

  send_getPublicKeychain (mid) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid
    };
    const args = new TalkService_getPublicKeychain_args(params);
    try {
      output.writeMessageBegin('getPublicKeychain', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getPublicKeychain (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getPublicKeychain_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getPublicKeychain failed: unknown result');
  }

  sendContentReceipt (seq, consumer, messageId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendContentReceipt(seq, consumer, messageId);
    });
  }

  send_sendContentReceipt (seq, consumer, messageId) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      consumer: consumer,
      messageId: messageId
    };
    const args = new TalkService_sendContentReceipt_args(params);
    try {
      output.writeMessageBegin('sendContentReceipt', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendContentReceipt (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendContentReceipt_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  respondResendMessage (reqSeq, receiverMid, originalMessageId, resendMessage, errorCode) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_respondResendMessage(reqSeq, receiverMid, originalMessageId, resendMessage, errorCode);
    });
  }

  send_respondResendMessage (reqSeq, receiverMid, originalMessageId, resendMessage, errorCode) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      receiverMid: receiverMid,
      originalMessageId: originalMessageId,
      resendMessage: resendMessage,
      errorCode: errorCode
    };
    const args = new TalkService_respondResendMessage_args(params);
    try {
      output.writeMessageBegin('respondResendMessage', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_respondResendMessage (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_respondResendMessage_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getAllRoomIds () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getAllRoomIds();
    });
  }

  send_getAllRoomIds () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getAllRoomIds_args();
    try {
      output.writeMessageBegin('getAllRoomIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getAllRoomIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getAllRoomIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getAllRoomIds failed: unknown result');
  }

  requestE2EEKeyExchange (reqSeq, temporalPublicKey, publicKey, verifier) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_requestE2EEKeyExchange(reqSeq, temporalPublicKey, publicKey, verifier);
    });
  }

  send_requestE2EEKeyExchange (reqSeq, temporalPublicKey, publicKey, verifier) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      temporalPublicKey: temporalPublicKey,
      publicKey: publicKey,
      verifier: verifier
    };
    const args = new TalkService_requestE2EEKeyExchange_args(params);
    try {
      output.writeMessageBegin('requestE2EEKeyExchange', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_requestE2EEKeyExchange (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_requestE2EEKeyExchange_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  disableNearby () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_disableNearby();
    });
  }

  send_disableNearby () {
    const output = new this.pClass(this.output);
    const args = new TalkService_disableNearby_args();
    try {
      output.writeMessageBegin('disableNearby', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_disableNearby (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_disableNearby_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  createQrcodeBase64Image (url, characterSet, imageSize, x, y, width, height) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height);
    });
  }

  send_createQrcodeBase64Image (url, characterSet, imageSize, x, y, width, height) {
    const output = new this.pClass(this.output);
    const params = {
      url: url,
      characterSet: characterSet,
      imageSize: imageSize,
      x: x,
      y: y,
      width: width,
      height: height
    };
    const args = new TalkService_createQrcodeBase64Image_args(params);
    try {
      output.writeMessageBegin('createQrcodeBase64Image', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_createQrcodeBase64Image (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_createQrcodeBase64Image_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('createQrcodeBase64Image failed: unknown result');
  }

  getMessageBoxList (channelId, lastMessagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxList(channelId, lastMessagesCount);
    });
  }

  send_getMessageBoxList (channelId, lastMessagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      lastMessagesCount: lastMessagesCount
    };
    const args = new TalkService_getMessageBoxList_args(params);
    try {
      output.writeMessageBegin('getMessageBoxList', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxList (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxList_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxList failed: unknown result');
  }

  respondE2EEKeyExchange (reqSeq, encryptedKeyChain, hashKeyChain) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_respondE2EEKeyExchange(reqSeq, encryptedKeyChain, hashKeyChain);
    });
  }

  send_respondE2EEKeyExchange (reqSeq, encryptedKeyChain, hashKeyChain) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      encryptedKeyChain: encryptedKeyChain,
      hashKeyChain: hashKeyChain
    };
    const args = new TalkService_respondE2EEKeyExchange_args(params);
    try {
      output.writeMessageBegin('respondE2EEKeyExchange', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_respondE2EEKeyExchange (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_respondE2EEKeyExchange_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  verifyQrcode (verifier, pinCode) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_verifyQrcode(verifier, pinCode);
    });
  }

  send_verifyQrcode (verifier, pinCode) {
    const output = new this.pClass(this.output);
    const params = {
      verifier: verifier,
      pinCode: pinCode
    };
    const args = new TalkService_verifyQrcode_args(params);
    try {
      output.writeMessageBegin('verifyQrcode', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_verifyQrcode (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_verifyQrcode_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('verifyQrcode failed: unknown result');
  }

  updateNotificationTokenWithBytes (token, type) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateNotificationTokenWithBytes(token, type);
    });
  }

  send_updateNotificationTokenWithBytes (token, type) {
    const output = new this.pClass(this.output);
    const params = {
      token: token,
      type: type
    };
    const args = new TalkService_updateNotificationTokenWithBytes_args(params);
    try {
      output.writeMessageBegin('updateNotificationTokenWithBytes', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateNotificationTokenWithBytes (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateNotificationTokenWithBytes_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getPreviousMessages (messageBoxId, endSeq, messagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getPreviousMessages(messageBoxId, endSeq, messagesCount);
    });
  }

  send_getPreviousMessages (messageBoxId, endSeq, messagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId,
      endSeq: endSeq,
      messagesCount: messagesCount
    };
    const args = new TalkService_getPreviousMessages_args(params);
    try {
      output.writeMessageBegin('getPreviousMessages', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getPreviousMessages (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getPreviousMessages_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getPreviousMessages failed: unknown result');
  }

  getSettings () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getSettings();
    });
  }

  send_getSettings () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getSettings_args();
    try {
      output.writeMessageBegin('getSettings', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getSettings (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getSettings_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getSettings failed: unknown result');
  }

  getLastE2EEPublicKeys (chatMid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getLastE2EEPublicKeys(chatMid);
    });
  }

  send_getLastE2EEPublicKeys (chatMid) {
    const output = new this.pClass(this.output);
    const params = {
      chatMid: chatMid
    };
    const args = new TalkService_getLastE2EEPublicKeys_args(params);
    try {
      output.writeMessageBegin('getLastE2EEPublicKeys', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getLastE2EEPublicKeys (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getLastE2EEPublicKeys_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getLastE2EEPublicKeys failed: unknown result');
  }

  registerE2EEPublicKey (reqSeq, publicKey) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerE2EEPublicKey(reqSeq, publicKey);
    });
  }

  send_registerE2EEPublicKey (reqSeq, publicKey) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      publicKey: publicKey
    };
    const args = new TalkService_registerE2EEPublicKey_args(params);
    try {
      output.writeMessageBegin('registerE2EEPublicKey', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerE2EEPublicKey (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerE2EEPublicKey_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerE2EEPublicKey failed: unknown result');
  }

  acquireCallTicket (to) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_acquireCallTicket(to);
    });
  }

  send_acquireCallTicket (to) {
    const output = new this.pClass(this.output);
    const params = {
      to: to
    };
    const args = new TalkService_acquireCallTicket_args(params);
    try {
      output.writeMessageBegin('acquireCallTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_acquireCallTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_acquireCallTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('acquireCallTicket failed: unknown result');
  }

  inviteIntoGroup (reqSeq, groupId, contactIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_inviteIntoGroup(reqSeq, groupId, contactIds);
    });
  }

  send_inviteIntoGroup (reqSeq, groupId, contactIds) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      groupId: groupId,
      contactIds: contactIds
    };
    const args = new TalkService_inviteIntoGroup_args(params);
    try {
      output.writeMessageBegin('inviteIntoGroup', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_inviteIntoGroup (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_inviteIntoGroup_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  makeUserAddMyselfAsContact (contactOwnerMid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_makeUserAddMyselfAsContact(contactOwnerMid);
    });
  }

  send_makeUserAddMyselfAsContact (contactOwnerMid) {
    const output = new this.pClass(this.output);
    const params = {
      contactOwnerMid: contactOwnerMid
    };
    const args = new TalkService_makeUserAddMyselfAsContact_args(params);
    try {
      output.writeMessageBegin('makeUserAddMyselfAsContact', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_makeUserAddMyselfAsContact (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_makeUserAddMyselfAsContact_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('makeUserAddMyselfAsContact failed: unknown result');
  }

  removeMessageFromMyHome (messageId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_removeMessageFromMyHome(messageId);
    });
  }

  send_removeMessageFromMyHome (messageId) {
    const output = new this.pClass(this.output);
    const params = {
      messageId: messageId
    };
    const args = new TalkService_removeMessageFromMyHome_args(params);
    try {
      output.writeMessageBegin('removeMessageFromMyHome', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_removeMessageFromMyHome (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_removeMessageFromMyHome_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('removeMessageFromMyHome failed: unknown result');
  }

  commitSendMessages (seq, messageIds, receiverMids, onlyToFollowers) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_commitSendMessages(seq, messageIds, receiverMids, onlyToFollowers);
    });
  }

  send_commitSendMessages (seq, messageIds, receiverMids, onlyToFollowers) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      messageIds: messageIds,
      receiverMids: receiverMids,
      onlyToFollowers: onlyToFollowers
    };
    const args = new TalkService_commitSendMessages_args(params);
    try {
      output.writeMessageBegin('commitSendMessages', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_commitSendMessages (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_commitSendMessages_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('commitSendMessages failed: unknown result');
  }

  registerWithPhoneNumberAndPassword (sessionId, keynm, encrypted) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerWithPhoneNumberAndPassword(sessionId, keynm, encrypted);
    });
  }

  send_registerWithPhoneNumberAndPassword (sessionId, keynm, encrypted) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId,
      keynm: keynm,
      encrypted: encrypted
    };
    const args = new TalkService_registerWithPhoneNumberAndPassword_args(params);
    try {
      output.writeMessageBegin('registerWithPhoneNumberAndPassword', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerWithPhoneNumberAndPassword (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerWithPhoneNumberAndPassword_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerWithPhoneNumberAndPassword failed: unknown result');
  }

  leaveGroup (reqSeq, groupId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_leaveGroup(reqSeq, groupId);
    });
  }

  send_leaveGroup (reqSeq, groupId) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      groupId: groupId
    };
    const args = new TalkService_leaveGroup_args(params);
    try {
      output.writeMessageBegin('leaveGroup', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_leaveGroup (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_leaveGroup_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getAnalyticsInfo () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getAnalyticsInfo();
    });
  }

  send_getAnalyticsInfo () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getAnalyticsInfo_args();
    try {
      output.writeMessageBegin('getAnalyticsInfo', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getAnalyticsInfo (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getAnalyticsInfo_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getAnalyticsInfo failed: unknown result');
  }

  reportClientStatistics (reqSeq, category, count) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportClientStatistics(reqSeq, category, count);
    });
  }

  send_reportClientStatistics (reqSeq, category, count) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      category: category,
      count: count
    };
    const args = new TalkService_reportClientStatistics_args(params);
    try {
      output.writeMessageBegin('reportClientStatistics', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportClientStatistics (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportClientStatistics_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  acceptProximityMatches (sessionId, ids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_acceptProximityMatches(sessionId, ids);
    });
  }

  send_acceptProximityMatches (sessionId, ids) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId,
      ids: ids
    };
    const args = new TalkService_acceptProximityMatches_args(params);
    try {
      output.writeMessageBegin('acceptProximityMatches', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_acceptProximityMatches (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_acceptProximityMatches_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getGroup (groupId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getGroup(groupId);
    });
  }

  send_getGroup (groupId) {
    const output = new this.pClass(this.output);
    const params = {
      groupId: groupId
    };
    const args = new TalkService_getGroup_args(params);
    try {
      output.writeMessageBegin('getGroup', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getGroup (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getGroup_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getGroup failed: unknown result');
  }

  clearIdentityCredential () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clearIdentityCredential();
    });
  }

  send_clearIdentityCredential () {
    const output = new this.pClass(this.output);
    const args = new TalkService_clearIdentityCredential_args();
    try {
      output.writeMessageBegin('clearIdentityCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clearIdentityCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_clearIdentityCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getUpdatedMessageBoxIds (startMessageId, startMessageBoxId, messageBoxCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getUpdatedMessageBoxIds(startMessageId, startMessageBoxId, messageBoxCount);
    });
  }

  send_getUpdatedMessageBoxIds (startMessageId, startMessageBoxId, messageBoxCount) {
    const output = new this.pClass(this.output);
    const params = {
      startMessageId: startMessageId,
      startMessageBoxId: startMessageBoxId,
      messageBoxCount: messageBoxCount
    };
    const args = new TalkService_getUpdatedMessageBoxIds_args(params);
    try {
      output.writeMessageBegin('getUpdatedMessageBoxIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getUpdatedMessageBoxIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getUpdatedMessageBoxIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getUpdatedMessageBoxIds failed: unknown result');
  }

  getGroups (groupIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getGroups(groupIds);
    });
  }

  send_getGroups (groupIds) {
    const output = new this.pClass(this.output);
    const params = {
      groupIds: groupIds
    };
    const args = new TalkService_getGroups_args(params);
    try {
      output.writeMessageBegin('getGroups', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getGroups (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getGroups_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getGroups failed: unknown result');
  }

  sendMessageReceipt (seq, consumer, messageIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendMessageReceipt(seq, consumer, messageIds);
    });
  }

  send_sendMessageReceipt (seq, consumer, messageIds) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      consumer: consumer,
      messageIds: messageIds
    };
    const args = new TalkService_sendMessageReceipt_args(params);
    try {
      output.writeMessageBegin('sendMessageReceipt', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendMessageReceipt (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendMessageReceipt_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  findContactByMetaTag (userid, reference) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findContactByMetaTag(userid, reference);
    });
  }

  send_findContactByMetaTag (userid, reference) {
    const output = new this.pClass(this.output);
    const params = {
      userid: userid,
      reference: reference
    };
    const args = new TalkService_findContactByMetaTag_args(params);
    try {
      output.writeMessageBegin('findContactByMetaTag', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findContactByMetaTag (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findContactByMetaTag_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findContactByMetaTag failed: unknown result');
  }

  destroyMessage (seq, chatId, messageId, sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_destroyMessage(seq, chatId, messageId, sessionId);
    });
  }

  send_destroyMessage (seq, chatId, messageId, sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      chatId: chatId,
      messageId: messageId,
      sessionId: sessionId
    };
    const args = new TalkService_destroyMessage_args(params);
    try {
      output.writeMessageBegin('destroyMessage', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_destroyMessage (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_destroyMessage_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  generateUserTicket (expirationTime, maxUseCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_generateUserTicket(expirationTime, maxUseCount);
    });
  }

  send_generateUserTicket (expirationTime, maxUseCount) {
    const output = new this.pClass(this.output);
    const params = {
      expirationTime: expirationTime,
      maxUseCount: maxUseCount
    };
    const args = new TalkService_generateUserTicket_args(params);
    try {
      output.writeMessageBegin('generateUserTicket', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_generateUserTicket (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_generateUserTicket_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('generateUserTicket failed: unknown result');
  }

  registerDeviceWithoutPhoneNumberWithIdentityCredential (region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId);
    });
  }

  send_registerDeviceWithoutPhoneNumberWithIdentityCredential (region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId) {
    const output = new this.pClass(this.output);
    const params = {
      region: region,
      udidHash: udidHash,
      deviceInfo: deviceInfo,
      provider: provider,
      identifier: identifier,
      verifier: verifier,
      mid: mid,
      migrationPincodeSessionId: migrationPincodeSessionId
    };
    const args = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args(params);
    try {
      output.writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_registerDeviceWithoutPhoneNumberWithIdentityCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('registerDeviceWithoutPhoneNumberWithIdentityCredential failed: unknown result');
  }

  getFavoriteMids () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getFavoriteMids();
    });
  }

  send_getFavoriteMids () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getFavoriteMids_args();
    try {
      output.writeMessageBegin('getFavoriteMids', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getFavoriteMids (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getFavoriteMids_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getFavoriteMids failed: unknown result');
  }

  getAcceptedProximityMatches (sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getAcceptedProximityMatches(sessionId);
    });
  }

  send_getAcceptedProximityMatches (sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId
    };
    const args = new TalkService_getAcceptedProximityMatches_args(params);
    try {
      output.writeMessageBegin('getAcceptedProximityMatches', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getAcceptedProximityMatches (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getAcceptedProximityMatches_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getAcceptedProximityMatches failed: unknown result');
  }

  notifyInstalled (udidHash, applicationTypeWithExtensions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifyInstalled(udidHash, applicationTypeWithExtensions);
    });
  }

  send_notifyInstalled (udidHash, applicationTypeWithExtensions) {
    const output = new this.pClass(this.output);
    const params = {
      udidHash: udidHash,
      applicationTypeWithExtensions: applicationTypeWithExtensions
    };
    const args = new TalkService_notifyInstalled_args(params);
    try {
      output.writeMessageBegin('notifyInstalled', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifyInstalled (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifyInstalled_result();
    result.read(input);
    input.readMessageEnd();

    callback(null);
  }

  getCountryWithRequestIp () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getCountryWithRequestIp();
    });
  }

  send_getCountryWithRequestIp () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getCountryWithRequestIp_args();
    try {
      output.writeMessageBegin('getCountryWithRequestIp', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getCountryWithRequestIp (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getCountryWithRequestIp_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getCountryWithRequestIp failed: unknown result');
  }

  getGroupsV2 (groupIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getGroupsV2(groupIds);
    });
  }

  send_getGroupsV2 (groupIds) {
    const output = new this.pClass(this.output);
    const params = {
      groupIds: groupIds
    };
    const args = new TalkService_getGroupsV2_args(params);
    try {
      output.writeMessageBegin('getGroupsV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getGroupsV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getGroupsV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getGroupsV2 failed: unknown result');
  }

  loginWithIdentityCredential (identifier, password, keepLoggedIn, accessLocation, systemName, identityProvider, certificate) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_loginWithIdentityCredential(identifier, password, keepLoggedIn, accessLocation, systemName, identityProvider, certificate);
    });
  }

  send_loginWithIdentityCredential (identifier, password, keepLoggedIn, accessLocation, systemName, identityProvider, certificate) {
    const output = new this.pClass(this.output);
    const params = {
      identifier: identifier,
      password: password,
      keepLoggedIn: keepLoggedIn,
      accessLocation: accessLocation,
      systemName: systemName,
      identityProvider: identityProvider,
      certificate: certificate
    };
    const args = new TalkService_loginWithIdentityCredential_args(params);
    try {
      output.writeMessageBegin('loginWithIdentityCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_loginWithIdentityCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_loginWithIdentityCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('loginWithIdentityCredential failed: unknown result');
  }

  startUpdateVerification (region, carrier, phone, udidHash, deviceInfo, networkCode, locale, simInfo) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale, simInfo);
    });
  }

  send_startUpdateVerification (region, carrier, phone, udidHash, deviceInfo, networkCode, locale, simInfo) {
    const output = new this.pClass(this.output);
    const params = {
      region: region,
      carrier: carrier,
      phone: phone,
      udidHash: udidHash,
      deviceInfo: deviceInfo,
      networkCode: networkCode,
      locale: locale,
      simInfo: simInfo
    };
    const args = new TalkService_startUpdateVerification_args(params);
    try {
      output.writeMessageBegin('startUpdateVerification', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_startUpdateVerification (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_startUpdateVerification_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('startUpdateVerification failed: unknown result');
  }

  getSessions () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getSessions();
    });
  }

  send_getSessions () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getSessions_args();
    try {
      output.writeMessageBegin('getSessions', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getSessions (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getSessions_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getSessions failed: unknown result');
  }

  updateSettings (reqSeq, settings) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateSettings(reqSeq, settings);
    });
  }

  send_updateSettings (reqSeq, settings) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      settings: settings
    };
    const args = new TalkService_updateSettings_args(params);
    try {
      output.writeMessageBegin('updateSettings', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateSettings (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateSettings_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getContact (id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getContact(id);
    });
  }

  send_getContact (id) {
    const output = new this.pClass(this.output);
    const params = {
      id: id
    };
    const args = new TalkService_getContact_args(params);
    try {
      output.writeMessageBegin('getContact', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getContact (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getContact_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getContact failed: unknown result');
  }

  getBlockedContactIds () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getBlockedContactIds();
    });
  }

  send_getBlockedContactIds () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getBlockedContactIds_args();
    try {
      output.writeMessageBegin('getBlockedContactIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getBlockedContactIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getBlockedContactIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getBlockedContactIds failed: unknown result');
  }

  loginWithVerifierForCertificate (verifier) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_loginWithVerifierForCertificate(verifier);
    });
  }

  send_loginWithVerifierForCertificate (verifier) {
    const output = new this.pClass(this.output);
    const params = {
      verifier: verifier
    };
    const args = new TalkService_loginWithVerifierForCertificate_args(params);
    try {
      output.writeMessageBegin('loginWithVerifierForCertificate', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_loginWithVerifierForCertificate (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_loginWithVerifierForCertificate_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('loginWithVerifierForCertificate failed: unknown result');
  }

  getProfile () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getProfile();
    });
  }

  send_getProfile () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getProfile_args();
    try {
      output.writeMessageBegin('getProfile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getProfile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getProfile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getProfile failed: unknown result');
  }

  findContactsByEmail (emails) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findContactsByEmail(emails);
    });
  }

  send_findContactsByEmail (emails) {
    const output = new this.pClass(this.output);
    const params = {
      emails: emails
    };
    const args = new TalkService_findContactsByEmail_args(params);
    try {
      output.writeMessageBegin('findContactsByEmail', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findContactsByEmail (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findContactsByEmail_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findContactsByEmail failed: unknown result');
  }

  getSystemConfiguration () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getSystemConfiguration();
    });
  }

  send_getSystemConfiguration () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getSystemConfiguration_args();
    try {
      output.writeMessageBegin('getSystemConfiguration', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getSystemConfiguration (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getSystemConfiguration_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getSystemConfiguration failed: unknown result');
  }

  getRecentMessages (messageBoxId, messagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getRecentMessages(messageBoxId, messagesCount);
    });
  }

  send_getRecentMessages (messageBoxId, messagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId,
      messagesCount: messagesCount
    };
    const args = new TalkService_getRecentMessages_args(params);
    try {
      output.writeMessageBegin('getRecentMessages', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getRecentMessages (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getRecentMessages_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getRecentMessages failed: unknown result');
  }

  verifyPhone (sessionId, pinCode, udidHash) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_verifyPhone(sessionId, pinCode, udidHash);
    });
  }

  send_verifyPhone (sessionId, pinCode, udidHash) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId,
      pinCode: pinCode,
      udidHash: udidHash
    };
    const args = new TalkService_verifyPhone_args(params);
    try {
      output.writeMessageBegin('verifyPhone', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_verifyPhone (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_verifyPhone_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('verifyPhone failed: unknown result');
  }

  createGroup (seq, name, contactIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_createGroup(seq, name, contactIds);
    });
  }

  send_createGroup (seq, name, contactIds) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      name: name,
      contactIds: contactIds
    };
    const args = new TalkService_createGroup_args(params);
    try {
      output.writeMessageBegin('createGroup', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_createGroup (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_createGroup_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('createGroup failed: unknown result');
  }

  updateBuddySetting (key, value) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateBuddySetting(key, value);
    });
  }

  send_updateBuddySetting (key, value) {
    const output = new this.pClass(this.output);
    const params = {
      key: key,
      value: value
    };
    const args = new TalkService_updateBuddySetting_args(params);
    try {
      output.writeMessageBegin('updateBuddySetting', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateBuddySetting (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateBuddySetting_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  updateRegion (region) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateRegion(region);
    });
  }

  send_updateRegion (region) {
    const output = new this.pClass(this.output);
    const params = {
      region: region
    };
    const args = new TalkService_updateRegion_args(params);
    try {
      output.writeMessageBegin('updateRegion', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateRegion (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateRegion_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  verifyIdentityCredential (identifier, password, identityProvider) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_verifyIdentityCredential(identifier, password, identityProvider);
    });
  }

  send_verifyIdentityCredential (identifier, password, identityProvider) {
    const output = new this.pClass(this.output);
    const params = {
      identifier: identifier,
      password: password,
      identityProvider: identityProvider
    };
    const args = new TalkService_verifyIdentityCredential_args(params);
    try {
      output.writeMessageBegin('verifyIdentityCredential', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_verifyIdentityCredential (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_verifyIdentityCredential_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  sendChatRemoved (seq, consumer, lastMessageId, sessionId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendChatRemoved(seq, consumer, lastMessageId, sessionId);
    });
  }

  send_sendChatRemoved (seq, consumer, lastMessageId, sessionId) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      consumer: consumer,
      lastMessageId: lastMessageId,
      sessionId: sessionId
    };
    const args = new TalkService_sendChatRemoved_args(params);
    try {
      output.writeMessageBegin('sendChatRemoved', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendChatRemoved (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendChatRemoved_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getGroupIdsJoined () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getGroupIdsJoined();
    });
  }

  send_getGroupIdsJoined () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getGroupIdsJoined_args();
    try {
      output.writeMessageBegin('getGroupIdsJoined', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getGroupIdsJoined (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getGroupIdsJoined_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getGroupIdsJoined failed: unknown result');
  }

  findContactByUserid (userid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findContactByUserid(userid);
    });
  }

  send_findContactByUserid (userid) {
    const output = new this.pClass(this.output);
    const params = {
      userid: userid
    };
    const args = new TalkService_findContactByUserid_args(params);
    try {
      output.writeMessageBegin('findContactByUserid', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findContactByUserid (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findContactByUserid_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findContactByUserid failed: unknown result');
  }

  getE2EEPublicKeys () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getE2EEPublicKeys();
    });
  }

  send_getE2EEPublicKeys () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getE2EEPublicKeys_args();
    try {
      output.writeMessageBegin('getE2EEPublicKeys', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getE2EEPublicKeys (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getE2EEPublicKeys_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getE2EEPublicKeys failed: unknown result');
  }

  getMessageBoxWrapUpList (start, messageBoxCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxWrapUpList(start, messageBoxCount);
    });
  }

  send_getMessageBoxWrapUpList (start, messageBoxCount) {
    const output = new this.pClass(this.output);
    const params = {
      start: start,
      messageBoxCount: messageBoxCount
    };
    const args = new TalkService_getMessageBoxWrapUpList_args(params);
    try {
      output.writeMessageBegin('getMessageBoxWrapUpList', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxWrapUpList (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxWrapUpList_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxWrapUpList failed: unknown result');
  }

  leaveRoom (reqSeq, roomId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_leaveRoom(reqSeq, roomId);
    });
  }

  send_leaveRoom (reqSeq, roomId) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      roomId: roomId
    };
    const args = new TalkService_leaveRoom_args(params);
    try {
      output.writeMessageBegin('leaveRoom', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_leaveRoom (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_leaveRoom_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  unblockRecommendation (reqSeq, id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_unblockRecommendation(reqSeq, id);
    });
  }

  send_unblockRecommendation (reqSeq, id) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      id: id
    };
    const args = new TalkService_unblockRecommendation_args(params);
    try {
      output.writeMessageBegin('unblockRecommendation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_unblockRecommendation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_unblockRecommendation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  findAndAddContactsByPhone (reqSeq, phones) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findAndAddContactsByPhone(reqSeq, phones);
    });
  }

  send_findAndAddContactsByPhone (reqSeq, phones) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      phones: phones
    };
    const args = new TalkService_findAndAddContactsByPhone_args(params);
    try {
      output.writeMessageBegin('findAndAddContactsByPhone', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findAndAddContactsByPhone (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findAndAddContactsByPhone_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findAndAddContactsByPhone failed: unknown result');
  }

  getAuthQrcode (keepLoggedIn, systemName, returnCallbackUrl) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getAuthQrcode(keepLoggedIn, systemName, returnCallbackUrl);
    });
  }

  send_getAuthQrcode (keepLoggedIn, systemName, returnCallbackUrl) {
    const output = new this.pClass(this.output);
    const params = {
      keepLoggedIn: keepLoggedIn,
      systemName: systemName,
      returnCallbackUrl: returnCallbackUrl
    };
    const args = new TalkService_getAuthQrcode_args(params);
    try {
      output.writeMessageBegin('getAuthQrcode', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getAuthQrcode (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getAuthQrcode_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getAuthQrcode failed: unknown result');
  }

  getE2EEGroupSharedKey (version, chatMid, groupKeyId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getE2EEGroupSharedKey(version, chatMid, groupKeyId);
    });
  }

  send_getE2EEGroupSharedKey (version, chatMid, groupKeyId) {
    const output = new this.pClass(this.output);
    const params = {
      version: version,
      chatMid: chatMid,
      groupKeyId: groupKeyId
    };
    const args = new TalkService_getE2EEGroupSharedKey_args(params);
    try {
      output.writeMessageBegin('getE2EEGroupSharedKey', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getE2EEGroupSharedKey (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getE2EEGroupSharedKey_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getE2EEGroupSharedKey failed: unknown result');
  }

  getMessageBoxWrapUp (mid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxWrapUp(mid);
    });
  }

  send_getMessageBoxWrapUp (mid) {
    const output = new this.pClass(this.output);
    const params = {
      mid: mid
    };
    const args = new TalkService_getMessageBoxWrapUp_args(params);
    try {
      output.writeMessageBegin('getMessageBoxWrapUp', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxWrapUp (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxWrapUp_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxWrapUp failed: unknown result');
  }

  updateSettingsAttributes (reqSeq, attrBitset, settings) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateSettingsAttributes(reqSeq, attrBitset, settings);
    });
  }

  send_updateSettingsAttributes (reqSeq, attrBitset, settings) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      attrBitset: attrBitset,
      settings: settings
    };
    const args = new TalkService_updateSettingsAttributes_args(params);
    try {
      output.writeMessageBegin('updateSettingsAttributes', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateSettingsAttributes (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateSettingsAttributes_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('updateSettingsAttributes failed: unknown result');
  }

  startVerification (region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash);
    });
  }

  send_startVerification (region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash) {
    const output = new this.pClass(this.output);
    const params = {
      region: region,
      carrier: carrier,
      phone: phone,
      udidHash: udidHash,
      deviceInfo: deviceInfo,
      networkCode: networkCode,
      mid: mid,
      locale: locale,
      simInfo: simInfo,
      oldUdidHash: oldUdidHash
    };
    const args = new TalkService_startVerification_args(params);
    try {
      output.writeMessageBegin('startVerification', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_startVerification (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_startVerification_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('startVerification failed: unknown result');
  }

  reportRooms (syncOpRevision, rooms) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_reportRooms(syncOpRevision, rooms);
    });
  }

  send_reportRooms (syncOpRevision, rooms) {
    const output = new this.pClass(this.output);
    const params = {
      syncOpRevision: syncOpRevision,
      rooms: rooms
    };
    const args = new TalkService_reportRooms_args(params);
    try {
      output.writeMessageBegin('reportRooms', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_reportRooms (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_reportRooms_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  updateGroupPreferenceAttribute (reqSeq, groupMid, updatedAttrs) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateGroupPreferenceAttribute(reqSeq, groupMid, updatedAttrs);
    });
  }

  send_updateGroupPreferenceAttribute (reqSeq, groupMid, updatedAttrs) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      groupMid: groupMid,
      updatedAttrs: updatedAttrs
    };
    const args = new TalkService_updateGroupPreferenceAttribute_args(params);
    try {
      output.writeMessageBegin('updateGroupPreferenceAttribute', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateGroupPreferenceAttribute (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateGroupPreferenceAttribute_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getMessageBoxWrapUpV2 (messageBoxId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBoxWrapUpV2(messageBoxId);
    });
  }

  send_getMessageBoxWrapUpV2 (messageBoxId) {
    const output = new this.pClass(this.output);
    const params = {
      messageBoxId: messageBoxId
    };
    const args = new TalkService_getMessageBoxWrapUpV2_args(params);
    try {
      output.writeMessageBegin('getMessageBoxWrapUpV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBoxWrapUpV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBoxWrapUpV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBoxWrapUpV2 failed: unknown result');
  }

  getCompactRooms (roomIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getCompactRooms(roomIds);
    });
  }

  send_getCompactRooms (roomIds) {
    const output = new this.pClass(this.output);
    const params = {
      roomIds: roomIds
    };
    const args = new TalkService_getCompactRooms_args(params);
    try {
      output.writeMessageBegin('getCompactRooms', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getCompactRooms (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getCompactRooms_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getCompactRooms failed: unknown result');
  }

  findAndAddContactByMetaTag (reqSeq, userid, reference) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findAndAddContactByMetaTag(reqSeq, userid, reference);
    });
  }

  send_findAndAddContactByMetaTag (reqSeq, userid, reference) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      userid: userid,
      reference: reference
    };
    const args = new TalkService_findAndAddContactByMetaTag_args(params);
    try {
      output.writeMessageBegin('findAndAddContactByMetaTag', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findAndAddContactByMetaTag (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findAndAddContactByMetaTag_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findAndAddContactByMetaTag failed: unknown result');
  }

  storeUpdateProfileAttribute (seq, profileAttribute, value) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_storeUpdateProfileAttribute(seq, profileAttribute, value);
    });
  }

  send_storeUpdateProfileAttribute (seq, profileAttribute, value) {
    const output = new this.pClass(this.output);
    const params = {
      seq: seq,
      profileAttribute: profileAttribute,
      value: value
    };
    const args = new TalkService_storeUpdateProfileAttribute_args(params);
    try {
      output.writeMessageBegin('storeUpdateProfileAttribute', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_storeUpdateProfileAttribute (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_storeUpdateProfileAttribute_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  resendEmailConfirmation (verifier) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_resendEmailConfirmation(verifier);
    });
  }

  send_resendEmailConfirmation (verifier) {
    const output = new this.pClass(this.output);
    const params = {
      verifier: verifier
    };
    const args = new TalkService_resendEmailConfirmation_args(params);
    try {
      output.writeMessageBegin('resendEmailConfirmation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_resendEmailConfirmation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_resendEmailConfirmation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('resendEmailConfirmation failed: unknown result');
  }

  confirmEmail (verifier, pinCode) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_confirmEmail(verifier, pinCode);
    });
  }

  send_confirmEmail (verifier, pinCode) {
    const output = new this.pClass(this.output);
    const params = {
      verifier: verifier,
      pinCode: pinCode
    };
    const args = new TalkService_confirmEmail_args(params);
    try {
      output.writeMessageBegin('confirmEmail', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_confirmEmail (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_confirmEmail_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('confirmEmail failed: unknown result');
  }

  getExtendedProfile () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getExtendedProfile();
    });
  }

  send_getExtendedProfile () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getExtendedProfile_args();
    try {
      output.writeMessageBegin('getExtendedProfile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getExtendedProfile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getExtendedProfile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getExtendedProfile failed: unknown result');
  }

  isUseridAvailable (userid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_isUseridAvailable(userid);
    });
  }

  send_isUseridAvailable (userid) {
    const output = new this.pClass(this.output);
    const params = {
      userid: userid
    };
    const args = new TalkService_isUseridAvailable_args(params);
    try {
      output.writeMessageBegin('isUseridAvailable', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_isUseridAvailable (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_isUseridAvailable_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('isUseridAvailable failed: unknown result');
  }

  notifyRegistrationComplete (udidHash, applicationTypeWithExtensions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions);
    });
  }

  send_notifyRegistrationComplete (udidHash, applicationTypeWithExtensions) {
    const output = new this.pClass(this.output);
    const params = {
      udidHash: udidHash,
      applicationTypeWithExtensions: applicationTypeWithExtensions
    };
    const args = new TalkService_notifyRegistrationComplete_args(params);
    try {
      output.writeMessageBegin('notifyRegistrationComplete', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_notifyRegistrationComplete (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_notifyRegistrationComplete_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  updateDeviceInfo (deviceUid, deviceInfo) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateDeviceInfo(deviceUid, deviceInfo);
    });
  }

  send_updateDeviceInfo (deviceUid, deviceInfo) {
    const output = new this.pClass(this.output);
    const params = {
      deviceUid: deviceUid,
      deviceInfo: deviceInfo
    };
    const args = new TalkService_updateDeviceInfo_args(params);
    try {
      output.writeMessageBegin('updateDeviceInfo', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateDeviceInfo (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateDeviceInfo_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  blockRecommendation (reqSeq, id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_blockRecommendation(reqSeq, id);
    });
  }

  send_blockRecommendation (reqSeq, id) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      id: id
    };
    const args = new TalkService_blockRecommendation_args(params);
    try {
      output.writeMessageBegin('blockRecommendation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_blockRecommendation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_blockRecommendation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  rejectGroupInvitation (reqSeq, groupId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_rejectGroupInvitation(reqSeq, groupId);
    });
  }

  send_rejectGroupInvitation (reqSeq, groupId) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      groupId: groupId
    };
    const args = new TalkService_rejectGroupInvitation_args(params);
    try {
      output.writeMessageBegin('rejectGroupInvitation', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_rejectGroupInvitation (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_rejectGroupInvitation_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  updateCustomModeSettings (customMode, paramMap) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_updateCustomModeSettings(customMode, paramMap);
    });
  }

  send_updateCustomModeSettings (customMode, paramMap) {
    const output = new this.pClass(this.output);
    const params = {
      customMode: customMode,
      paramMap: paramMap
    };
    const args = new TalkService_updateCustomModeSettings_args(params);
    try {
      output.writeMessageBegin('updateCustomModeSettings', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_updateCustomModeSettings (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_updateCustomModeSettings_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  createRoomV2 (reqSeq, contactIds) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_createRoomV2(reqSeq, contactIds);
    });
  }

  send_createRoomV2 (reqSeq, contactIds) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      contactIds: contactIds
    };
    const args = new TalkService_createRoomV2_args(params);
    try {
      output.writeMessageBegin('createRoomV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_createRoomV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_createRoomV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('createRoomV2 failed: unknown result');
  }

  noop () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_noop();
    });
  }

  send_noop () {
    const output = new this.pClass(this.output);
    const args = new TalkService_noop_args();
    try {
      output.writeMessageBegin('noop', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_noop (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_noop_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  acquireEncryptedAccessToken (featureType) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_acquireEncryptedAccessToken(featureType);
    });
  }

  send_acquireEncryptedAccessToken (featureType) {
    const output = new this.pClass(this.output);
    const params = {
      featureType: featureType
    };
    const args = new TalkService_acquireEncryptedAccessToken_args(params);
    try {
      output.writeMessageBegin('acquireEncryptedAccessToken', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_acquireEncryptedAccessToken (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_acquireEncryptedAccessToken_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('acquireEncryptedAccessToken failed: unknown result');
  }

  getE2EEPublicKeysEx (ignoreE2EEStatus) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getE2EEPublicKeysEx(ignoreE2EEStatus);
    });
  }

  send_getE2EEPublicKeysEx (ignoreE2EEStatus) {
    const output = new this.pClass(this.output);
    const params = {
      ignoreE2EEStatus: ignoreE2EEStatus
    };
    const args = new TalkService_getE2EEPublicKeysEx_args(params);
    try {
      output.writeMessageBegin('getE2EEPublicKeysEx', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getE2EEPublicKeysEx (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getE2EEPublicKeysEx_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getE2EEPublicKeysEx failed: unknown result');
  }

  syncContacts (reqSeq, localContacts) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_syncContacts(reqSeq, localContacts);
    });
  }

  send_syncContacts (reqSeq, localContacts) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      localContacts: localContacts
    };
    const args = new TalkService_syncContacts_args(params);
    try {
      output.writeMessageBegin('syncContacts', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_syncContacts (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_syncContacts_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('syncContacts failed: unknown result');
  }

  findAndAddContactsByMid (reqSeq, mid, type, reference) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findAndAddContactsByMid(reqSeq, mid, type, reference);
    });
  }

  send_findAndAddContactsByMid (reqSeq, mid, type, reference) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      mid: mid,
      type: type,
      reference: reference
    };
    const args = new TalkService_findAndAddContactsByMid_args(params);
    try {
      output.writeMessageBegin('findAndAddContactsByMid', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findAndAddContactsByMid (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findAndAddContactsByMid_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findAndAddContactsByMid failed: unknown result');
  }

  findGroupByTicketV2 (ticketId) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_findGroupByTicketV2(ticketId);
    });
  }

  send_findGroupByTicketV2 (ticketId) {
    const output = new this.pClass(this.output);
    const params = {
      ticketId: ticketId
    };
    const args = new TalkService_findGroupByTicketV2_args(params);
    try {
      output.writeMessageBegin('findGroupByTicketV2', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_findGroupByTicketV2 (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_findGroupByTicketV2_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('findGroupByTicketV2 failed: unknown result');
  }

  removeFriendRequest (direction, midOrEMid) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_removeFriendRequest(direction, midOrEMid);
    });
  }

  send_removeFriendRequest (direction, midOrEMid) {
    const output = new this.pClass(this.output);
    const params = {
      direction: direction,
      midOrEMid: midOrEMid
    };
    const args = new TalkService_removeFriendRequest_args(params);
    try {
      output.writeMessageBegin('removeFriendRequest', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_removeFriendRequest (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_removeFriendRequest_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  verifyPhoneNumber (sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_verifyPhoneNumber(sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash);
    });
  }

  send_verifyPhoneNumber (sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash) {
    const output = new this.pClass(this.output);
    const params = {
      sessionId: sessionId,
      pinCode: pinCode,
      udidHash: udidHash,
      migrationPincodeSessionId: migrationPincodeSessionId,
      oldUdidHash: oldUdidHash
    };
    const args = new TalkService_verifyPhoneNumber_args(params);
    try {
      output.writeMessageBegin('verifyPhoneNumber', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_verifyPhoneNumber (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_verifyPhoneNumber_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('verifyPhoneNumber failed: unknown result');
  }

  setNotificationsEnabled (reqSeq, type, target, enablement) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_setNotificationsEnabled(reqSeq, type, target, enablement);
    });
  }

  send_setNotificationsEnabled (reqSeq, type, target, enablement) {
    const output = new this.pClass(this.output);
    const params = {
      reqSeq: reqSeq,
      type: type,
      target: target,
      enablement: enablement
    };
    const args = new TalkService_setNotificationsEnabled_args(params);
    try {
      output.writeMessageBegin('setNotificationsEnabled', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_setNotificationsEnabled (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_setNotificationsEnabled_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getAllContactIds () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getAllContactIds();
    });
  }

  send_getAllContactIds () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getAllContactIds_args();
    try {
      output.writeMessageBegin('getAllContactIds', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getAllContactIds (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getAllContactIds_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getAllContactIds failed: unknown result');
  }

  getIdentityIdentifier () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getIdentityIdentifier();
    });
  }

  send_getIdentityIdentifier () {
    const output = new this.pClass(this.output);
    const args = new TalkService_getIdentityIdentifier_args();
    try {
      output.writeMessageBegin('getIdentityIdentifier', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getIdentityIdentifier (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getIdentityIdentifier_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getIdentityIdentifier failed: unknown result');
  }

  sendDummyPush () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sendDummyPush();
    });
  }

  send_sendDummyPush () {
    const output = new this.pClass(this.output);
    const args = new TalkService_sendDummyPush_args();
    try {
      output.writeMessageBegin('sendDummyPush', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sendDummyPush (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_sendDummyPush_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  inviteFriendsBySms (phoneNumberList) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_inviteFriendsBySms(phoneNumberList);
    });
  }

  send_inviteFriendsBySms (phoneNumberList) {
    const output = new this.pClass(this.output);
    const params = {
      phoneNumberList: phoneNumberList
    };
    const args = new TalkService_inviteFriendsBySms_args(params);
    try {
      output.writeMessageBegin('inviteFriendsBySms', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_inviteFriendsBySms (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_inviteFriendsBySms_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  getMessageBox (channelId, messageBoxId, lastMessagesCount) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_getMessageBox(channelId, messageBoxId, lastMessagesCount);
    });
  }

  send_getMessageBox (channelId, messageBoxId, lastMessagesCount) {
    const output = new this.pClass(this.output);
    const params = {
      channelId: channelId,
      messageBoxId: messageBoxId,
      lastMessagesCount: lastMessagesCount
    };
    const args = new TalkService_getMessageBox_args(params);
    try {
      output.writeMessageBegin('getMessageBox', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_getMessageBox (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new TalkService_getMessageBox_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('getMessageBox failed: unknown result');
  }
};
const TalkServiceProcessor = exports.Processor = class {
  constructor(handler) {
    this._handler = handler;
  }
  process (input, output) {
    const r = input.readMessageBegin();
    if (this['process_' + r.fname]) {
      return this['process_' + r.fname].call(this, r.rseqid, input, output);
    } else {
      input.skip(Thrift.Type.STRUCT);
      input.readMessageEnd();
      const x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname);
      output.writeMessageBegin(r.fname, Thrift.MessageType.EXCEPTION, r.rseqid);
      x.write(output);
      output.writeMessageEnd();
      output.flush();
    }
  }
  process_reportDeviceState (seqid, input, output) {
    const args = new TalkService_reportDeviceState_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportDeviceState.length === 2) {
      Promise.resolve(this._handler.reportDeviceState.bind(this._handler)(
        args.booleanState,
        args.stringState
      )).then(result => {
        const result_obj = new TalkService_reportDeviceState_result({success: result});
        output.writeMessageBegin("reportDeviceState", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportDeviceState_result(err);
          output.writeMessageBegin("reportDeviceState", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportDeviceState", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportDeviceState(args.booleanState, args.stringState, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportDeviceState_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportDeviceState", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportDeviceState", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifySleepV2 (seqid, input, output) {
    const args = new TalkService_notifySleepV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifySleepV2.length === 1) {
      Promise.resolve(this._handler.notifySleepV2.bind(this._handler)(
        args.lastStatusMap
      )).then(result => {
        const result_obj = new TalkService_notifySleepV2_result({success: result});
        output.writeMessageBegin("notifySleepV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_notifySleepV2_result(err);
          output.writeMessageBegin("notifySleepV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifySleepV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifySleepV2(args.lastStatusMap, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_notifySleepV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifySleepV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifySleepV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateNotificationToken (seqid, input, output) {
    const args = new TalkService_updateNotificationToken_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateNotificationToken.length === 2) {
      Promise.resolve(this._handler.updateNotificationToken.bind(this._handler)(
        args.token,
        args.type
      )).then(result => {
        const result_obj = new TalkService_updateNotificationToken_result({success: result});
        output.writeMessageBegin("updateNotificationToken", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateNotificationToken_result(err);
          output.writeMessageBegin("updateNotificationToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateNotificationToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateNotificationToken(args.token, args.type, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateNotificationToken_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateNotificationToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateNotificationToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateGroup (seqid, input, output) {
    const args = new TalkService_updateGroup_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateGroup.length === 2) {
      Promise.resolve(this._handler.updateGroup.bind(this._handler)(
        args.reqSeq,
        args.group
      )).then(result => {
        const result_obj = new TalkService_updateGroup_result({success: result});
        output.writeMessageBegin("updateGroup", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateGroup_result(err);
          output.writeMessageBegin("updateGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateGroup(args.reqSeq, args.group, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateGroup_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_verifyAccountMigrationPincode (seqid, input, output) {
    const args = new TalkService_verifyAccountMigrationPincode_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.verifyAccountMigrationPincode.length === 2) {
      Promise.resolve(this._handler.verifyAccountMigrationPincode.bind(this._handler)(
        args.migrationPincodeSessionId,
        args.accountMigrationPincode
      )).then(result => {
        const result_obj = new TalkService_verifyAccountMigrationPincode_result({success: result});
        output.writeMessageBegin("verifyAccountMigrationPincode", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_verifyAccountMigrationPincode_result(err);
          output.writeMessageBegin("verifyAccountMigrationPincode", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyAccountMigrationPincode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.verifyAccountMigrationPincode(args.migrationPincodeSessionId, args.accountMigrationPincode, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_verifyAccountMigrationPincode_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("verifyAccountMigrationPincode", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyAccountMigrationPincode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerWithExistingSnsIdAndIdentityCredential (seqid, input, output) {
    const args = new TalkService_registerWithExistingSnsIdAndIdentityCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerWithExistingSnsIdAndIdentityCredential.length === 5) {
      Promise.resolve(this._handler.registerWithExistingSnsIdAndIdentityCredential.bind(this._handler)(
        args.identityCredential,
        args.region,
        args.udidHash,
        args.deviceInfo,
        args.migrationPincodeSessionId
      )).then(result => {
        const result_obj = new TalkService_registerWithExistingSnsIdAndIdentityCredential_result({success: result});
        output.writeMessageBegin("registerWithExistingSnsIdAndIdentityCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerWithExistingSnsIdAndIdentityCredential_result(err);
          output.writeMessageBegin("registerWithExistingSnsIdAndIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithExistingSnsIdAndIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerWithExistingSnsIdAndIdentityCredential(args.identityCredential, args.region, args.udidHash, args.deviceInfo, args.migrationPincodeSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerWithExistingSnsIdAndIdentityCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerWithExistingSnsIdAndIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithExistingSnsIdAndIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerDeviceWithoutPhoneNumber (seqid, input, output) {
    const args = new TalkService_registerDeviceWithoutPhoneNumber_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerDeviceWithoutPhoneNumber.length === 3) {
      Promise.resolve(this._handler.registerDeviceWithoutPhoneNumber.bind(this._handler)(
        args.region,
        args.udidHash,
        args.deviceInfo
      )).then(result => {
        const result_obj = new TalkService_registerDeviceWithoutPhoneNumber_result({success: result});
        output.writeMessageBegin("registerDeviceWithoutPhoneNumber", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerDeviceWithoutPhoneNumber_result(err);
          output.writeMessageBegin("registerDeviceWithoutPhoneNumber", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerDeviceWithoutPhoneNumber", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerDeviceWithoutPhoneNumber(args.region, args.udidHash, args.deviceInfo, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerDeviceWithoutPhoneNumber_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerDeviceWithoutPhoneNumber", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerDeviceWithoutPhoneNumber", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_changeVerificationMethod (seqid, input, output) {
    const args = new TalkService_changeVerificationMethod_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.changeVerificationMethod.length === 2) {
      Promise.resolve(this._handler.changeVerificationMethod.bind(this._handler)(
        args.sessionId,
        args.method
      )).then(result => {
        const result_obj = new TalkService_changeVerificationMethod_result({success: result});
        output.writeMessageBegin("changeVerificationMethod", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_changeVerificationMethod_result(err);
          output.writeMessageBegin("changeVerificationMethod", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("changeVerificationMethod", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.changeVerificationMethod(args.sessionId, args.method, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_changeVerificationMethod_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("changeVerificationMethod", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("changeVerificationMethod", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_setBuddyLocation (seqid, input, output) {
    const args = new TalkService_setBuddyLocation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.setBuddyLocation.length === 3) {
      Promise.resolve(this._handler.setBuddyLocation.bind(this._handler)(
        args.mid,
        args.index,
        args.location
      )).then(result => {
        const result_obj = new TalkService_setBuddyLocation_result({success: result});
        output.writeMessageBegin("setBuddyLocation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_setBuddyLocation_result(err);
          output.writeMessageBegin("setBuddyLocation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("setBuddyLocation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.setBuddyLocation(args.mid, args.index, args.location, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_setBuddyLocation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("setBuddyLocation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("setBuddyLocation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getFriendRequests (seqid, input, output) {
    const args = new TalkService_getFriendRequests_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getFriendRequests.length === 2) {
      Promise.resolve(this._handler.getFriendRequests.bind(this._handler)(
        args.direction,
        args.lastSeenSeqId
      )).then(result => {
        const result_obj = new TalkService_getFriendRequests_result({success: result});
        output.writeMessageBegin("getFriendRequests", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getFriendRequests_result(err);
          output.writeMessageBegin("getFriendRequests", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getFriendRequests", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getFriendRequests(args.direction, args.lastSeenSeqId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getFriendRequests_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getFriendRequests", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getFriendRequests", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_kickoutFromGroup (seqid, input, output) {
    const args = new TalkService_kickoutFromGroup_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.kickoutFromGroup.length === 3) {
      Promise.resolve(this._handler.kickoutFromGroup.bind(this._handler)(
        args.reqSeq,
        args.groupId,
        args.contactIds
      )).then(result => {
        const result_obj = new TalkService_kickoutFromGroup_result({success: result});
        output.writeMessageBegin("kickoutFromGroup", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_kickoutFromGroup_result(err);
          output.writeMessageBegin("kickoutFromGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("kickoutFromGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.kickoutFromGroup(args.reqSeq, args.groupId, args.contactIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_kickoutFromGroup_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("kickoutFromGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("kickoutFromGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_verifyIdentityCredentialWithResult (seqid, input, output) {
    const args = new TalkService_verifyIdentityCredentialWithResult_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.verifyIdentityCredentialWithResult.length === 2) {
      Promise.resolve(this._handler.verifyIdentityCredentialWithResult.bind(this._handler)(
        args.identityCredential,
        args.migrationPincodeSessionId
      )).then(result => {
        const result_obj = new TalkService_verifyIdentityCredentialWithResult_result({success: result});
        output.writeMessageBegin("verifyIdentityCredentialWithResult", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_verifyIdentityCredentialWithResult_result(err);
          output.writeMessageBegin("verifyIdentityCredentialWithResult", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyIdentityCredentialWithResult", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.verifyIdentityCredentialWithResult(args.identityCredential, args.migrationPincodeSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_verifyIdentityCredentialWithResult_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("verifyIdentityCredentialWithResult", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyIdentityCredentialWithResult", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendEchoPush (seqid, input, output) {
    const args = new TalkService_sendEchoPush_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendEchoPush.length === 1) {
      Promise.resolve(this._handler.sendEchoPush.bind(this._handler)(
        args.text
      )).then(result => {
        const result_obj = new TalkService_sendEchoPush_result({success: result});
        output.writeMessageBegin("sendEchoPush", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendEchoPush_result(err);
          output.writeMessageBegin("sendEchoPush", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendEchoPush", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendEchoPush(args.text, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendEchoPush_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendEchoPush", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendEchoPush", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_createSession (seqid, input, output) {
    const args = new TalkService_createSession_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.createSession.length === 0) {
      Promise.resolve(this._handler.createSession.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_createSession_result({success: result});
        output.writeMessageBegin("createSession", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_createSession_result(err);
          output.writeMessageBegin("createSession", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createSession", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.createSession((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_createSession_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("createSession", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createSession", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reissueDeviceCredential (seqid, input, output) {
    const args = new TalkService_reissueDeviceCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reissueDeviceCredential.length === 0) {
      Promise.resolve(this._handler.reissueDeviceCredential.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_reissueDeviceCredential_result({success: result});
        output.writeMessageBegin("reissueDeviceCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reissueDeviceCredential_result(err);
          output.writeMessageBegin("reissueDeviceCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reissueDeviceCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reissueDeviceCredential((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reissueDeviceCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reissueDeviceCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reissueDeviceCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRecommendationIds (seqid, input, output) {
    const args = new TalkService_getRecommendationIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRecommendationIds.length === 0) {
      Promise.resolve(this._handler.getRecommendationIds.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getRecommendationIds_result({success: result});
        output.writeMessageBegin("getRecommendationIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRecommendationIds_result(err);
          output.writeMessageBegin("getRecommendationIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRecommendationIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRecommendationIds((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRecommendationIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRecommendationIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRecommendationIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_inviteViaEmail (seqid, input, output) {
    const args = new TalkService_inviteViaEmail_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.inviteViaEmail.length === 3) {
      Promise.resolve(this._handler.inviteViaEmail.bind(this._handler)(
        args.reqSeq,
        args.email,
        args.name
      )).then(result => {
        const result_obj = new TalkService_inviteViaEmail_result({success: result});
        output.writeMessageBegin("inviteViaEmail", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_inviteViaEmail_result(err);
          output.writeMessageBegin("inviteViaEmail", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("inviteViaEmail", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.inviteViaEmail(args.reqSeq, args.email, args.name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_inviteViaEmail_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("inviteViaEmail", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("inviteViaEmail", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRoomsV2 (seqid, input, output) {
    const args = new TalkService_getRoomsV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRoomsV2.length === 1) {
      Promise.resolve(this._handler.getRoomsV2.bind(this._handler)(
        args.roomIds
      )).then(result => {
        const result_obj = new TalkService_getRoomsV2_result({success: result});
        output.writeMessageBegin("getRoomsV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRoomsV2_result(err);
          output.writeMessageBegin("getRoomsV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRoomsV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRoomsV2(args.roomIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRoomsV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRoomsV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRoomsV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getReadMessageOps (seqid, input, output) {
    const args = new TalkService_getReadMessageOps_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getReadMessageOps.length === 1) {
      Promise.resolve(this._handler.getReadMessageOps.bind(this._handler)(
        args.chatId
      )).then(result => {
        const result_obj = new TalkService_getReadMessageOps_result({success: result});
        output.writeMessageBegin("getReadMessageOps", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getReadMessageOps_result(err);
          output.writeMessageBegin("getReadMessageOps", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getReadMessageOps", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getReadMessageOps(args.chatId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getReadMessageOps_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getReadMessageOps", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getReadMessageOps", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getSettingsAttributes (seqid, input, output) {
    const args = new TalkService_getSettingsAttributes_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getSettingsAttributes.length === 1) {
      Promise.resolve(this._handler.getSettingsAttributes.bind(this._handler)(
        args.attrBitset
      )).then(result => {
        const result_obj = new TalkService_getSettingsAttributes_result({success: result});
        output.writeMessageBegin("getSettingsAttributes", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getSettingsAttributes_result(err);
          output.writeMessageBegin("getSettingsAttributes", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSettingsAttributes", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getSettingsAttributes(args.attrBitset, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getSettingsAttributes_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getSettingsAttributes", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSettingsAttributes", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_requestIdentityUnbind (seqid, input, output) {
    const args = new TalkService_requestIdentityUnbind_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.requestIdentityUnbind.length === 2) {
      Promise.resolve(this._handler.requestIdentityUnbind.bind(this._handler)(
        args.identifier,
        args.provider
      )).then(result => {
        const result_obj = new TalkService_requestIdentityUnbind_result({success: result});
        output.writeMessageBegin("requestIdentityUnbind", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_requestIdentityUnbind_result(err);
          output.writeMessageBegin("requestIdentityUnbind", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestIdentityUnbind", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.requestIdentityUnbind(args.identifier, args.provider, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_requestIdentityUnbind_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("requestIdentityUnbind", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestIdentityUnbind", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessagesBySequenceNumber (seqid, input, output) {
    const args = new TalkService_getMessagesBySequenceNumber_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessagesBySequenceNumber.length === 4) {
      Promise.resolve(this._handler.getMessagesBySequenceNumber.bind(this._handler)(
        args.channelId,
        args.messageBoxId,
        args.startSeq,
        args.endSeq
      )).then(result => {
        const result_obj = new TalkService_getMessagesBySequenceNumber_result({success: result});
        output.writeMessageBegin("getMessagesBySequenceNumber", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessagesBySequenceNumber_result(err);
          output.writeMessageBegin("getMessagesBySequenceNumber", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessagesBySequenceNumber", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessagesBySequenceNumber(args.channelId, args.messageBoxId, args.startSeq, args.endSeq, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessagesBySequenceNumber_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessagesBySequenceNumber", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessagesBySequenceNumber", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_inviteIntoRoom (seqid, input, output) {
    const args = new TalkService_inviteIntoRoom_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.inviteIntoRoom.length === 3) {
      Promise.resolve(this._handler.inviteIntoRoom.bind(this._handler)(
        args.reqSeq,
        args.roomId,
        args.contactIds
      )).then(result => {
        const result_obj = new TalkService_inviteIntoRoom_result({success: result});
        output.writeMessageBegin("inviteIntoRoom", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_inviteIntoRoom_result(err);
          output.writeMessageBegin("inviteIntoRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("inviteIntoRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.inviteIntoRoom(args.reqSeq, args.roomId, args.contactIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_inviteIntoRoom_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("inviteIntoRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("inviteIntoRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendChatChecked (seqid, input, output) {
    const args = new TalkService_sendChatChecked_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendChatChecked.length === 4) {
      Promise.resolve(this._handler.sendChatChecked.bind(this._handler)(
        args.seq,
        args.consumer,
        args.lastMessageId,
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_sendChatChecked_result({success: result});
        output.writeMessageBegin("sendChatChecked", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendChatChecked_result(err);
          output.writeMessageBegin("sendChatChecked", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendChatChecked", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendChatChecked(args.seq, args.consumer, args.lastMessageId, args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendChatChecked_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendChatChecked", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendChatChecked", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_removeSnsId (seqid, input, output) {
    const args = new TalkService_removeSnsId_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.removeSnsId.length === 1) {
      Promise.resolve(this._handler.removeSnsId.bind(this._handler)(
        args.snsIdType
      )).then(result => {
        const result_obj = new TalkService_removeSnsId_result({success: result});
        output.writeMessageBegin("removeSnsId", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_removeSnsId_result(err);
          output.writeMessageBegin("removeSnsId", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeSnsId", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.removeSnsId(args.snsIdType, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_removeSnsId_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("removeSnsId", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeSnsId", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reportSpammer (seqid, input, output) {
    const args = new TalkService_reportSpammer_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportSpammer.length === 4) {
      Promise.resolve(this._handler.reportSpammer.bind(this._handler)(
        args.spammerMid,
        args.spammerReasons,
        args.spamMessageIds,
        args.spamMessages
      )).then(result => {
        const result_obj = new TalkService_reportSpammer_result({success: result});
        output.writeMessageBegin("reportSpammer", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportSpammer_result(err);
          output.writeMessageBegin("reportSpammer", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportSpammer", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportSpammer(args.spammerMid, args.spammerReasons, args.spamMessageIds, args.spamMessages, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportSpammer_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportSpammer", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportSpammer", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findAndAddContactsByEmail (seqid, input, output) {
    const args = new TalkService_findAndAddContactsByEmail_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findAndAddContactsByEmail.length === 2) {
      Promise.resolve(this._handler.findAndAddContactsByEmail.bind(this._handler)(
        args.reqSeq,
        args.emails
      )).then(result => {
        const result_obj = new TalkService_findAndAddContactsByEmail_result({success: result});
        output.writeMessageBegin("findAndAddContactsByEmail", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findAndAddContactsByEmail_result(err);
          output.writeMessageBegin("findAndAddContactsByEmail", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactsByEmail", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findAndAddContactsByEmail(args.reqSeq, args.emails, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findAndAddContactsByEmail_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findAndAddContactsByEmail", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactsByEmail", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getCompactGroups (seqid, input, output) {
    const args = new TalkService_getCompactGroups_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getCompactGroups.length === 1) {
      Promise.resolve(this._handler.getCompactGroups.bind(this._handler)(
        args.groupIds
      )).then(result => {
        const result_obj = new TalkService_getCompactGroups_result({success: result});
        output.writeMessageBegin("getCompactGroups", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getCompactGroups_result(err);
          output.writeMessageBegin("getCompactGroups", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactGroups", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getCompactGroups(args.groupIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getCompactGroups_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getCompactGroups", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactGroups", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendMessage (seqid, input, output) {
    const args = new TalkService_sendMessage_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendMessage.length === 2) {
      Promise.resolve(this._handler.sendMessage.bind(this._handler)(
        args.seq,
        args.message
      )).then(result => {
        const result_obj = new TalkService_sendMessage_result({success: result});
        output.writeMessageBegin("sendMessage", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendMessage_result(err);
          output.writeMessageBegin("sendMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendMessage(args.seq, args.message, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendMessage_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRooms (seqid, input, output) {
    const args = new TalkService_getRooms_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRooms.length === 1) {
      Promise.resolve(this._handler.getRooms.bind(this._handler)(
        args.roomIds
      )).then(result => {
        const result_obj = new TalkService_getRooms_result({success: result});
        output.writeMessageBegin("getRooms", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRooms_result(err);
          output.writeMessageBegin("getRooms", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRooms", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRooms(args.roomIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRooms_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRooms", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRooms", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateC2DMRegistrationId (seqid, input, output) {
    const args = new TalkService_updateC2DMRegistrationId_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateC2DMRegistrationId.length === 1) {
      Promise.resolve(this._handler.updateC2DMRegistrationId.bind(this._handler)(
        args.registrationId
      )).then(result => {
        const result_obj = new TalkService_updateC2DMRegistrationId_result({success: result});
        output.writeMessageBegin("updateC2DMRegistrationId", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateC2DMRegistrationId_result(err);
          output.writeMessageBegin("updateC2DMRegistrationId", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateC2DMRegistrationId", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateC2DMRegistrationId(args.registrationId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateC2DMRegistrationId_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateC2DMRegistrationId", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateC2DMRegistrationId", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendPostback (seqid, input, output) {
    const args = new TalkService_sendPostback_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendPostback.length === 1) {
      Promise.resolve(this._handler.sendPostback.bind(this._handler)(
        args.request
      )).then(result => {
        const result_obj = new TalkService_sendPostback_result({success: result});
        output.writeMessageBegin("sendPostback", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendPostback_result(err);
          output.writeMessageBegin("sendPostback", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendPostback", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendPostback(args.request, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendPostback_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendPostback", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendPostback", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getReadMessageOpsInBulk (seqid, input, output) {
    const args = new TalkService_getReadMessageOpsInBulk_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getReadMessageOpsInBulk.length === 1) {
      Promise.resolve(this._handler.getReadMessageOpsInBulk.bind(this._handler)(
        args.chatIds
      )).then(result => {
        const result_obj = new TalkService_getReadMessageOpsInBulk_result({success: result});
        output.writeMessageBegin("getReadMessageOpsInBulk", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getReadMessageOpsInBulk_result(err);
          output.writeMessageBegin("getReadMessageOpsInBulk", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getReadMessageOpsInBulk", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getReadMessageOpsInBulk(args.chatIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getReadMessageOpsInBulk_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getReadMessageOpsInBulk", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getReadMessageOpsInBulk", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendMessageIgnored (seqid, input, output) {
    const args = new TalkService_sendMessageIgnored_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendMessageIgnored.length === 3) {
      Promise.resolve(this._handler.sendMessageIgnored.bind(this._handler)(
        args.seq,
        args.consumer,
        args.messageIds
      )).then(result => {
        const result_obj = new TalkService_sendMessageIgnored_result({success: result});
        output.writeMessageBegin("sendMessageIgnored", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendMessageIgnored_result(err);
          output.writeMessageBegin("sendMessageIgnored", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessageIgnored", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendMessageIgnored(args.seq, args.consumer, args.messageIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendMessageIgnored_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendMessageIgnored", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessageIgnored", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxWrapUpListV2 (seqid, input, output) {
    const args = new TalkService_getMessageBoxWrapUpListV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxWrapUpListV2.length === 2) {
      Promise.resolve(this._handler.getMessageBoxWrapUpListV2.bind(this._handler)(
        args.messageBoxOffset,
        args.messageBoxCount
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxWrapUpListV2_result({success: result});
        output.writeMessageBegin("getMessageBoxWrapUpListV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxWrapUpListV2_result(err);
          output.writeMessageBegin("getMessageBoxWrapUpListV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxWrapUpListV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxWrapUpListV2(args.messageBoxOffset, args.messageBoxCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxWrapUpListV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxWrapUpListV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxWrapUpListV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getOldReadMessageOpsWithRange (seqid, input, output) {
    const args = new TalkService_getOldReadMessageOpsWithRange_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getOldReadMessageOpsWithRange.length === 2) {
      Promise.resolve(this._handler.getOldReadMessageOpsWithRange.bind(this._handler)(
        args.startRev,
        args.endRev
      )).then(result => {
        const result_obj = new TalkService_getOldReadMessageOpsWithRange_result({success: result});
        output.writeMessageBegin("getOldReadMessageOpsWithRange", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getOldReadMessageOpsWithRange_result(err);
          output.writeMessageBegin("getOldReadMessageOpsWithRange", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getOldReadMessageOpsWithRange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getOldReadMessageOpsWithRange(args.startRev, args.endRev, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getOldReadMessageOpsWithRange_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getOldReadMessageOpsWithRange", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getOldReadMessageOpsWithRange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRSAKeyInfo (seqid, input, output) {
    const args = new TalkService_getRSAKeyInfo_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRSAKeyInfo.length === 1) {
      Promise.resolve(this._handler.getRSAKeyInfo.bind(this._handler)(
        args.provider
      )).then(result => {
        const result_obj = new TalkService_getRSAKeyInfo_result({success: result});
        output.writeMessageBegin("getRSAKeyInfo", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRSAKeyInfo_result(err);
          output.writeMessageBegin("getRSAKeyInfo", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRSAKeyInfo", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRSAKeyInfo(args.provider, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRSAKeyInfo_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRSAKeyInfo", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRSAKeyInfo", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateProfileAttribute (seqid, input, output) {
    const args = new TalkService_updateProfileAttribute_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateProfileAttribute.length === 3) {
      Promise.resolve(this._handler.updateProfileAttribute.bind(this._handler)(
        args.reqSeq,
        args.attr,
        args.value
      )).then(result => {
        const result_obj = new TalkService_updateProfileAttribute_result({success: result});
        output.writeMessageBegin("updateProfileAttribute", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateProfileAttribute_result(err);
          output.writeMessageBegin("updateProfileAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateProfileAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateProfileAttribute(args.reqSeq, args.attr, args.value, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateProfileAttribute_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateProfileAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateProfileAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_createAccountMigrationPincodeSession (seqid, input, output) {
    const args = new TalkService_createAccountMigrationPincodeSession_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.createAccountMigrationPincodeSession.length === 0) {
      Promise.resolve(this._handler.createAccountMigrationPincodeSession.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_createAccountMigrationPincodeSession_result({success: result});
        output.writeMessageBegin("createAccountMigrationPincodeSession", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_createAccountMigrationPincodeSession_result(err);
          output.writeMessageBegin("createAccountMigrationPincodeSession", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createAccountMigrationPincodeSession", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.createAccountMigrationPincodeSession((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_createAccountMigrationPincodeSession_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("createAccountMigrationPincodeSession", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createAccountMigrationPincodeSession", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifiedRedirect (seqid, input, output) {
    const args = new TalkService_notifiedRedirect_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifiedRedirect.length === 1) {
      Promise.resolve(this._handler.notifiedRedirect.bind(this._handler)(
        args.paramMap
      )).then(result => {
        const result_obj = new TalkService_notifiedRedirect_result({success: result});
        output.writeMessageBegin("notifiedRedirect", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_notifiedRedirect_result(err);
          output.writeMessageBegin("notifiedRedirect", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifiedRedirect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifiedRedirect(args.paramMap, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_notifiedRedirect_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifiedRedirect", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifiedRedirect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifyIndividualEvent (seqid, input, output) {
    const args = new TalkService_notifyIndividualEvent_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifyIndividualEvent.length === 2) {
      Promise.resolve(this._handler.notifyIndividualEvent.bind(this._handler)(
        args.notificationStatus,
        args.receiverMids
      )).then(result => {
        const result_obj = new TalkService_notifyIndividualEvent_result({success: result});
        output.writeMessageBegin("notifyIndividualEvent", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_notifyIndividualEvent_result(err);
          output.writeMessageBegin("notifyIndividualEvent", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyIndividualEvent", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifyIndividualEvent(args.notificationStatus, args.receiverMids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_notifyIndividualEvent_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifyIndividualEvent", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyIndividualEvent", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateApnsDeviceToken (seqid, input, output) {
    const args = new TalkService_updateApnsDeviceToken_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateApnsDeviceToken.length === 1) {
      Promise.resolve(this._handler.updateApnsDeviceToken.bind(this._handler)(
        args.apnsDeviceToken
      )).then(result => {
        const result_obj = new TalkService_updateApnsDeviceToken_result({success: result});
        output.writeMessageBegin("updateApnsDeviceToken", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateApnsDeviceToken_result(err);
          output.writeMessageBegin("updateApnsDeviceToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateApnsDeviceToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateApnsDeviceToken(args.apnsDeviceToken, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateApnsDeviceToken_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateApnsDeviceToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateApnsDeviceToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxCompactWrapUpListV2 (seqid, input, output) {
    const args = new TalkService_getMessageBoxCompactWrapUpListV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxCompactWrapUpListV2.length === 2) {
      Promise.resolve(this._handler.getMessageBoxCompactWrapUpListV2.bind(this._handler)(
        args.messageBoxOffset,
        args.messageBoxCount
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxCompactWrapUpListV2_result({success: result});
        output.writeMessageBegin("getMessageBoxCompactWrapUpListV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxCompactWrapUpListV2_result(err);
          output.writeMessageBegin("getMessageBoxCompactWrapUpListV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxCompactWrapUpListV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxCompactWrapUpListV2(args.messageBoxOffset, args.messageBoxCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxCompactWrapUpListV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxCompactWrapUpListV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxCompactWrapUpListV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_requestEmailConfirmation (seqid, input, output) {
    const args = new TalkService_requestEmailConfirmation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.requestEmailConfirmation.length === 1) {
      Promise.resolve(this._handler.requestEmailConfirmation.bind(this._handler)(
        args.emailConfirmation
      )).then(result => {
        const result_obj = new TalkService_requestEmailConfirmation_result({success: result});
        output.writeMessageBegin("requestEmailConfirmation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_requestEmailConfirmation_result(err);
          output.writeMessageBegin("requestEmailConfirmation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestEmailConfirmation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.requestEmailConfirmation(args.emailConfirmation, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_requestEmailConfirmation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("requestEmailConfirmation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestEmailConfirmation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerWithSnsIdAndIdentityCredential (seqid, input, output) {
    const args = new TalkService_registerWithSnsIdAndIdentityCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerWithSnsIdAndIdentityCredential.length === 7) {
      Promise.resolve(this._handler.registerWithSnsIdAndIdentityCredential.bind(this._handler)(
        args.snsIdType,
        args.snsAccessToken,
        args.identityCredential,
        args.region,
        args.udidHash,
        args.deviceInfo,
        args.migrationPincodeSessionId
      )).then(result => {
        const result_obj = new TalkService_registerWithSnsIdAndIdentityCredential_result({success: result});
        output.writeMessageBegin("registerWithSnsIdAndIdentityCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerWithSnsIdAndIdentityCredential_result(err);
          output.writeMessageBegin("registerWithSnsIdAndIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithSnsIdAndIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerWithSnsIdAndIdentityCredential(args.snsIdType, args.snsAccessToken, args.identityCredential, args.region, args.udidHash, args.deviceInfo, args.migrationPincodeSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerWithSnsIdAndIdentityCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerWithSnsIdAndIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithSnsIdAndIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxCompactWrapUp (seqid, input, output) {
    const args = new TalkService_getMessageBoxCompactWrapUp_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxCompactWrapUp.length === 1) {
      Promise.resolve(this._handler.getMessageBoxCompactWrapUp.bind(this._handler)(
        args.mid
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxCompactWrapUp_result({success: result});
        output.writeMessageBegin("getMessageBoxCompactWrapUp", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxCompactWrapUp_result(err);
          output.writeMessageBegin("getMessageBoxCompactWrapUp", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxCompactWrapUp", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxCompactWrapUp(args.mid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxCompactWrapUp_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxCompactWrapUp", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxCompactWrapUp", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findContactByUserTicket (seqid, input, output) {
    const args = new TalkService_findContactByUserTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findContactByUserTicket.length === 1) {
      Promise.resolve(this._handler.findContactByUserTicket.bind(this._handler)(
        args.ticketIdWithTag
      )).then(result => {
        const result_obj = new TalkService_findContactByUserTicket_result({success: result});
        output.writeMessageBegin("findContactByUserTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findContactByUserTicket_result(err);
          output.writeMessageBegin("findContactByUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactByUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findContactByUserTicket(args.ticketIdWithTag, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findContactByUserTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findContactByUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactByUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateAccountMigrationPincode (seqid, input, output) {
    const args = new TalkService_updateAccountMigrationPincode_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateAccountMigrationPincode.length === 1) {
      Promise.resolve(this._handler.updateAccountMigrationPincode.bind(this._handler)(
        args.accountMigrationPincode
      )).then(result => {
        const result_obj = new TalkService_updateAccountMigrationPincode_result({success: result});
        output.writeMessageBegin("updateAccountMigrationPincode", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateAccountMigrationPincode_result(err);
          output.writeMessageBegin("updateAccountMigrationPincode", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateAccountMigrationPincode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateAccountMigrationPincode(args.accountMigrationPincode, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateAccountMigrationPincode_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateAccountMigrationPincode", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateAccountMigrationPincode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerBuddyUser (seqid, input, output) {
    const args = new TalkService_registerBuddyUser_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerBuddyUser.length === 2) {
      Promise.resolve(this._handler.registerBuddyUser.bind(this._handler)(
        args.buddyId,
        args.registrarPassword
      )).then(result => {
        const result_obj = new TalkService_registerBuddyUser_result({success: result});
        output.writeMessageBegin("registerBuddyUser", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerBuddyUser_result(err);
          output.writeMessageBegin("registerBuddyUser", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerBuddyUser", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerBuddyUser(args.buddyId, args.registrarPassword, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerBuddyUser_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerBuddyUser", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerBuddyUser", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateSettings2 (seqid, input, output) {
    const args = new TalkService_updateSettings2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateSettings2.length === 2) {
      Promise.resolve(this._handler.updateSettings2.bind(this._handler)(
        args.reqSeq,
        args.settings
      )).then(result => {
        const result_obj = new TalkService_updateSettings2_result({success: result});
        output.writeMessageBegin("updateSettings2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateSettings2_result(err);
          output.writeMessageBegin("updateSettings2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateSettings2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateSettings2(args.reqSeq, args.settings, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateSettings2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateSettings2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateSettings2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getUserTicket (seqid, input, output) {
    const args = new TalkService_getUserTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getUserTicket.length === 0) {
      Promise.resolve(this._handler.getUserTicket.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getUserTicket_result({success: result});
        output.writeMessageBegin("getUserTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getUserTicket_result(err);
          output.writeMessageBegin("getUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getUserTicket((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getUserTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_fetchOps (seqid, input, output) {
    const args = new TalkService_fetchOps_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.fetchOps.length === 4) {
      Promise.resolve(this._handler.fetchOps.bind(this._handler)(
        args.localRev,
        args.count,
        args.globalRev,
        args.individualRev
      )).then(result => {
        const result_obj = new TalkService_fetchOps_result({success: result});
        output.writeMessageBegin("fetchOps", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ShouldSyncException) {
          result = new TalkService_fetchOps_result(err);
          output.writeMessageBegin("fetchOps", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("fetchOps", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.fetchOps(args.localRev, args.count, args.globalRev, args.individualRev, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ShouldSyncException) {
          result_obj = new TalkService_fetchOps_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("fetchOps", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("fetchOps", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_commitSendMessagesToMid (seqid, input, output) {
    const args = new TalkService_commitSendMessagesToMid_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.commitSendMessagesToMid.length === 1) {
      Promise.resolve(this._handler.commitSendMessagesToMid.bind(this._handler)(
        args.request
      )).then(result => {
        const result_obj = new TalkService_commitSendMessagesToMid_result({success: result});
        output.writeMessageBegin("commitSendMessagesToMid", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_commitSendMessagesToMid_result(err);
          output.writeMessageBegin("commitSendMessagesToMid", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("commitSendMessagesToMid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.commitSendMessagesToMid(args.request, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_commitSendMessagesToMid_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("commitSendMessagesToMid", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("commitSendMessagesToMid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxV2 (seqid, input, output) {
    const args = new TalkService_getMessageBoxV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxV2.length === 2) {
      Promise.resolve(this._handler.getMessageBoxV2.bind(this._handler)(
        args.messageBoxId,
        args.lastMessagesCount
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxV2_result({success: result});
        output.writeMessageBegin("getMessageBoxV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxV2_result(err);
          output.writeMessageBegin("getMessageBoxV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxV2(args.messageBoxId, args.lastMessagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_requestResendMessage (seqid, input, output) {
    const args = new TalkService_requestResendMessage_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.requestResendMessage.length === 3) {
      Promise.resolve(this._handler.requestResendMessage.bind(this._handler)(
        args.reqSeq,
        args.senderMid,
        args.messageId
      )).then(result => {
        const result_obj = new TalkService_requestResendMessage_result({success: result});
        output.writeMessageBegin("requestResendMessage", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_requestResendMessage_result(err);
          output.writeMessageBegin("requestResendMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestResendMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.requestResendMessage(args.reqSeq, args.senderMid, args.messageId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_requestResendMessage_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("requestResendMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestResendMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getGroupWithoutMembers (seqid, input, output) {
    const args = new TalkService_getGroupWithoutMembers_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getGroupWithoutMembers.length === 1) {
      Promise.resolve(this._handler.getGroupWithoutMembers.bind(this._handler)(
        args.groupId
      )).then(result => {
        const result_obj = new TalkService_getGroupWithoutMembers_result({success: result});
        output.writeMessageBegin("getGroupWithoutMembers", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getGroupWithoutMembers_result(err);
          output.writeMessageBegin("getGroupWithoutMembers", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroupWithoutMembers", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getGroupWithoutMembers(args.groupId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getGroupWithoutMembers_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getGroupWithoutMembers", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroupWithoutMembers", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_removeAllMessages (seqid, input, output) {
    const args = new TalkService_removeAllMessages_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.removeAllMessages.length === 2) {
      Promise.resolve(this._handler.removeAllMessages.bind(this._handler)(
        args.seq,
        args.lastMessageId
      )).then(result => {
        const result_obj = new TalkService_removeAllMessages_result({success: result});
        output.writeMessageBegin("removeAllMessages", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_removeAllMessages_result(err);
          output.writeMessageBegin("removeAllMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeAllMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.removeAllMessages(args.seq, args.lastMessageId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_removeAllMessages_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("removeAllMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeAllMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_verifyAccountMigration (seqid, input, output) {
    const args = new TalkService_verifyAccountMigration_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.verifyAccountMigration.length === 1) {
      Promise.resolve(this._handler.verifyAccountMigration.bind(this._handler)(
        args.migrationSessionId
      )).then(result => {
        const result_obj = new TalkService_verifyAccountMigration_result({success: result});
        output.writeMessageBegin("verifyAccountMigration", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_verifyAccountMigration_result(err);
          output.writeMessageBegin("verifyAccountMigration", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyAccountMigration", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.verifyAccountMigration(args.migrationSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_verifyAccountMigration_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("verifyAccountMigration", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyAccountMigration", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reissueGroupTicket (seqid, input, output) {
    const args = new TalkService_reissueGroupTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reissueGroupTicket.length === 1) {
      Promise.resolve(this._handler.reissueGroupTicket.bind(this._handler)(
        args.groupMid
      )).then(result => {
        const result_obj = new TalkService_reissueGroupTicket_result({success: result});
        output.writeMessageBegin("reissueGroupTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reissueGroupTicket_result(err);
          output.writeMessageBegin("reissueGroupTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reissueGroupTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reissueGroupTicket(args.groupMid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reissueGroupTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reissueGroupTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reissueGroupTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_logoutSession (seqid, input, output) {
    const args = new TalkService_logoutSession_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.logoutSession.length === 1) {
      Promise.resolve(this._handler.logoutSession.bind(this._handler)(
        args.tokenKey
      )).then(result => {
        const result_obj = new TalkService_logoutSession_result({success: result});
        output.writeMessageBegin("logoutSession", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_logoutSession_result(err);
          output.writeMessageBegin("logoutSession", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("logoutSession", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.logoutSession(args.tokenKey, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_logoutSession_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("logoutSession", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("logoutSession", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getBuddyLocation (seqid, input, output) {
    const args = new TalkService_getBuddyLocation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getBuddyLocation.length === 2) {
      Promise.resolve(this._handler.getBuddyLocation.bind(this._handler)(
        args.mid,
        args.index
      )).then(result => {
        const result_obj = new TalkService_getBuddyLocation_result({success: result});
        output.writeMessageBegin("getBuddyLocation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getBuddyLocation_result(err);
          output.writeMessageBegin("getBuddyLocation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBuddyLocation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getBuddyLocation(args.mid, args.index, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getBuddyLocation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getBuddyLocation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBuddyLocation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getWapInvitation (seqid, input, output) {
    const args = new TalkService_getWapInvitation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getWapInvitation.length === 1) {
      Promise.resolve(this._handler.getWapInvitation.bind(this._handler)(
        args.invitationHash
      )).then(result => {
        const result_obj = new TalkService_getWapInvitation_result({success: result});
        output.writeMessageBegin("getWapInvitation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getWapInvitation_result(err);
          output.writeMessageBegin("getWapInvitation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getWapInvitation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getWapInvitation(args.invitationHash, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getWapInvitation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getWapInvitation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getWapInvitation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerDevice (seqid, input, output) {
    const args = new TalkService_registerDevice_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerDevice.length === 2) {
      Promise.resolve(this._handler.registerDevice.bind(this._handler)(
        args.sessionId,
        args.migrationPincodeSessionId
      )).then(result => {
        const result_obj = new TalkService_registerDevice_result({success: result});
        output.writeMessageBegin("registerDevice", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerDevice_result(err);
          output.writeMessageBegin("registerDevice", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerDevice", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerDevice(args.sessionId, args.migrationPincodeSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerDevice_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerDevice", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerDevice", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clearMessageBox (seqid, input, output) {
    const args = new TalkService_clearMessageBox_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clearMessageBox.length === 2) {
      Promise.resolve(this._handler.clearMessageBox.bind(this._handler)(
        args.channelId,
        args.messageBoxId
      )).then(result => {
        const result_obj = new TalkService_clearMessageBox_result({success: result});
        output.writeMessageBegin("clearMessageBox", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_clearMessageBox_result(err);
          output.writeMessageBegin("clearMessageBox", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clearMessageBox", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clearMessageBox(args.channelId, args.messageBoxId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_clearMessageBox_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clearMessageBox", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clearMessageBox", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_loginWithIdentityCredentialForCertificate (seqid, input, output) {
    const args = new TalkService_loginWithIdentityCredentialForCertificate_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.loginWithIdentityCredentialForCertificate.length === 7) {
      Promise.resolve(this._handler.loginWithIdentityCredentialForCertificate.bind(this._handler)(
        args.identifier,
        args.password,
        args.keepLoggedIn,
        args.accessLocation,
        args.systemName,
        args.identityProvider,
        args.certificate
      )).then(result => {
        const result_obj = new TalkService_loginWithIdentityCredentialForCertificate_result({success: result});
        output.writeMessageBegin("loginWithIdentityCredentialForCertificate", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_loginWithIdentityCredentialForCertificate_result(err);
          output.writeMessageBegin("loginWithIdentityCredentialForCertificate", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithIdentityCredentialForCertificate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.loginWithIdentityCredentialForCertificate(args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.identityProvider, args.certificate, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_loginWithIdentityCredentialForCertificate_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("loginWithIdentityCredentialForCertificate", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithIdentityCredentialForCertificate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getSuggestSettings (seqid, input, output) {
    const args = new TalkService_getSuggestSettings_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getSuggestSettings.length === 1) {
      Promise.resolve(this._handler.getSuggestSettings.bind(this._handler)(
        args.locale
      )).then(result => {
        const result_obj = new TalkService_getSuggestSettings_result({success: result});
        output.writeMessageBegin("getSuggestSettings", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getSuggestSettings_result(err);
          output.writeMessageBegin("getSuggestSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSuggestSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getSuggestSettings(args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getSuggestSettings_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getSuggestSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSuggestSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateAndGetNearby (seqid, input, output) {
    const args = new TalkService_updateAndGetNearby_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateAndGetNearby.length === 2) {
      Promise.resolve(this._handler.updateAndGetNearby.bind(this._handler)(
        args.latitude,
        args.longitude
      )).then(result => {
        const result_obj = new TalkService_updateAndGetNearby_result({success: result});
        output.writeMessageBegin("updateAndGetNearby", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateAndGetNearby_result(err);
          output.writeMessageBegin("updateAndGetNearby", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateAndGetNearby", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateAndGetNearby(args.latitude, args.longitude, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateAndGetNearby_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateAndGetNearby", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateAndGetNearby", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_syncContactBySnsIds (seqid, input, output) {
    const args = new TalkService_syncContactBySnsIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.syncContactBySnsIds.length === 2) {
      Promise.resolve(this._handler.syncContactBySnsIds.bind(this._handler)(
        args.reqSeq,
        args.modifications
      )).then(result => {
        const result_obj = new TalkService_syncContactBySnsIds_result({success: result});
        output.writeMessageBegin("syncContactBySnsIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_syncContactBySnsIds_result(err);
          output.writeMessageBegin("syncContactBySnsIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("syncContactBySnsIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.syncContactBySnsIds(args.reqSeq, args.modifications, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_syncContactBySnsIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("syncContactBySnsIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("syncContactBySnsIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getContacts (seqid, input, output) {
    const args = new TalkService_getContacts_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getContacts.length === 1) {
      Promise.resolve(this._handler.getContacts.bind(this._handler)(
        args.ids
      )).then(result => {
        const result_obj = new TalkService_getContacts_result({success: result});
        output.writeMessageBegin("getContacts", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getContacts_result(err);
          output.writeMessageBegin("getContacts", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getContacts", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getContacts(args.ids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getContacts_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getContacts", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getContacts", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxCompactWrapUpList (seqid, input, output) {
    const args = new TalkService_getMessageBoxCompactWrapUpList_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxCompactWrapUpList.length === 2) {
      Promise.resolve(this._handler.getMessageBoxCompactWrapUpList.bind(this._handler)(
        args.start,
        args.messageBoxCount
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxCompactWrapUpList_result({success: result});
        output.writeMessageBegin("getMessageBoxCompactWrapUpList", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxCompactWrapUpList_result(err);
          output.writeMessageBegin("getMessageBoxCompactWrapUpList", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxCompactWrapUpList", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxCompactWrapUpList(args.start, args.messageBoxCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxCompactWrapUpList_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxCompactWrapUpList", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxCompactWrapUpList", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getProximityMatchCandidates (seqid, input, output) {
    const args = new TalkService_getProximityMatchCandidates_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getProximityMatchCandidates.length === 1) {
      Promise.resolve(this._handler.getProximityMatchCandidates.bind(this._handler)(
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_getProximityMatchCandidates_result({success: result});
        output.writeMessageBegin("getProximityMatchCandidates", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getProximityMatchCandidates_result(err);
          output.writeMessageBegin("getProximityMatchCandidates", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getProximityMatchCandidates", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getProximityMatchCandidates(args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getProximityMatchCandidates_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getProximityMatchCandidates", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getProximityMatchCandidates", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateExtendedProfileAttribute (seqid, input, output) {
    const args = new TalkService_updateExtendedProfileAttribute_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateExtendedProfileAttribute.length === 3) {
      Promise.resolve(this._handler.updateExtendedProfileAttribute.bind(this._handler)(
        args.reqSeq,
        args.attr,
        args.extendedProfile
      )).then(result => {
        const result_obj = new TalkService_updateExtendedProfileAttribute_result({success: result});
        output.writeMessageBegin("updateExtendedProfileAttribute", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateExtendedProfileAttribute_result(err);
          output.writeMessageBegin("updateExtendedProfileAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateExtendedProfileAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateExtendedProfileAttribute(args.reqSeq, args.attr, args.extendedProfile, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateExtendedProfileAttribute_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateExtendedProfileAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateExtendedProfileAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_resendPinCode (seqid, input, output) {
    const args = new TalkService_resendPinCode_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.resendPinCode.length === 1) {
      Promise.resolve(this._handler.resendPinCode.bind(this._handler)(
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_resendPinCode_result({success: result});
        output.writeMessageBegin("resendPinCode", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_resendPinCode_result(err);
          output.writeMessageBegin("resendPinCode", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("resendPinCode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.resendPinCode(args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_resendPinCode_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("resendPinCode", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("resendPinCode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reportSettings (seqid, input, output) {
    const args = new TalkService_reportSettings_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportSettings.length === 2) {
      Promise.resolve(this._handler.reportSettings.bind(this._handler)(
        args.syncOpRevision,
        args.settings
      )).then(result => {
        const result_obj = new TalkService_reportSettings_result({success: result});
        output.writeMessageBegin("reportSettings", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportSettings_result(err);
          output.writeMessageBegin("reportSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportSettings(args.syncOpRevision, args.settings, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportSettings_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerBuddyUserid (seqid, input, output) {
    const args = new TalkService_registerBuddyUserid_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerBuddyUserid.length === 2) {
      Promise.resolve(this._handler.registerBuddyUserid.bind(this._handler)(
        args.seq,
        args.userid
      )).then(result => {
        const result_obj = new TalkService_registerBuddyUserid_result({success: result});
        output.writeMessageBegin("registerBuddyUserid", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerBuddyUserid_result(err);
          output.writeMessageBegin("registerBuddyUserid", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerBuddyUserid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerBuddyUserid(args.seq, args.userid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerBuddyUserid_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerBuddyUserid", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerBuddyUserid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findGroupByTicket (seqid, input, output) {
    const args = new TalkService_findGroupByTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findGroupByTicket.length === 1) {
      Promise.resolve(this._handler.findGroupByTicket.bind(this._handler)(
        args.ticketId
      )).then(result => {
        const result_obj = new TalkService_findGroupByTicket_result({success: result});
        output.writeMessageBegin("findGroupByTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findGroupByTicket_result(err);
          output.writeMessageBegin("findGroupByTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findGroupByTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findGroupByTicket(args.ticketId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findGroupByTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findGroupByTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findGroupByTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerDeviceWithIdentityCredential (seqid, input, output) {
    const args = new TalkService_registerDeviceWithIdentityCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerDeviceWithIdentityCredential.length === 5) {
      Promise.resolve(this._handler.registerDeviceWithIdentityCredential.bind(this._handler)(
        args.sessionId,
        args.identifier,
        args.verifier,
        args.provider,
        args.migrationPincodeSessionId
      )).then(result => {
        const result_obj = new TalkService_registerDeviceWithIdentityCredential_result({success: result});
        output.writeMessageBegin("registerDeviceWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerDeviceWithIdentityCredential_result(err);
          output.writeMessageBegin("registerDeviceWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerDeviceWithIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerDeviceWithIdentityCredential(args.sessionId, args.identifier, args.verifier, args.provider, args.migrationPincodeSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerDeviceWithIdentityCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerDeviceWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerDeviceWithIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_invalidateUserTicket (seqid, input, output) {
    const args = new TalkService_invalidateUserTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.invalidateUserTicket.length === 0) {
      Promise.resolve(this._handler.invalidateUserTicket.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_invalidateUserTicket_result({success: result});
        output.writeMessageBegin("invalidateUserTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_invalidateUserTicket_result(err);
          output.writeMessageBegin("invalidateUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("invalidateUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.invalidateUserTicket((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_invalidateUserTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("invalidateUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("invalidateUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendEvent (seqid, input, output) {
    const args = new TalkService_sendEvent_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendEvent.length === 2) {
      Promise.resolve(this._handler.sendEvent.bind(this._handler)(
        args.seq,
        args.message
      )).then(result => {
        const result_obj = new TalkService_sendEvent_result({success: result});
        output.writeMessageBegin("sendEvent", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendEvent_result(err);
          output.writeMessageBegin("sendEvent", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendEvent", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendEvent(args.seq, args.message, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendEvent_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendEvent", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendEvent", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendMessageToMyHome (seqid, input, output) {
    const args = new TalkService_sendMessageToMyHome_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendMessageToMyHome.length === 2) {
      Promise.resolve(this._handler.sendMessageToMyHome.bind(this._handler)(
        args.seq,
        args.message
      )).then(result => {
        const result_obj = new TalkService_sendMessageToMyHome_result({success: result});
        output.writeMessageBegin("sendMessageToMyHome", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendMessageToMyHome_result(err);
          output.writeMessageBegin("sendMessageToMyHome", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessageToMyHome", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendMessageToMyHome(args.seq, args.message, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendMessageToMyHome_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendMessageToMyHome", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessageToMyHome", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendContentPreviewUpdated (seqid, input, output) {
    const args = new TalkService_sendContentPreviewUpdated_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendContentPreviewUpdated.length === 3) {
      Promise.resolve(this._handler.sendContentPreviewUpdated.bind(this._handler)(
        args.esq,
        args.messageId,
        args.receiverMids
      )).then(result => {
        const result_obj = new TalkService_sendContentPreviewUpdated_result({success: result});
        output.writeMessageBegin("sendContentPreviewUpdated", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendContentPreviewUpdated_result(err);
          output.writeMessageBegin("sendContentPreviewUpdated", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendContentPreviewUpdated", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendContentPreviewUpdated(args.esq, args.messageId, args.receiverMids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendContentPreviewUpdated_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendContentPreviewUpdated", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendContentPreviewUpdated", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_loginWithVerifier (seqid, input, output) {
    const args = new TalkService_loginWithVerifier_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.loginWithVerifier.length === 1) {
      Promise.resolve(this._handler.loginWithVerifier.bind(this._handler)(
        args.verifier
      )).then(result => {
        const result_obj = new TalkService_loginWithVerifier_result({success: result});
        output.writeMessageBegin("loginWithVerifier", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_loginWithVerifier_result(err);
          output.writeMessageBegin("loginWithVerifier", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithVerifier", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.loginWithVerifier(args.verifier, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_loginWithVerifier_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("loginWithVerifier", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithVerifier", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_removeBuddySubscriptionAndNotifyBuddyUnregistered (seqid, input, output) {
    const args = new TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.removeBuddySubscriptionAndNotifyBuddyUnregistered.length === 1) {
      Promise.resolve(this._handler.removeBuddySubscriptionAndNotifyBuddyUnregistered.bind(this._handler)(
        args.subscriberMids
      )).then(result => {
        const result_obj = new TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_result({success: result});
        output.writeMessageBegin("removeBuddySubscriptionAndNotifyBuddyUnregistered", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_result(err);
          output.writeMessageBegin("removeBuddySubscriptionAndNotifyBuddyUnregistered", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeBuddySubscriptionAndNotifyBuddyUnregistered", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.removeBuddySubscriptionAndNotifyBuddyUnregistered(args.subscriberMids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_removeBuddySubscriptionAndNotifyBuddyUnregistered_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("removeBuddySubscriptionAndNotifyBuddyUnregistered", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeBuddySubscriptionAndNotifyBuddyUnregistered", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_unblockContact (seqid, input, output) {
    const args = new TalkService_unblockContact_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.unblockContact.length === 3) {
      Promise.resolve(this._handler.unblockContact.bind(this._handler)(
        args.reqSeq,
        args.id,
        args.reference
      )).then(result => {
        const result_obj = new TalkService_unblockContact_result({success: result});
        output.writeMessageBegin("unblockContact", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_unblockContact_result(err);
          output.writeMessageBegin("unblockContact", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unblockContact", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.unblockContact(args.reqSeq, args.id, args.reference, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_unblockContact_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("unblockContact", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unblockContact", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_removeBuddyLocation (seqid, input, output) {
    const args = new TalkService_removeBuddyLocation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.removeBuddyLocation.length === 2) {
      Promise.resolve(this._handler.removeBuddyLocation.bind(this._handler)(
        args.mid,
        args.index
      )).then(result => {
        const result_obj = new TalkService_removeBuddyLocation_result({success: result});
        output.writeMessageBegin("removeBuddyLocation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_removeBuddyLocation_result(err);
          output.writeMessageBegin("removeBuddyLocation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeBuddyLocation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.removeBuddyLocation(args.mid, args.index, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_removeBuddyLocation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("removeBuddyLocation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeBuddyLocation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRingbackTone (seqid, input, output) {
    const args = new TalkService_getRingbackTone_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRingbackTone.length === 0) {
      Promise.resolve(this._handler.getRingbackTone.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getRingbackTone_result({success: result});
        output.writeMessageBegin("getRingbackTone", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRingbackTone_result(err);
          output.writeMessageBegin("getRingbackTone", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRingbackTone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRingbackTone((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRingbackTone_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRingbackTone", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRingbackTone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getConfigurations (seqid, input, output) {
    const args = new TalkService_getConfigurations_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getConfigurations.length === 5) {
      Promise.resolve(this._handler.getConfigurations.bind(this._handler)(
        args.revision,
        args.regionOfUsim,
        args.regionOfTelephone,
        args.regionOfLocale,
        args.carrier
      )).then(result => {
        const result_obj = new TalkService_getConfigurations_result({success: result});
        output.writeMessageBegin("getConfigurations", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getConfigurations_result(err);
          output.writeMessageBegin("getConfigurations", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getConfigurations", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getConfigurations(args.revision, args.regionOfUsim, args.regionOfTelephone, args.regionOfLocale, args.carrier, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getConfigurations_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getConfigurations", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getConfigurations", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getProximityMatchCandidateList (seqid, input, output) {
    const args = new TalkService_getProximityMatchCandidateList_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getProximityMatchCandidateList.length === 1) {
      Promise.resolve(this._handler.getProximityMatchCandidateList.bind(this._handler)(
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_getProximityMatchCandidateList_result({success: result});
        output.writeMessageBegin("getProximityMatchCandidateList", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getProximityMatchCandidateList_result(err);
          output.writeMessageBegin("getProximityMatchCandidateList", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getProximityMatchCandidateList", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getProximityMatchCandidateList(args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getProximityMatchCandidateList_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getProximityMatchCandidateList", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getProximityMatchCandidateList", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_requestAccountPasswordReset (seqid, input, output) {
    const args = new TalkService_requestAccountPasswordReset_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.requestAccountPasswordReset.length === 3) {
      Promise.resolve(this._handler.requestAccountPasswordReset.bind(this._handler)(
        args.identifier,
        args.provider,
        args.locale
      )).then(result => {
        const result_obj = new TalkService_requestAccountPasswordReset_result({success: result});
        output.writeMessageBegin("requestAccountPasswordReset", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_requestAccountPasswordReset_result(err);
          output.writeMessageBegin("requestAccountPasswordReset", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestAccountPasswordReset", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.requestAccountPasswordReset(args.identifier, args.provider, args.locale, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_requestAccountPasswordReset_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("requestAccountPasswordReset", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestAccountPasswordReset", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getNextMessages (seqid, input, output) {
    const args = new TalkService_getNextMessages_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getNextMessages.length === 3) {
      Promise.resolve(this._handler.getNextMessages.bind(this._handler)(
        args.messageBoxId,
        args.startSeq,
        args.messagesCount
      )).then(result => {
        const result_obj = new TalkService_getNextMessages_result({success: result});
        output.writeMessageBegin("getNextMessages", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getNextMessages_result(err);
          output.writeMessageBegin("getNextMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getNextMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getNextMessages(args.messageBoxId, args.startSeq, args.messagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getNextMessages_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getNextMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getNextMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reportProfile (seqid, input, output) {
    const args = new TalkService_reportProfile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportProfile.length === 2) {
      Promise.resolve(this._handler.reportProfile.bind(this._handler)(
        args.syncOpRevision,
        args.profile
      )).then(result => {
        const result_obj = new TalkService_reportProfile_result({success: result});
        output.writeMessageBegin("reportProfile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportProfile_result(err);
          output.writeMessageBegin("reportProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportProfile(args.syncOpRevision, args.profile, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportProfile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getCompactRoom (seqid, input, output) {
    const args = new TalkService_getCompactRoom_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getCompactRoom.length === 1) {
      Promise.resolve(this._handler.getCompactRoom.bind(this._handler)(
        args.roomId
      )).then(result => {
        const result_obj = new TalkService_getCompactRoom_result({success: result});
        output.writeMessageBegin("getCompactRoom", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getCompactRoom_result(err);
          output.writeMessageBegin("getCompactRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getCompactRoom(args.roomId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getCompactRoom_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getCompactRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getLastOpRevision (seqid, input, output) {
    const args = new TalkService_getLastOpRevision_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getLastOpRevision.length === 0) {
      Promise.resolve(this._handler.getLastOpRevision.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getLastOpRevision_result({success: result});
        output.writeMessageBegin("getLastOpRevision", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getLastOpRevision_result(err);
          output.writeMessageBegin("getLastOpRevision", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getLastOpRevision", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getLastOpRevision((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getLastOpRevision_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getLastOpRevision", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getLastOpRevision", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getPreviousMessagesV2 (seqid, input, output) {
    const args = new TalkService_getPreviousMessagesV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getPreviousMessagesV2.length === 3) {
      Promise.resolve(this._handler.getPreviousMessagesV2.bind(this._handler)(
        args.messageBoxId,
        args.endMessageId,
        args.messagesCount
      )).then(result => {
        const result_obj = new TalkService_getPreviousMessagesV2_result({success: result});
        output.writeMessageBegin("getPreviousMessagesV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getPreviousMessagesV2_result(err);
          output.writeMessageBegin("getPreviousMessagesV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getPreviousMessagesV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getPreviousMessagesV2(args.messageBoxId, args.endMessageId, args.messagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getPreviousMessagesV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getPreviousMessagesV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getPreviousMessagesV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_fetchAnnouncements (seqid, input, output) {
    const args = new TalkService_fetchAnnouncements_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.fetchAnnouncements.length === 1) {
      Promise.resolve(this._handler.fetchAnnouncements.bind(this._handler)(
        args.lastFetchedIndex
      )).then(result => {
        const result_obj = new TalkService_fetchAnnouncements_result({success: result});
        output.writeMessageBegin("fetchAnnouncements", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_fetchAnnouncements_result(err);
          output.writeMessageBegin("fetchAnnouncements", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("fetchAnnouncements", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.fetchAnnouncements(args.lastFetchedIndex, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_fetchAnnouncements_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("fetchAnnouncements", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("fetchAnnouncements", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_acquireCallRoute (seqid, input, output) {
    const args = new TalkService_acquireCallRoute_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.acquireCallRoute.length === 1) {
      Promise.resolve(this._handler.acquireCallRoute.bind(this._handler)(
        args.to
      )).then(result => {
        const result_obj = new TalkService_acquireCallRoute_result({success: result});
        output.writeMessageBegin("acquireCallRoute", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_acquireCallRoute_result(err);
          output.writeMessageBegin("acquireCallRoute", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acquireCallRoute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.acquireCallRoute(args.to, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_acquireCallRoute_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("acquireCallRoute", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acquireCallRoute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateSettingsAttribute (seqid, input, output) {
    const args = new TalkService_updateSettingsAttribute_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateSettingsAttribute.length === 3) {
      Promise.resolve(this._handler.updateSettingsAttribute.bind(this._handler)(
        args.reqSeq,
        args.attr,
        args.value
      )).then(result => {
        const result_obj = new TalkService_updateSettingsAttribute_result({success: result});
        output.writeMessageBegin("updateSettingsAttribute", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateSettingsAttribute_result(err);
          output.writeMessageBegin("updateSettingsAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateSettingsAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateSettingsAttribute(args.reqSeq, args.attr, args.value, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateSettingsAttribute_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateSettingsAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateSettingsAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_createGroupV2 (seqid, input, output) {
    const args = new TalkService_createGroupV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.createGroupV2.length === 3) {
      Promise.resolve(this._handler.createGroupV2.bind(this._handler)(
        args.seq,
        args.name,
        args.contactIds
      )).then(result => {
        const result_obj = new TalkService_createGroupV2_result({success: result});
        output.writeMessageBegin("createGroupV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_createGroupV2_result(err);
          output.writeMessageBegin("createGroupV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createGroupV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.createGroupV2(args.seq, args.name, args.contactIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_createGroupV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("createGroupV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createGroupV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_isIdentityIdentifierAvailable (seqid, input, output) {
    const args = new TalkService_isIdentityIdentifierAvailable_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.isIdentityIdentifierAvailable.length === 2) {
      Promise.resolve(this._handler.isIdentityIdentifierAvailable.bind(this._handler)(
        args.identifier,
        args.provider
      )).then(result => {
        const result_obj = new TalkService_isIdentityIdentifierAvailable_result({success: result});
        output.writeMessageBegin("isIdentityIdentifierAvailable", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_isIdentityIdentifierAvailable_result(err);
          output.writeMessageBegin("isIdentityIdentifierAvailable", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("isIdentityIdentifierAvailable", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.isIdentityIdentifierAvailable(args.identifier, args.provider, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_isIdentityIdentifierAvailable_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("isIdentityIdentifierAvailable", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("isIdentityIdentifierAvailable", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_blockContact (seqid, input, output) {
    const args = new TalkService_blockContact_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.blockContact.length === 2) {
      Promise.resolve(this._handler.blockContact.bind(this._handler)(
        args.reqSeq,
        args.id
      )).then(result => {
        const result_obj = new TalkService_blockContact_result({success: result});
        output.writeMessageBegin("blockContact", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_blockContact_result(err);
          output.writeMessageBegin("blockContact", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("blockContact", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.blockContact(args.reqSeq, args.id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_blockContact_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("blockContact", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("blockContact", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_commitUpdateProfile (seqid, input, output) {
    const args = new TalkService_commitUpdateProfile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.commitUpdateProfile.length === 3) {
      Promise.resolve(this._handler.commitUpdateProfile.bind(this._handler)(
        args.seq,
        args.attrs,
        args.receiverMids
      )).then(result => {
        const result_obj = new TalkService_commitUpdateProfile_result({success: result});
        output.writeMessageBegin("commitUpdateProfile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_commitUpdateProfile_result(err);
          output.writeMessageBegin("commitUpdateProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("commitUpdateProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.commitUpdateProfile(args.seq, args.attrs, args.receiverMids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_commitUpdateProfile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("commitUpdateProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("commitUpdateProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerWithSnsId (seqid, input, output) {
    const args = new TalkService_registerWithSnsId_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerWithSnsId.length === 7) {
      Promise.resolve(this._handler.registerWithSnsId.bind(this._handler)(
        args.snsIdType,
        args.snsAccessToken,
        args.region,
        args.udidHash,
        args.deviceInfo,
        args.mid,
        args.migrationPincodeSessionId
      )).then(result => {
        const result_obj = new TalkService_registerWithSnsId_result({success: result});
        output.writeMessageBegin("registerWithSnsId", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerWithSnsId_result(err);
          output.writeMessageBegin("registerWithSnsId", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithSnsId", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerWithSnsId(args.snsIdType, args.snsAccessToken, args.region, args.udidHash, args.deviceInfo, args.mid, args.migrationPincodeSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerWithSnsId_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerWithSnsId", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithSnsId", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updatePublicKeychain (seqid, input, output) {
    const args = new TalkService_updatePublicKeychain_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updatePublicKeychain.length === 1) {
      Promise.resolve(this._handler.updatePublicKeychain.bind(this._handler)(
        args.publicKeychain
      )).then(result => {
        const result_obj = new TalkService_updatePublicKeychain_result({success: result});
        output.writeMessageBegin("updatePublicKeychain", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updatePublicKeychain_result(err);
          output.writeMessageBegin("updatePublicKeychain", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updatePublicKeychain", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updatePublicKeychain(args.publicKeychain, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updatePublicKeychain_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updatePublicKeychain", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updatePublicKeychain", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_loginWithVerifierForCerificate (seqid, input, output) {
    const args = new TalkService_loginWithVerifierForCerificate_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.loginWithVerifierForCerificate.length === 1) {
      Promise.resolve(this._handler.loginWithVerifierForCerificate.bind(this._handler)(
        args.verifier
      )).then(result => {
        const result_obj = new TalkService_loginWithVerifierForCerificate_result({success: result});
        output.writeMessageBegin("loginWithVerifierForCerificate", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_loginWithVerifierForCerificate_result(err);
          output.writeMessageBegin("loginWithVerifierForCerificate", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithVerifierForCerificate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.loginWithVerifierForCerificate(args.verifier, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_loginWithVerifierForCerificate_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("loginWithVerifierForCerificate", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithVerifierForCerificate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_tryFriendRequest (seqid, input, output) {
    const args = new TalkService_tryFriendRequest_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.tryFriendRequest.length === 3) {
      Promise.resolve(this._handler.tryFriendRequest.bind(this._handler)(
        args.midOrEMid,
        args.method,
        args.friendRequestParams
      )).then(result => {
        const result_obj = new TalkService_tryFriendRequest_result({success: result});
        output.writeMessageBegin("tryFriendRequest", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_tryFriendRequest_result(err);
          output.writeMessageBegin("tryFriendRequest", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("tryFriendRequest", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.tryFriendRequest(args.midOrEMid, args.method, args.friendRequestParams, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_tryFriendRequest_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("tryFriendRequest", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("tryFriendRequest", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getBlockedRecommendationIds (seqid, input, output) {
    const args = new TalkService_getBlockedRecommendationIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getBlockedRecommendationIds.length === 0) {
      Promise.resolve(this._handler.getBlockedRecommendationIds.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getBlockedRecommendationIds_result({success: result});
        output.writeMessageBegin("getBlockedRecommendationIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getBlockedRecommendationIds_result(err);
          output.writeMessageBegin("getBlockedRecommendationIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBlockedRecommendationIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getBlockedRecommendationIds((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getBlockedRecommendationIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getBlockedRecommendationIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBlockedRecommendationIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getGroupIdsInvited (seqid, input, output) {
    const args = new TalkService_getGroupIdsInvited_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getGroupIdsInvited.length === 0) {
      Promise.resolve(this._handler.getGroupIdsInvited.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getGroupIdsInvited_result({success: result});
        output.writeMessageBegin("getGroupIdsInvited", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getGroupIdsInvited_result(err);
          output.writeMessageBegin("getGroupIdsInvited", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroupIdsInvited", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getGroupIdsInvited((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getGroupIdsInvited_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getGroupIdsInvited", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroupIdsInvited", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getSuggestIncrements (seqid, input, output) {
    const args = new TalkService_getSuggestIncrements_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getSuggestIncrements.length === 1) {
      Promise.resolve(this._handler.getSuggestIncrements.bind(this._handler)(
        args.revisions
      )).then(result => {
        const result_obj = new TalkService_getSuggestIncrements_result({success: result});
        output.writeMessageBegin("getSuggestIncrements", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getSuggestIncrements_result(err);
          output.writeMessageBegin("getSuggestIncrements", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSuggestIncrements", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getSuggestIncrements(args.revisions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getSuggestIncrements_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getSuggestIncrements", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSuggestIncrements", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_resendPinCodeBySMS (seqid, input, output) {
    const args = new TalkService_resendPinCodeBySMS_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.resendPinCodeBySMS.length === 1) {
      Promise.resolve(this._handler.resendPinCodeBySMS.bind(this._handler)(
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_resendPinCodeBySMS_result({success: result});
        output.writeMessageBegin("resendPinCodeBySMS", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_resendPinCodeBySMS_result(err);
          output.writeMessageBegin("resendPinCodeBySMS", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("resendPinCodeBySMS", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.resendPinCodeBySMS(args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_resendPinCodeBySMS_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("resendPinCodeBySMS", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("resendPinCodeBySMS", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerWithPhoneNumber (seqid, input, output) {
    const args = new TalkService_registerWithPhoneNumber_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerWithPhoneNumber.length === 2) {
      Promise.resolve(this._handler.registerWithPhoneNumber.bind(this._handler)(
        args.sessionId,
        args.migrationPincodeSessionId
      )).then(result => {
        const result_obj = new TalkService_registerWithPhoneNumber_result({success: result});
        output.writeMessageBegin("registerWithPhoneNumber", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerWithPhoneNumber_result(err);
          output.writeMessageBegin("registerWithPhoneNumber", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithPhoneNumber", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerWithPhoneNumber(args.sessionId, args.migrationPincodeSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerWithPhoneNumber_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerWithPhoneNumber", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithPhoneNumber", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getActiveBuddySubscriberIds (seqid, input, output) {
    const args = new TalkService_getActiveBuddySubscriberIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getActiveBuddySubscriberIds.length === 0) {
      Promise.resolve(this._handler.getActiveBuddySubscriberIds.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getActiveBuddySubscriberIds_result({success: result});
        output.writeMessageBegin("getActiveBuddySubscriberIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getActiveBuddySubscriberIds_result(err);
          output.writeMessageBegin("getActiveBuddySubscriberIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getActiveBuddySubscriberIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getActiveBuddySubscriberIds((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getActiveBuddySubscriberIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getActiveBuddySubscriberIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getActiveBuddySubscriberIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_createRoom (seqid, input, output) {
    const args = new TalkService_createRoom_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.createRoom.length === 2) {
      Promise.resolve(this._handler.createRoom.bind(this._handler)(
        args.reqSeq,
        args.contactIds
      )).then(result => {
        const result_obj = new TalkService_createRoom_result({success: result});
        output.writeMessageBegin("createRoom", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_createRoom_result(err);
          output.writeMessageBegin("createRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.createRoom(args.reqSeq, args.contactIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_createRoom_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("createRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_verifyPhoneNumberForLogin (seqid, input, output) {
    const args = new TalkService_verifyPhoneNumberForLogin_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.verifyPhoneNumberForLogin.length === 3) {
      Promise.resolve(this._handler.verifyPhoneNumberForLogin.bind(this._handler)(
        args.verifierFromPhone,
        args.pinCodeForPhone,
        args.verifierFromLogin
      )).then(result => {
        const result_obj = new TalkService_verifyPhoneNumberForLogin_result({success: result});
        output.writeMessageBegin("verifyPhoneNumberForLogin", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_verifyPhoneNumberForLogin_result(err);
          output.writeMessageBegin("verifyPhoneNumberForLogin", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyPhoneNumberForLogin", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.verifyPhoneNumberForLogin(args.verifierFromPhone, args.pinCodeForPhone, args.verifierFromLogin, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_verifyPhoneNumberForLogin_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("verifyPhoneNumberForLogin", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyPhoneNumberForLogin", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_addSnsId (seqid, input, output) {
    const args = new TalkService_addSnsId_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.addSnsId.length === 2) {
      Promise.resolve(this._handler.addSnsId.bind(this._handler)(
        args.snsIdType,
        args.snsAccessToken
      )).then(result => {
        const result_obj = new TalkService_addSnsId_result({success: result});
        output.writeMessageBegin("addSnsId", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_addSnsId_result(err);
          output.writeMessageBegin("addSnsId", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("addSnsId", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.addSnsId(args.snsIdType, args.snsAccessToken, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_addSnsId_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("addSnsId", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("addSnsId", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_finishUpdateVerification (seqid, input, output) {
    const args = new TalkService_finishUpdateVerification_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.finishUpdateVerification.length === 1) {
      Promise.resolve(this._handler.finishUpdateVerification.bind(this._handler)(
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_finishUpdateVerification_result({success: result});
        output.writeMessageBegin("finishUpdateVerification", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_finishUpdateVerification_result(err);
          output.writeMessageBegin("finishUpdateVerification", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("finishUpdateVerification", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.finishUpdateVerification(args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_finishUpdateVerification_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("finishUpdateVerification", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("finishUpdateVerification", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_validateContactsOnBot (seqid, input, output) {
    const args = new TalkService_validateContactsOnBot_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.validateContactsOnBot.length === 1) {
      Promise.resolve(this._handler.validateContactsOnBot.bind(this._handler)(
        args.contacts
      )).then(result => {
        const result_obj = new TalkService_validateContactsOnBot_result({success: result});
        output.writeMessageBegin("validateContactsOnBot", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_validateContactsOnBot_result(err);
          output.writeMessageBegin("validateContactsOnBot", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("validateContactsOnBot", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.validateContactsOnBot(args.contacts, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_validateContactsOnBot_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("validateContactsOnBot", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("validateContactsOnBot", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRoom (seqid, input, output) {
    const args = new TalkService_getRoom_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRoom.length === 1) {
      Promise.resolve(this._handler.getRoom.bind(this._handler)(
        args.roomId
      )).then(result => {
        const result_obj = new TalkService_getRoom_result({success: result});
        output.writeMessageBegin("getRoom", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRoom_result(err);
          output.writeMessageBegin("getRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRoom(args.roomId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRoom_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_closeProximityMatch (seqid, input, output) {
    const args = new TalkService_closeProximityMatch_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.closeProximityMatch.length === 1) {
      Promise.resolve(this._handler.closeProximityMatch.bind(this._handler)(
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_closeProximityMatch_result({success: result});
        output.writeMessageBegin("closeProximityMatch", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_closeProximityMatch_result(err);
          output.writeMessageBegin("closeProximityMatch", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("closeProximityMatch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.closeProximityMatch(args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_closeProximityMatch_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("closeProximityMatch", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("closeProximityMatch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getCompactGroup (seqid, input, output) {
    const args = new TalkService_getCompactGroup_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getCompactGroup.length === 1) {
      Promise.resolve(this._handler.getCompactGroup.bind(this._handler)(
        args.groupId
      )).then(result => {
        const result_obj = new TalkService_getCompactGroup_result({success: result});
        output.writeMessageBegin("getCompactGroup", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getCompactGroup_result(err);
          output.writeMessageBegin("getCompactGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getCompactGroup(args.groupId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getCompactGroup_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getCompactGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getBlockedContactIdsByRange (seqid, input, output) {
    const args = new TalkService_getBlockedContactIdsByRange_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getBlockedContactIdsByRange.length === 2) {
      Promise.resolve(this._handler.getBlockedContactIdsByRange.bind(this._handler)(
        args.start,
        args.count
      )).then(result => {
        const result_obj = new TalkService_getBlockedContactIdsByRange_result({success: result});
        output.writeMessageBegin("getBlockedContactIdsByRange", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getBlockedContactIdsByRange_result(err);
          output.writeMessageBegin("getBlockedContactIdsByRange", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBlockedContactIdsByRange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getBlockedContactIdsByRange(args.start, args.count, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getBlockedContactIdsByRange_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getBlockedContactIdsByRange", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBlockedContactIdsByRange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRecentMessagesV2 (seqid, input, output) {
    const args = new TalkService_getRecentMessagesV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRecentMessagesV2.length === 2) {
      Promise.resolve(this._handler.getRecentMessagesV2.bind(this._handler)(
        args.messageBoxId,
        args.messagesCount
      )).then(result => {
        const result_obj = new TalkService_getRecentMessagesV2_result({success: result});
        output.writeMessageBegin("getRecentMessagesV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRecentMessagesV2_result(err);
          output.writeMessageBegin("getRecentMessagesV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRecentMessagesV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRecentMessagesV2(args.messageBoxId, args.messagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRecentMessagesV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRecentMessagesV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRecentMessagesV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reissueUserTicket (seqid, input, output) {
    const args = new TalkService_reissueUserTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reissueUserTicket.length === 2) {
      Promise.resolve(this._handler.reissueUserTicket.bind(this._handler)(
        args.expirationTime,
        args.maxUseCount
      )).then(result => {
        const result_obj = new TalkService_reissueUserTicket_result({success: result});
        output.writeMessageBegin("reissueUserTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reissueUserTicket_result(err);
          output.writeMessageBegin("reissueUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reissueUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reissueUserTicket(args.expirationTime, args.maxUseCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reissueUserTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reissueUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reissueUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageReadRange (seqid, input, output) {
    const args = new TalkService_getMessageReadRange_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageReadRange.length === 1) {
      Promise.resolve(this._handler.getMessageReadRange.bind(this._handler)(
        args.chatIds
      )).then(result => {
        const result_obj = new TalkService_getMessageReadRange_result({success: result});
        output.writeMessageBegin("getMessageReadRange", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageReadRange_result(err);
          output.writeMessageBegin("getMessageReadRange", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageReadRange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageReadRange(args.chatIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageReadRange_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageReadRange", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageReadRange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clearRingbackTone (seqid, input, output) {
    const args = new TalkService_clearRingbackTone_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clearRingbackTone.length === 0) {
      Promise.resolve(this._handler.clearRingbackTone.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_clearRingbackTone_result({success: result});
        output.writeMessageBegin("clearRingbackTone", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_clearRingbackTone_result(err);
          output.writeMessageBegin("clearRingbackTone", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clearRingbackTone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clearRingbackTone((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_clearRingbackTone_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clearRingbackTone", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clearRingbackTone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_setIdentityCredential (seqid, input, output) {
    const args = new TalkService_setIdentityCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.setIdentityCredential.length === 3) {
      Promise.resolve(this._handler.setIdentityCredential.bind(this._handler)(
        args.identifier,
        args.verifier,
        args.provider
      )).then(result => {
        const result_obj = new TalkService_setIdentityCredential_result({success: result});
        output.writeMessageBegin("setIdentityCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_setIdentityCredential_result(err);
          output.writeMessageBegin("setIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("setIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.setIdentityCredential(args.identifier, args.verifier, args.provider, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_setIdentityCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("setIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("setIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxCompactWrapUpV2 (seqid, input, output) {
    const args = new TalkService_getMessageBoxCompactWrapUpV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxCompactWrapUpV2.length === 1) {
      Promise.resolve(this._handler.getMessageBoxCompactWrapUpV2.bind(this._handler)(
        args.messageBoxId
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxCompactWrapUpV2_result({success: result});
        output.writeMessageBegin("getMessageBoxCompactWrapUpV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxCompactWrapUpV2_result(err);
          output.writeMessageBegin("getMessageBoxCompactWrapUpV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxCompactWrapUpV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxCompactWrapUpV2(args.messageBoxId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxCompactWrapUpV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxCompactWrapUpV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxCompactWrapUpV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getServerTime (seqid, input, output) {
    const args = new TalkService_getServerTime_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getServerTime.length === 0) {
      Promise.resolve(this._handler.getServerTime.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getServerTime_result({success: result});
        output.writeMessageBegin("getServerTime", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getServerTime_result(err);
          output.writeMessageBegin("getServerTime", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getServerTime", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getServerTime((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getServerTime_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getServerTime", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getServerTime", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_trySendMessage (seqid, input, output) {
    const args = new TalkService_trySendMessage_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.trySendMessage.length === 2) {
      Promise.resolve(this._handler.trySendMessage.bind(this._handler)(
        args.seq,
        args.message
      )).then(result => {
        const result_obj = new TalkService_trySendMessage_result({success: result});
        output.writeMessageBegin("trySendMessage", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_trySendMessage_result(err);
          output.writeMessageBegin("trySendMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("trySendMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.trySendMessage(args.seq, args.message, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_trySendMessage_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("trySendMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("trySendMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getNextMessagesV2 (seqid, input, output) {
    const args = new TalkService_getNextMessagesV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getNextMessagesV2.length === 3) {
      Promise.resolve(this._handler.getNextMessagesV2.bind(this._handler)(
        args.messageBoxId,
        args.startMessageId,
        args.messagesCount
      )).then(result => {
        const result_obj = new TalkService_getNextMessagesV2_result({success: result});
        output.writeMessageBegin("getNextMessagesV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getNextMessagesV2_result(err);
          output.writeMessageBegin("getNextMessagesV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getNextMessagesV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getNextMessagesV2(args.messageBoxId, args.startMessageId, args.messagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getNextMessagesV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getNextMessagesV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getNextMessagesV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifySleep (seqid, input, output) {
    const args = new TalkService_notifySleep_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifySleep.length === 2) {
      Promise.resolve(this._handler.notifySleep.bind(this._handler)(
        args.lastRev,
        args.badge
      )).then(result => {
        const result_obj = new TalkService_notifySleep_result({success: result});
        output.writeMessageBegin("notifySleep", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_notifySleep_result(err);
          output.writeMessageBegin("notifySleep", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifySleep", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifySleep(args.lastRev, args.badge, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_notifySleep_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifySleep", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifySleep", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getBuddyBlockerIds (seqid, input, output) {
    const args = new TalkService_getBuddyBlockerIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getBuddyBlockerIds.length === 0) {
      Promise.resolve(this._handler.getBuddyBlockerIds.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getBuddyBlockerIds_result({success: result});
        output.writeMessageBegin("getBuddyBlockerIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getBuddyBlockerIds_result(err);
          output.writeMessageBegin("getBuddyBlockerIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBuddyBlockerIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getBuddyBlockerIds((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getBuddyBlockerIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getBuddyBlockerIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBuddyBlockerIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_removeE2EEPublicKey (seqid, input, output) {
    const args = new TalkService_removeE2EEPublicKey_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.removeE2EEPublicKey.length === 1) {
      Promise.resolve(this._handler.removeE2EEPublicKey.bind(this._handler)(
        args.publicKey
      )).then(result => {
        const result_obj = new TalkService_removeE2EEPublicKey_result({success: result});
        output.writeMessageBegin("removeE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_removeE2EEPublicKey_result(err);
          output.writeMessageBegin("removeE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeE2EEPublicKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.removeE2EEPublicKey(args.publicKey, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_removeE2EEPublicKey_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("removeE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeE2EEPublicKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reissueTrackingTicket (seqid, input, output) {
    const args = new TalkService_reissueTrackingTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reissueTrackingTicket.length === 1) {
      Promise.resolve(this._handler.reissueTrackingTicket.bind(this._handler)(
        args.type
      )).then(result => {
        const result_obj = new TalkService_reissueTrackingTicket_result({success: result});
        output.writeMessageBegin("reissueTrackingTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reissueTrackingTicket_result(err);
          output.writeMessageBegin("reissueTrackingTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reissueTrackingTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reissueTrackingTicket(args.type, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reissueTrackingTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reissueTrackingTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reissueTrackingTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_cancelGroupInvitation (seqid, input, output) {
    const args = new TalkService_cancelGroupInvitation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.cancelGroupInvitation.length === 3) {
      Promise.resolve(this._handler.cancelGroupInvitation.bind(this._handler)(
        args.reqSeq,
        args.groupId,
        args.contactIds
      )).then(result => {
        const result_obj = new TalkService_cancelGroupInvitation_result({success: result});
        output.writeMessageBegin("cancelGroupInvitation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_cancelGroupInvitation_result(err);
          output.writeMessageBegin("cancelGroupInvitation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("cancelGroupInvitation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.cancelGroupInvitation(args.reqSeq, args.groupId, args.contactIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_cancelGroupInvitation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("cancelGroupInvitation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("cancelGroupInvitation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_removeMessage (seqid, input, output) {
    const args = new TalkService_removeMessage_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.removeMessage.length === 1) {
      Promise.resolve(this._handler.removeMessage.bind(this._handler)(
        args.messageId
      )).then(result => {
        const result_obj = new TalkService_removeMessage_result({success: result});
        output.writeMessageBegin("removeMessage", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_removeMessage_result(err);
          output.writeMessageBegin("removeMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.removeMessage(args.messageId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_removeMessage_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("removeMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getAllReadMessageOps (seqid, input, output) {
    const args = new TalkService_getAllReadMessageOps_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getAllReadMessageOps.length === 0) {
      Promise.resolve(this._handler.getAllReadMessageOps.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getAllReadMessageOps_result({success: result});
        output.writeMessageBegin("getAllReadMessageOps", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getAllReadMessageOps_result(err);
          output.writeMessageBegin("getAllReadMessageOps", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAllReadMessageOps", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getAllReadMessageOps((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getAllReadMessageOps_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getAllReadMessageOps", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAllReadMessageOps", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_unregisterUserAndDevice (seqid, input, output) {
    const args = new TalkService_unregisterUserAndDevice_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.unregisterUserAndDevice.length === 0) {
      Promise.resolve(this._handler.unregisterUserAndDevice.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_unregisterUserAndDevice_result({success: result});
        output.writeMessageBegin("unregisterUserAndDevice", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_unregisterUserAndDevice_result(err);
          output.writeMessageBegin("unregisterUserAndDevice", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unregisterUserAndDevice", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.unregisterUserAndDevice((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_unregisterUserAndDevice_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("unregisterUserAndDevice", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unregisterUserAndDevice", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_acceptGroupInvitation (seqid, input, output) {
    const args = new TalkService_acceptGroupInvitation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.acceptGroupInvitation.length === 2) {
      Promise.resolve(this._handler.acceptGroupInvitation.bind(this._handler)(
        args.reqSeq,
        args.groupId
      )).then(result => {
        const result_obj = new TalkService_acceptGroupInvitation_result({success: result});
        output.writeMessageBegin("acceptGroupInvitation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_acceptGroupInvitation_result(err);
          output.writeMessageBegin("acceptGroupInvitation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acceptGroupInvitation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.acceptGroupInvitation(args.reqSeq, args.groupId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_acceptGroupInvitation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("acceptGroupInvitation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acceptGroupInvitation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getCompactContactsModifiedSince (seqid, input, output) {
    const args = new TalkService_getCompactContactsModifiedSince_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getCompactContactsModifiedSince.length === 1) {
      Promise.resolve(this._handler.getCompactContactsModifiedSince.bind(this._handler)(
        args.timestamp
      )).then(result => {
        const result_obj = new TalkService_getCompactContactsModifiedSince_result({success: result});
        output.writeMessageBegin("getCompactContactsModifiedSince", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getCompactContactsModifiedSince_result(err);
          output.writeMessageBegin("getCompactContactsModifiedSince", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactContactsModifiedSince", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getCompactContactsModifiedSince(args.timestamp, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getCompactContactsModifiedSince_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getCompactContactsModifiedSince", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactContactsModifiedSince", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_releaseSession (seqid, input, output) {
    const args = new TalkService_releaseSession_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.releaseSession.length === 0) {
      Promise.resolve(this._handler.releaseSession.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_releaseSession_result({success: result});
        output.writeMessageBegin("releaseSession", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_releaseSession_result(err);
          output.writeMessageBegin("releaseSession", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("releaseSession", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.releaseSession((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_releaseSession_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("releaseSession", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("releaseSession", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findContactsByPhone (seqid, input, output) {
    const args = new TalkService_findContactsByPhone_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findContactsByPhone.length === 1) {
      Promise.resolve(this._handler.findContactsByPhone.bind(this._handler)(
        args.phones
      )).then(result => {
        const result_obj = new TalkService_findContactsByPhone_result({success: result});
        output.writeMessageBegin("findContactsByPhone", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findContactsByPhone_result(err);
          output.writeMessageBegin("findContactsByPhone", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactsByPhone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findContactsByPhone(args.phones, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findContactsByPhone_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findContactsByPhone", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactsByPhone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getHiddenContactMids (seqid, input, output) {
    const args = new TalkService_getHiddenContactMids_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getHiddenContactMids.length === 0) {
      Promise.resolve(this._handler.getHiddenContactMids.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getHiddenContactMids_result({success: result});
        output.writeMessageBegin("getHiddenContactMids", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getHiddenContactMids_result(err);
          output.writeMessageBegin("getHiddenContactMids", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getHiddenContactMids", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getHiddenContactMids((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getHiddenContactMids_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getHiddenContactMids", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getHiddenContactMids", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getEncryptedIdentity (seqid, input, output) {
    const args = new TalkService_getEncryptedIdentity_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getEncryptedIdentity.length === 0) {
      Promise.resolve(this._handler.getEncryptedIdentity.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getEncryptedIdentity_result({success: result});
        output.writeMessageBegin("getEncryptedIdentity", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getEncryptedIdentity_result(err);
          output.writeMessageBegin("getEncryptedIdentity", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getEncryptedIdentity", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getEncryptedIdentity((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getEncryptedIdentity_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getEncryptedIdentity", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getEncryptedIdentity", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateProfile (seqid, input, output) {
    const args = new TalkService_updateProfile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateProfile.length === 2) {
      Promise.resolve(this._handler.updateProfile.bind(this._handler)(
        args.reqSeq,
        args.profile
      )).then(result => {
        const result_obj = new TalkService_updateProfile_result({success: result});
        output.writeMessageBegin("updateProfile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateProfile_result(err);
          output.writeMessageBegin("updateProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateProfile(args.reqSeq, args.profile, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateProfile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reportSpam (seqid, input, output) {
    const args = new TalkService_reportSpam_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportSpam.length === 6) {
      Promise.resolve(this._handler.reportSpam.bind(this._handler)(
        args.chatMid,
        args.memberMids,
        args.spammerReasons,
        args.senderMids,
        args.spamMessageIds,
        args.spamMessages
      )).then(result => {
        const result_obj = new TalkService_reportSpam_result({success: result});
        output.writeMessageBegin("reportSpam", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportSpam_result(err);
          output.writeMessageBegin("reportSpam", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportSpam", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportSpam(args.chatMid, args.memberMids, args.spammerReasons, args.senderMids, args.spamMessageIds, args.spamMessages, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportSpam_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportSpam", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportSpam", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getSuggestRevisions (seqid, input, output) {
    const args = new TalkService_getSuggestRevisions_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getSuggestRevisions.length === 0) {
      Promise.resolve(this._handler.getSuggestRevisions.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getSuggestRevisions_result({success: result});
        output.writeMessageBegin("getSuggestRevisions", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getSuggestRevisions_result(err);
          output.writeMessageBegin("getSuggestRevisions", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSuggestRevisions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getSuggestRevisions((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getSuggestRevisions_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getSuggestRevisions", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSuggestRevisions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getPreviousMessagesV2WithReadCount (seqid, input, output) {
    const args = new TalkService_getPreviousMessagesV2WithReadCount_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getPreviousMessagesV2WithReadCount.length === 3) {
      Promise.resolve(this._handler.getPreviousMessagesV2WithReadCount.bind(this._handler)(
        args.messageBoxId,
        args.endMessageId,
        args.messagesCount
      )).then(result => {
        const result_obj = new TalkService_getPreviousMessagesV2WithReadCount_result({success: result});
        output.writeMessageBegin("getPreviousMessagesV2WithReadCount", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getPreviousMessagesV2WithReadCount_result(err);
          output.writeMessageBegin("getPreviousMessagesV2WithReadCount", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getPreviousMessagesV2WithReadCount", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getPreviousMessagesV2WithReadCount(args.messageBoxId, args.endMessageId, args.messagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getPreviousMessagesV2WithReadCount_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getPreviousMessagesV2WithReadCount", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getPreviousMessagesV2WithReadCount", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_fetchOperations (seqid, input, output) {
    const args = new TalkService_fetchOperations_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.fetchOperations.length === 2) {
      Promise.resolve(this._handler.fetchOperations.bind(this._handler)(
        args.localRev,
        args.count
      )).then(result => {
        const result_obj = new TalkService_fetchOperations_result({success: result});
        output.writeMessageBegin("fetchOperations", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.ShouldSyncException) {
          result = new TalkService_fetchOperations_result(err);
          output.writeMessageBegin("fetchOperations", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("fetchOperations", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.fetchOperations(args.localRev, args.count, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.ShouldSyncException) {
          result_obj = new TalkService_fetchOperations_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("fetchOperations", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("fetchOperations", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerWapDevice (seqid, input, output) {
    const args = new TalkService_registerWapDevice_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerWapDevice.length === 4) {
      Promise.resolve(this._handler.registerWapDevice.bind(this._handler)(
        args.invitationHash,
        args.guidHash,
        args.email,
        args.deviceInfo
      )).then(result => {
        const result_obj = new TalkService_registerWapDevice_result({success: result});
        output.writeMessageBegin("registerWapDevice", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerWapDevice_result(err);
          output.writeMessageBegin("registerWapDevice", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWapDevice", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerWapDevice(args.invitationHash, args.guidHash, args.email, args.deviceInfo, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerWapDevice_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerWapDevice", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWapDevice", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRecentFriendRequests (seqid, input, output) {
    const args = new TalkService_getRecentFriendRequests_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRecentFriendRequests.length === 0) {
      Promise.resolve(this._handler.getRecentFriendRequests.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getRecentFriendRequests_result({success: result});
        output.writeMessageBegin("getRecentFriendRequests", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRecentFriendRequests_result(err);
          output.writeMessageBegin("getRecentFriendRequests", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRecentFriendRequests", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRecentFriendRequests((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRecentFriendRequests_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRecentFriendRequests", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRecentFriendRequests", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifyBuddyOnAir (seqid, input, output) {
    const args = new TalkService_notifyBuddyOnAir_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifyBuddyOnAir.length === 2) {
      Promise.resolve(this._handler.notifyBuddyOnAir.bind(this._handler)(
        args.seq,
        args.receiverMids
      )).then(result => {
        const result_obj = new TalkService_notifyBuddyOnAir_result({success: result});
        output.writeMessageBegin("notifyBuddyOnAir", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_notifyBuddyOnAir_result(err);
          output.writeMessageBegin("notifyBuddyOnAir", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyBuddyOnAir", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifyBuddyOnAir(args.seq, args.receiverMids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_notifyBuddyOnAir_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifyBuddyOnAir", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyBuddyOnAir", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getLastAnnouncementIndex (seqid, input, output) {
    const args = new TalkService_getLastAnnouncementIndex_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getLastAnnouncementIndex.length === 0) {
      Promise.resolve(this._handler.getLastAnnouncementIndex.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getLastAnnouncementIndex_result({success: result});
        output.writeMessageBegin("getLastAnnouncementIndex", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getLastAnnouncementIndex_result(err);
          output.writeMessageBegin("getLastAnnouncementIndex", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getLastAnnouncementIndex", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getLastAnnouncementIndex((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getLastAnnouncementIndex_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getLastAnnouncementIndex", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getLastAnnouncementIndex", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendMessageAwaitCommit (seqid, input, output) {
    const args = new TalkService_sendMessageAwaitCommit_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendMessageAwaitCommit.length === 2) {
      Promise.resolve(this._handler.sendMessageAwaitCommit.bind(this._handler)(
        args.seq,
        args.message
      )).then(result => {
        const result_obj = new TalkService_sendMessageAwaitCommit_result({success: result});
        output.writeMessageBegin("sendMessageAwaitCommit", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendMessageAwaitCommit_result(err);
          output.writeMessageBegin("sendMessageAwaitCommit", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessageAwaitCommit", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendMessageAwaitCommit(args.seq, args.message, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendMessageAwaitCommit_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendMessageAwaitCommit", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessageAwaitCommit", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_negotiateE2EEPublicKey (seqid, input, output) {
    const args = new TalkService_negotiateE2EEPublicKey_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.negotiateE2EEPublicKey.length === 1) {
      Promise.resolve(this._handler.negotiateE2EEPublicKey.bind(this._handler)(
        args.mid
      )).then(result => {
        const result_obj = new TalkService_negotiateE2EEPublicKey_result({success: result});
        output.writeMessageBegin("negotiateE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_negotiateE2EEPublicKey_result(err);
          output.writeMessageBegin("negotiateE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("negotiateE2EEPublicKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.negotiateE2EEPublicKey(args.mid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_negotiateE2EEPublicKey_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("negotiateE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("negotiateE2EEPublicKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerE2EEGroupKey (seqid, input, output) {
    const args = new TalkService_registerE2EEGroupKey_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerE2EEGroupKey.length === 5) {
      Promise.resolve(this._handler.registerE2EEGroupKey.bind(this._handler)(
        args.version,
        args.chatMid,
        args.members,
        args.keyIds,
        args.encryptedSharedKeys
      )).then(result => {
        const result_obj = new TalkService_registerE2EEGroupKey_result({success: result});
        output.writeMessageBegin("registerE2EEGroupKey", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerE2EEGroupKey_result(err);
          output.writeMessageBegin("registerE2EEGroupKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerE2EEGroupKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerE2EEGroupKey(args.version, args.chatMid, args.members, args.keyIds, args.encryptedSharedKeys, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerE2EEGroupKey_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerE2EEGroupKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerE2EEGroupKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findSnsIdUserStatus (seqid, input, output) {
    const args = new TalkService_findSnsIdUserStatus_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findSnsIdUserStatus.length === 5) {
      Promise.resolve(this._handler.findSnsIdUserStatus.bind(this._handler)(
        args.snsIdType,
        args.snsAccessToken,
        args.udidHash,
        args.migrationPincodeSessionId,
        args.oldUdidHash
      )).then(result => {
        const result_obj = new TalkService_findSnsIdUserStatus_result({success: result});
        output.writeMessageBegin("findSnsIdUserStatus", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findSnsIdUserStatus_result(err);
          output.writeMessageBegin("findSnsIdUserStatus", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findSnsIdUserStatus", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findSnsIdUserStatus(args.snsIdType, args.snsAccessToken, args.udidHash, args.migrationPincodeSessionId, args.oldUdidHash, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findSnsIdUserStatus_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findSnsIdUserStatus", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findSnsIdUserStatus", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifyUpdated (seqid, input, output) {
    const args = new TalkService_notifyUpdated_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifyUpdated.length === 4) {
      Promise.resolve(this._handler.notifyUpdated.bind(this._handler)(
        args.lastRev,
        args.deviceInfo,
        args.udidHash,
        args.oldUdidHash
      )).then(result => {
        const result_obj = new TalkService_notifyUpdated_result({success: result});
        output.writeMessageBegin("notifyUpdated", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_notifyUpdated_result(err);
          output.writeMessageBegin("notifyUpdated", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyUpdated", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifyUpdated(args.lastRev, args.deviceInfo, args.udidHash, args.oldUdidHash, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_notifyUpdated_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifyUpdated", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyUpdated", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reportGroups (seqid, input, output) {
    const args = new TalkService_reportGroups_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportGroups.length === 2) {
      Promise.resolve(this._handler.reportGroups.bind(this._handler)(
        args.syncOpRevision,
        args.groups
      )).then(result => {
        const result_obj = new TalkService_reportGroups_result({success: result});
        output.writeMessageBegin("reportGroups", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportGroups_result(err);
          output.writeMessageBegin("reportGroups", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportGroups", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportGroups(args.syncOpRevision, args.groups, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportGroups_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportGroups", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportGroups", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getNotificationPolicy (seqid, input, output) {
    const args = new TalkService_getNotificationPolicy_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getNotificationPolicy.length === 1) {
      Promise.resolve(this._handler.getNotificationPolicy.bind(this._handler)(
        args.carrier
      )).then(result => {
        const result_obj = new TalkService_getNotificationPolicy_result({success: result});
        output.writeMessageBegin("getNotificationPolicy", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getNotificationPolicy_result(err);
          output.writeMessageBegin("getNotificationPolicy", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getNotificationPolicy", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getNotificationPolicy(args.carrier, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getNotificationPolicy_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getNotificationPolicy", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getNotificationPolicy", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findAndAddContactsByUserid (seqid, input, output) {
    const args = new TalkService_findAndAddContactsByUserid_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findAndAddContactsByUserid.length === 2) {
      Promise.resolve(this._handler.findAndAddContactsByUserid.bind(this._handler)(
        args.reqSeq,
        args.userid
      )).then(result => {
        const result_obj = new TalkService_findAndAddContactsByUserid_result({success: result});
        output.writeMessageBegin("findAndAddContactsByUserid", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findAndAddContactsByUserid_result(err);
          output.writeMessageBegin("findAndAddContactsByUserid", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactsByUserid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findAndAddContactsByUserid(args.reqSeq, args.userid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findAndAddContactsByUserid_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findAndAddContactsByUserid", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactsByUserid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getLastE2EEGroupSharedKey (seqid, input, output) {
    const args = new TalkService_getLastE2EEGroupSharedKey_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getLastE2EEGroupSharedKey.length === 2) {
      Promise.resolve(this._handler.getLastE2EEGroupSharedKey.bind(this._handler)(
        args.version,
        args.chatMid
      )).then(result => {
        const result_obj = new TalkService_getLastE2EEGroupSharedKey_result({success: result});
        output.writeMessageBegin("getLastE2EEGroupSharedKey", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getLastE2EEGroupSharedKey_result(err);
          output.writeMessageBegin("getLastE2EEGroupSharedKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getLastE2EEGroupSharedKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getLastE2EEGroupSharedKey(args.version, args.chatMid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getLastE2EEGroupSharedKey_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getLastE2EEGroupSharedKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getLastE2EEGroupSharedKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifyUpdatePublicKeychain (seqid, input, output) {
    const args = new TalkService_notifyUpdatePublicKeychain_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifyUpdatePublicKeychain.length === 1) {
      Promise.resolve(this._handler.notifyUpdatePublicKeychain.bind(this._handler)(
        args.mid
      )).then(result => {
        const result_obj = new TalkService_notifyUpdatePublicKeychain_result({success: result});
        output.writeMessageBegin("notifyUpdatePublicKeychain", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_notifyUpdatePublicKeychain_result(err);
          output.writeMessageBegin("notifyUpdatePublicKeychain", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyUpdatePublicKeychain", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifyUpdatePublicKeychain(args.mid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_notifyUpdatePublicKeychain_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifyUpdatePublicKeychain", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyUpdatePublicKeychain", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_report (seqid, input, output) {
    const args = new TalkService_report_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.report.length === 3) {
      Promise.resolve(this._handler.report.bind(this._handler)(
        args.syncOpRevision,
        args.category,
        args.report
      )).then(result => {
        const result_obj = new TalkService_report_result({success: result});
        output.writeMessageBegin("report", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_report_result(err);
          output.writeMessageBegin("report", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("report", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.report(args.syncOpRevision, args.category, args.report, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_report_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("report", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("report", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_acceptGroupInvitationByTicket (seqid, input, output) {
    const args = new TalkService_acceptGroupInvitationByTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.acceptGroupInvitationByTicket.length === 3) {
      Promise.resolve(this._handler.acceptGroupInvitationByTicket.bind(this._handler)(
        args.reqSeq,
        args.groupMid,
        args.ticketId
      )).then(result => {
        const result_obj = new TalkService_acceptGroupInvitationByTicket_result({success: result});
        output.writeMessageBegin("acceptGroupInvitationByTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_acceptGroupInvitationByTicket_result(err);
          output.writeMessageBegin("acceptGroupInvitationByTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acceptGroupInvitationByTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.acceptGroupInvitationByTicket(args.reqSeq, args.groupMid, args.ticketId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_acceptGroupInvitationByTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("acceptGroupInvitationByTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acceptGroupInvitationByTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getContactRegistration (seqid, input, output) {
    const args = new TalkService_getContactRegistration_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getContactRegistration.length === 2) {
      Promise.resolve(this._handler.getContactRegistration.bind(this._handler)(
        args.id,
        args.type
      )).then(result => {
        const result_obj = new TalkService_getContactRegistration_result({success: result});
        output.writeMessageBegin("getContactRegistration", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getContactRegistration_result(err);
          output.writeMessageBegin("getContactRegistration", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getContactRegistration", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getContactRegistration(args.id, args.type, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getContactRegistration_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getContactRegistration", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getContactRegistration", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateContactSetting (seqid, input, output) {
    const args = new TalkService_updateContactSetting_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateContactSetting.length === 4) {
      Promise.resolve(this._handler.updateContactSetting.bind(this._handler)(
        args.reqSeq,
        args.mid,
        args.flag,
        args.value
      )).then(result => {
        const result_obj = new TalkService_updateContactSetting_result({success: result});
        output.writeMessageBegin("updateContactSetting", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateContactSetting_result(err);
          output.writeMessageBegin("updateContactSetting", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateContactSetting", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateContactSetting(args.reqSeq, args.mid, args.flag, args.value, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateContactSetting_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateContactSetting", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateContactSetting", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getContactWithFriendRequestStatus (seqid, input, output) {
    const args = new TalkService_getContactWithFriendRequestStatus_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getContactWithFriendRequestStatus.length === 1) {
      Promise.resolve(this._handler.getContactWithFriendRequestStatus.bind(this._handler)(
        args.id
      )).then(result => {
        const result_obj = new TalkService_getContactWithFriendRequestStatus_result({success: result});
        output.writeMessageBegin("getContactWithFriendRequestStatus", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getContactWithFriendRequestStatus_result(err);
          output.writeMessageBegin("getContactWithFriendRequestStatus", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getContactWithFriendRequestStatus", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getContactWithFriendRequestStatus(args.id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getContactWithFriendRequestStatus_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getContactWithFriendRequestStatus", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getContactWithFriendRequestStatus", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxListByStatus (seqid, input, output) {
    const args = new TalkService_getMessageBoxListByStatus_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxListByStatus.length === 3) {
      Promise.resolve(this._handler.getMessageBoxListByStatus.bind(this._handler)(
        args.channelId,
        args.lastMessagesCount,
        args.status
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxListByStatus_result({success: result});
        output.writeMessageBegin("getMessageBoxListByStatus", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxListByStatus_result(err);
          output.writeMessageBegin("getMessageBoxListByStatus", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxListByStatus", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxListByStatus(args.channelId, args.lastMessagesCount, args.status, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxListByStatus_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxListByStatus", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxListByStatus", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_openProximityMatch (seqid, input, output) {
    const args = new TalkService_openProximityMatch_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.openProximityMatch.length === 1) {
      Promise.resolve(this._handler.openProximityMatch.bind(this._handler)(
        args.location
      )).then(result => {
        const result_obj = new TalkService_openProximityMatch_result({success: result});
        output.writeMessageBegin("openProximityMatch", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_openProximityMatch_result(err);
          output.writeMessageBegin("openProximityMatch", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("openProximityMatch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.openProximityMatch(args.location, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_openProximityMatch_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("openProximityMatch", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("openProximityMatch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_logout (seqid, input, output) {
    const args = new TalkService_logout_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.logout.length === 0) {
      Promise.resolve(this._handler.logout.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_logout_result({success: result});
        output.writeMessageBegin("logout", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_logout_result(err);
          output.writeMessageBegin("logout", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("logout", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.logout((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_logout_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("logout", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("logout", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getE2EEPublicKey (seqid, input, output) {
    const args = new TalkService_getE2EEPublicKey_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getE2EEPublicKey.length === 3) {
      Promise.resolve(this._handler.getE2EEPublicKey.bind(this._handler)(
        args.mid,
        args.version,
        args.keyId
      )).then(result => {
        const result_obj = new TalkService_getE2EEPublicKey_result({success: result});
        output.writeMessageBegin("getE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getE2EEPublicKey_result(err);
          output.writeMessageBegin("getE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getE2EEPublicKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getE2EEPublicKey(args.mid, args.version, args.keyId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getE2EEPublicKey_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getE2EEPublicKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerUserid (seqid, input, output) {
    const args = new TalkService_registerUserid_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerUserid.length === 2) {
      Promise.resolve(this._handler.registerUserid.bind(this._handler)(
        args.reqSeq,
        args.userid
      )).then(result => {
        const result_obj = new TalkService_registerUserid_result({success: result});
        output.writeMessageBegin("registerUserid", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerUserid_result(err);
          output.writeMessageBegin("registerUserid", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerUserid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerUserid(args.reqSeq, args.userid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerUserid_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerUserid", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerUserid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reportContacts (seqid, input, output) {
    const args = new TalkService_reportContacts_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportContacts.length === 4) {
      Promise.resolve(this._handler.reportContacts.bind(this._handler)(
        args.syncOpRevision,
        args.category,
        args.contactReports,
        args.actionType
      )).then(result => {
        const result_obj = new TalkService_reportContacts_result({success: result});
        output.writeMessageBegin("reportContacts", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportContacts_result(err);
          output.writeMessageBegin("reportContacts", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportContacts", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportContacts(args.syncOpRevision, args.category, args.contactReports, args.actionType, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportContacts_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportContacts", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportContacts", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getPublicKeychain (seqid, input, output) {
    const args = new TalkService_getPublicKeychain_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getPublicKeychain.length === 1) {
      Promise.resolve(this._handler.getPublicKeychain.bind(this._handler)(
        args.mid
      )).then(result => {
        const result_obj = new TalkService_getPublicKeychain_result({success: result});
        output.writeMessageBegin("getPublicKeychain", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getPublicKeychain_result(err);
          output.writeMessageBegin("getPublicKeychain", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getPublicKeychain", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getPublicKeychain(args.mid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getPublicKeychain_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getPublicKeychain", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getPublicKeychain", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendContentReceipt (seqid, input, output) {
    const args = new TalkService_sendContentReceipt_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendContentReceipt.length === 3) {
      Promise.resolve(this._handler.sendContentReceipt.bind(this._handler)(
        args.seq,
        args.consumer,
        args.messageId
      )).then(result => {
        const result_obj = new TalkService_sendContentReceipt_result({success: result});
        output.writeMessageBegin("sendContentReceipt", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendContentReceipt_result(err);
          output.writeMessageBegin("sendContentReceipt", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendContentReceipt", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendContentReceipt(args.seq, args.consumer, args.messageId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendContentReceipt_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendContentReceipt", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendContentReceipt", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_respondResendMessage (seqid, input, output) {
    const args = new TalkService_respondResendMessage_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.respondResendMessage.length === 5) {
      Promise.resolve(this._handler.respondResendMessage.bind(this._handler)(
        args.reqSeq,
        args.receiverMid,
        args.originalMessageId,
        args.resendMessage,
        args.errorCode
      )).then(result => {
        const result_obj = new TalkService_respondResendMessage_result({success: result});
        output.writeMessageBegin("respondResendMessage", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_respondResendMessage_result(err);
          output.writeMessageBegin("respondResendMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("respondResendMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.respondResendMessage(args.reqSeq, args.receiverMid, args.originalMessageId, args.resendMessage, args.errorCode, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_respondResendMessage_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("respondResendMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("respondResendMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getAllRoomIds (seqid, input, output) {
    const args = new TalkService_getAllRoomIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getAllRoomIds.length === 0) {
      Promise.resolve(this._handler.getAllRoomIds.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getAllRoomIds_result({success: result});
        output.writeMessageBegin("getAllRoomIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getAllRoomIds_result(err);
          output.writeMessageBegin("getAllRoomIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAllRoomIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getAllRoomIds((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getAllRoomIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getAllRoomIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAllRoomIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_requestE2EEKeyExchange (seqid, input, output) {
    const args = new TalkService_requestE2EEKeyExchange_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.requestE2EEKeyExchange.length === 4) {
      Promise.resolve(this._handler.requestE2EEKeyExchange.bind(this._handler)(
        args.reqSeq,
        args.temporalPublicKey,
        args.publicKey,
        args.verifier
      )).then(result => {
        const result_obj = new TalkService_requestE2EEKeyExchange_result({success: result});
        output.writeMessageBegin("requestE2EEKeyExchange", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_requestE2EEKeyExchange_result(err);
          output.writeMessageBegin("requestE2EEKeyExchange", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestE2EEKeyExchange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.requestE2EEKeyExchange(args.reqSeq, args.temporalPublicKey, args.publicKey, args.verifier, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_requestE2EEKeyExchange_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("requestE2EEKeyExchange", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("requestE2EEKeyExchange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_disableNearby (seqid, input, output) {
    const args = new TalkService_disableNearby_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.disableNearby.length === 0) {
      Promise.resolve(this._handler.disableNearby.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_disableNearby_result({success: result});
        output.writeMessageBegin("disableNearby", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_disableNearby_result(err);
          output.writeMessageBegin("disableNearby", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("disableNearby", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.disableNearby((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_disableNearby_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("disableNearby", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("disableNearby", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_createQrcodeBase64Image (seqid, input, output) {
    const args = new TalkService_createQrcodeBase64Image_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.createQrcodeBase64Image.length === 7) {
      Promise.resolve(this._handler.createQrcodeBase64Image.bind(this._handler)(
        args.url,
        args.characterSet,
        args.imageSize,
        args.x,
        args.y,
        args.width,
        args.height
      )).then(result => {
        const result_obj = new TalkService_createQrcodeBase64Image_result({success: result});
        output.writeMessageBegin("createQrcodeBase64Image", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_createQrcodeBase64Image_result(err);
          output.writeMessageBegin("createQrcodeBase64Image", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createQrcodeBase64Image", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.createQrcodeBase64Image(args.url, args.characterSet, args.imageSize, args.x, args.y, args.width, args.height, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_createQrcodeBase64Image_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("createQrcodeBase64Image", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createQrcodeBase64Image", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxList (seqid, input, output) {
    const args = new TalkService_getMessageBoxList_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxList.length === 2) {
      Promise.resolve(this._handler.getMessageBoxList.bind(this._handler)(
        args.channelId,
        args.lastMessagesCount
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxList_result({success: result});
        output.writeMessageBegin("getMessageBoxList", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxList_result(err);
          output.writeMessageBegin("getMessageBoxList", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxList", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxList(args.channelId, args.lastMessagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxList_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxList", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxList", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_respondE2EEKeyExchange (seqid, input, output) {
    const args = new TalkService_respondE2EEKeyExchange_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.respondE2EEKeyExchange.length === 3) {
      Promise.resolve(this._handler.respondE2EEKeyExchange.bind(this._handler)(
        args.reqSeq,
        args.encryptedKeyChain,
        args.hashKeyChain
      )).then(result => {
        const result_obj = new TalkService_respondE2EEKeyExchange_result({success: result});
        output.writeMessageBegin("respondE2EEKeyExchange", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_respondE2EEKeyExchange_result(err);
          output.writeMessageBegin("respondE2EEKeyExchange", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("respondE2EEKeyExchange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.respondE2EEKeyExchange(args.reqSeq, args.encryptedKeyChain, args.hashKeyChain, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_respondE2EEKeyExchange_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("respondE2EEKeyExchange", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("respondE2EEKeyExchange", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_verifyQrcode (seqid, input, output) {
    const args = new TalkService_verifyQrcode_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.verifyQrcode.length === 2) {
      Promise.resolve(this._handler.verifyQrcode.bind(this._handler)(
        args.verifier,
        args.pinCode
      )).then(result => {
        const result_obj = new TalkService_verifyQrcode_result({success: result});
        output.writeMessageBegin("verifyQrcode", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_verifyQrcode_result(err);
          output.writeMessageBegin("verifyQrcode", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyQrcode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.verifyQrcode(args.verifier, args.pinCode, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_verifyQrcode_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("verifyQrcode", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyQrcode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateNotificationTokenWithBytes (seqid, input, output) {
    const args = new TalkService_updateNotificationTokenWithBytes_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateNotificationTokenWithBytes.length === 2) {
      Promise.resolve(this._handler.updateNotificationTokenWithBytes.bind(this._handler)(
        args.token,
        args.type
      )).then(result => {
        const result_obj = new TalkService_updateNotificationTokenWithBytes_result({success: result});
        output.writeMessageBegin("updateNotificationTokenWithBytes", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateNotificationTokenWithBytes_result(err);
          output.writeMessageBegin("updateNotificationTokenWithBytes", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateNotificationTokenWithBytes", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateNotificationTokenWithBytes(args.token, args.type, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateNotificationTokenWithBytes_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateNotificationTokenWithBytes", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateNotificationTokenWithBytes", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getPreviousMessages (seqid, input, output) {
    const args = new TalkService_getPreviousMessages_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getPreviousMessages.length === 3) {
      Promise.resolve(this._handler.getPreviousMessages.bind(this._handler)(
        args.messageBoxId,
        args.endSeq,
        args.messagesCount
      )).then(result => {
        const result_obj = new TalkService_getPreviousMessages_result({success: result});
        output.writeMessageBegin("getPreviousMessages", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getPreviousMessages_result(err);
          output.writeMessageBegin("getPreviousMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getPreviousMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getPreviousMessages(args.messageBoxId, args.endSeq, args.messagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getPreviousMessages_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getPreviousMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getPreviousMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getSettings (seqid, input, output) {
    const args = new TalkService_getSettings_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getSettings.length === 0) {
      Promise.resolve(this._handler.getSettings.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getSettings_result({success: result});
        output.writeMessageBegin("getSettings", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getSettings_result(err);
          output.writeMessageBegin("getSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getSettings((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getSettings_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getLastE2EEPublicKeys (seqid, input, output) {
    const args = new TalkService_getLastE2EEPublicKeys_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getLastE2EEPublicKeys.length === 1) {
      Promise.resolve(this._handler.getLastE2EEPublicKeys.bind(this._handler)(
        args.chatMid
      )).then(result => {
        const result_obj = new TalkService_getLastE2EEPublicKeys_result({success: result});
        output.writeMessageBegin("getLastE2EEPublicKeys", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getLastE2EEPublicKeys_result(err);
          output.writeMessageBegin("getLastE2EEPublicKeys", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getLastE2EEPublicKeys", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getLastE2EEPublicKeys(args.chatMid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getLastE2EEPublicKeys_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getLastE2EEPublicKeys", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getLastE2EEPublicKeys", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerE2EEPublicKey (seqid, input, output) {
    const args = new TalkService_registerE2EEPublicKey_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerE2EEPublicKey.length === 2) {
      Promise.resolve(this._handler.registerE2EEPublicKey.bind(this._handler)(
        args.reqSeq,
        args.publicKey
      )).then(result => {
        const result_obj = new TalkService_registerE2EEPublicKey_result({success: result});
        output.writeMessageBegin("registerE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerE2EEPublicKey_result(err);
          output.writeMessageBegin("registerE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerE2EEPublicKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerE2EEPublicKey(args.reqSeq, args.publicKey, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerE2EEPublicKey_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerE2EEPublicKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerE2EEPublicKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_acquireCallTicket (seqid, input, output) {
    const args = new TalkService_acquireCallTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.acquireCallTicket.length === 1) {
      Promise.resolve(this._handler.acquireCallTicket.bind(this._handler)(
        args.to
      )).then(result => {
        const result_obj = new TalkService_acquireCallTicket_result({success: result});
        output.writeMessageBegin("acquireCallTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_acquireCallTicket_result(err);
          output.writeMessageBegin("acquireCallTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acquireCallTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.acquireCallTicket(args.to, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_acquireCallTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("acquireCallTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acquireCallTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_inviteIntoGroup (seqid, input, output) {
    const args = new TalkService_inviteIntoGroup_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.inviteIntoGroup.length === 3) {
      Promise.resolve(this._handler.inviteIntoGroup.bind(this._handler)(
        args.reqSeq,
        args.groupId,
        args.contactIds
      )).then(result => {
        const result_obj = new TalkService_inviteIntoGroup_result({success: result});
        output.writeMessageBegin("inviteIntoGroup", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_inviteIntoGroup_result(err);
          output.writeMessageBegin("inviteIntoGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("inviteIntoGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.inviteIntoGroup(args.reqSeq, args.groupId, args.contactIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_inviteIntoGroup_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("inviteIntoGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("inviteIntoGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_makeUserAddMyselfAsContact (seqid, input, output) {
    const args = new TalkService_makeUserAddMyselfAsContact_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.makeUserAddMyselfAsContact.length === 1) {
      Promise.resolve(this._handler.makeUserAddMyselfAsContact.bind(this._handler)(
        args.contactOwnerMid
      )).then(result => {
        const result_obj = new TalkService_makeUserAddMyselfAsContact_result({success: result});
        output.writeMessageBegin("makeUserAddMyselfAsContact", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_makeUserAddMyselfAsContact_result(err);
          output.writeMessageBegin("makeUserAddMyselfAsContact", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("makeUserAddMyselfAsContact", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.makeUserAddMyselfAsContact(args.contactOwnerMid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_makeUserAddMyselfAsContact_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("makeUserAddMyselfAsContact", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("makeUserAddMyselfAsContact", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_removeMessageFromMyHome (seqid, input, output) {
    const args = new TalkService_removeMessageFromMyHome_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.removeMessageFromMyHome.length === 1) {
      Promise.resolve(this._handler.removeMessageFromMyHome.bind(this._handler)(
        args.messageId
      )).then(result => {
        const result_obj = new TalkService_removeMessageFromMyHome_result({success: result});
        output.writeMessageBegin("removeMessageFromMyHome", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_removeMessageFromMyHome_result(err);
          output.writeMessageBegin("removeMessageFromMyHome", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeMessageFromMyHome", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.removeMessageFromMyHome(args.messageId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_removeMessageFromMyHome_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("removeMessageFromMyHome", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeMessageFromMyHome", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_commitSendMessages (seqid, input, output) {
    const args = new TalkService_commitSendMessages_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.commitSendMessages.length === 4) {
      Promise.resolve(this._handler.commitSendMessages.bind(this._handler)(
        args.seq,
        args.messageIds,
        args.receiverMids,
        args.onlyToFollowers
      )).then(result => {
        const result_obj = new TalkService_commitSendMessages_result({success: result});
        output.writeMessageBegin("commitSendMessages", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_commitSendMessages_result(err);
          output.writeMessageBegin("commitSendMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("commitSendMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.commitSendMessages(args.seq, args.messageIds, args.receiverMids, args.onlyToFollowers, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_commitSendMessages_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("commitSendMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("commitSendMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerWithPhoneNumberAndPassword (seqid, input, output) {
    const args = new TalkService_registerWithPhoneNumberAndPassword_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerWithPhoneNumberAndPassword.length === 3) {
      Promise.resolve(this._handler.registerWithPhoneNumberAndPassword.bind(this._handler)(
        args.sessionId,
        args.keynm,
        args.encrypted
      )).then(result => {
        const result_obj = new TalkService_registerWithPhoneNumberAndPassword_result({success: result});
        output.writeMessageBegin("registerWithPhoneNumberAndPassword", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerWithPhoneNumberAndPassword_result(err);
          output.writeMessageBegin("registerWithPhoneNumberAndPassword", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithPhoneNumberAndPassword", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerWithPhoneNumberAndPassword(args.sessionId, args.keynm, args.encrypted, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerWithPhoneNumberAndPassword_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerWithPhoneNumberAndPassword", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerWithPhoneNumberAndPassword", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_leaveGroup (seqid, input, output) {
    const args = new TalkService_leaveGroup_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.leaveGroup.length === 2) {
      Promise.resolve(this._handler.leaveGroup.bind(this._handler)(
        args.reqSeq,
        args.groupId
      )).then(result => {
        const result_obj = new TalkService_leaveGroup_result({success: result});
        output.writeMessageBegin("leaveGroup", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_leaveGroup_result(err);
          output.writeMessageBegin("leaveGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("leaveGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.leaveGroup(args.reqSeq, args.groupId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_leaveGroup_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("leaveGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("leaveGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getAnalyticsInfo (seqid, input, output) {
    const args = new TalkService_getAnalyticsInfo_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getAnalyticsInfo.length === 0) {
      Promise.resolve(this._handler.getAnalyticsInfo.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getAnalyticsInfo_result({success: result});
        output.writeMessageBegin("getAnalyticsInfo", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getAnalyticsInfo_result(err);
          output.writeMessageBegin("getAnalyticsInfo", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAnalyticsInfo", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getAnalyticsInfo((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getAnalyticsInfo_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getAnalyticsInfo", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAnalyticsInfo", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reportClientStatistics (seqid, input, output) {
    const args = new TalkService_reportClientStatistics_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportClientStatistics.length === 3) {
      Promise.resolve(this._handler.reportClientStatistics.bind(this._handler)(
        args.reqSeq,
        args.category,
        args.count
      )).then(result => {
        const result_obj = new TalkService_reportClientStatistics_result({success: result});
        output.writeMessageBegin("reportClientStatistics", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportClientStatistics_result(err);
          output.writeMessageBegin("reportClientStatistics", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportClientStatistics", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportClientStatistics(args.reqSeq, args.category, args.count, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportClientStatistics_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportClientStatistics", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportClientStatistics", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_acceptProximityMatches (seqid, input, output) {
    const args = new TalkService_acceptProximityMatches_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.acceptProximityMatches.length === 2) {
      Promise.resolve(this._handler.acceptProximityMatches.bind(this._handler)(
        args.sessionId,
        args.ids
      )).then(result => {
        const result_obj = new TalkService_acceptProximityMatches_result({success: result});
        output.writeMessageBegin("acceptProximityMatches", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_acceptProximityMatches_result(err);
          output.writeMessageBegin("acceptProximityMatches", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acceptProximityMatches", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.acceptProximityMatches(args.sessionId, args.ids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_acceptProximityMatches_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("acceptProximityMatches", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acceptProximityMatches", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getGroup (seqid, input, output) {
    const args = new TalkService_getGroup_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getGroup.length === 1) {
      Promise.resolve(this._handler.getGroup.bind(this._handler)(
        args.groupId
      )).then(result => {
        const result_obj = new TalkService_getGroup_result({success: result});
        output.writeMessageBegin("getGroup", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getGroup_result(err);
          output.writeMessageBegin("getGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getGroup(args.groupId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getGroup_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clearIdentityCredential (seqid, input, output) {
    const args = new TalkService_clearIdentityCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clearIdentityCredential.length === 0) {
      Promise.resolve(this._handler.clearIdentityCredential.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_clearIdentityCredential_result({success: result});
        output.writeMessageBegin("clearIdentityCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_clearIdentityCredential_result(err);
          output.writeMessageBegin("clearIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clearIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clearIdentityCredential((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_clearIdentityCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clearIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clearIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getUpdatedMessageBoxIds (seqid, input, output) {
    const args = new TalkService_getUpdatedMessageBoxIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getUpdatedMessageBoxIds.length === 3) {
      Promise.resolve(this._handler.getUpdatedMessageBoxIds.bind(this._handler)(
        args.startMessageId,
        args.startMessageBoxId,
        args.messageBoxCount
      )).then(result => {
        const result_obj = new TalkService_getUpdatedMessageBoxIds_result({success: result});
        output.writeMessageBegin("getUpdatedMessageBoxIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getUpdatedMessageBoxIds_result(err);
          output.writeMessageBegin("getUpdatedMessageBoxIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getUpdatedMessageBoxIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getUpdatedMessageBoxIds(args.startMessageId, args.startMessageBoxId, args.messageBoxCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getUpdatedMessageBoxIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getUpdatedMessageBoxIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getUpdatedMessageBoxIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getGroups (seqid, input, output) {
    const args = new TalkService_getGroups_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getGroups.length === 1) {
      Promise.resolve(this._handler.getGroups.bind(this._handler)(
        args.groupIds
      )).then(result => {
        const result_obj = new TalkService_getGroups_result({success: result});
        output.writeMessageBegin("getGroups", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getGroups_result(err);
          output.writeMessageBegin("getGroups", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroups", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getGroups(args.groupIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getGroups_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getGroups", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroups", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendMessageReceipt (seqid, input, output) {
    const args = new TalkService_sendMessageReceipt_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendMessageReceipt.length === 3) {
      Promise.resolve(this._handler.sendMessageReceipt.bind(this._handler)(
        args.seq,
        args.consumer,
        args.messageIds
      )).then(result => {
        const result_obj = new TalkService_sendMessageReceipt_result({success: result});
        output.writeMessageBegin("sendMessageReceipt", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendMessageReceipt_result(err);
          output.writeMessageBegin("sendMessageReceipt", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessageReceipt", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendMessageReceipt(args.seq, args.consumer, args.messageIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendMessageReceipt_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendMessageReceipt", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendMessageReceipt", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findContactByMetaTag (seqid, input, output) {
    const args = new TalkService_findContactByMetaTag_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findContactByMetaTag.length === 2) {
      Promise.resolve(this._handler.findContactByMetaTag.bind(this._handler)(
        args.userid,
        args.reference
      )).then(result => {
        const result_obj = new TalkService_findContactByMetaTag_result({success: result});
        output.writeMessageBegin("findContactByMetaTag", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findContactByMetaTag_result(err);
          output.writeMessageBegin("findContactByMetaTag", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactByMetaTag", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findContactByMetaTag(args.userid, args.reference, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findContactByMetaTag_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findContactByMetaTag", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactByMetaTag", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_destroyMessage (seqid, input, output) {
    const args = new TalkService_destroyMessage_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.destroyMessage.length === 4) {
      Promise.resolve(this._handler.destroyMessage.bind(this._handler)(
        args.seq,
        args.chatId,
        args.messageId,
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_destroyMessage_result({success: result});
        output.writeMessageBegin("destroyMessage", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_destroyMessage_result(err);
          output.writeMessageBegin("destroyMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("destroyMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.destroyMessage(args.seq, args.chatId, args.messageId, args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_destroyMessage_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("destroyMessage", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("destroyMessage", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_generateUserTicket (seqid, input, output) {
    const args = new TalkService_generateUserTicket_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.generateUserTicket.length === 2) {
      Promise.resolve(this._handler.generateUserTicket.bind(this._handler)(
        args.expirationTime,
        args.maxUseCount
      )).then(result => {
        const result_obj = new TalkService_generateUserTicket_result({success: result});
        output.writeMessageBegin("generateUserTicket", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_generateUserTicket_result(err);
          output.writeMessageBegin("generateUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("generateUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.generateUserTicket(args.expirationTime, args.maxUseCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_generateUserTicket_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("generateUserTicket", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("generateUserTicket", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_registerDeviceWithoutPhoneNumberWithIdentityCredential (seqid, input, output) {
    const args = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.registerDeviceWithoutPhoneNumberWithIdentityCredential.length === 8) {
      Promise.resolve(this._handler.registerDeviceWithoutPhoneNumberWithIdentityCredential.bind(this._handler)(
        args.region,
        args.udidHash,
        args.deviceInfo,
        args.provider,
        args.identifier,
        args.verifier,
        args.mid,
        args.migrationPincodeSessionId
      )).then(result => {
        const result_obj = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result({success: result});
        output.writeMessageBegin("registerDeviceWithoutPhoneNumberWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result(err);
          output.writeMessageBegin("registerDeviceWithoutPhoneNumberWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerDeviceWithoutPhoneNumberWithIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.registerDeviceWithoutPhoneNumberWithIdentityCredential(args.region, args.udidHash, args.deviceInfo, args.provider, args.identifier, args.verifier, args.mid, args.migrationPincodeSessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_registerDeviceWithoutPhoneNumberWithIdentityCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("registerDeviceWithoutPhoneNumberWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("registerDeviceWithoutPhoneNumberWithIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getFavoriteMids (seqid, input, output) {
    const args = new TalkService_getFavoriteMids_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getFavoriteMids.length === 0) {
      Promise.resolve(this._handler.getFavoriteMids.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getFavoriteMids_result({success: result});
        output.writeMessageBegin("getFavoriteMids", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getFavoriteMids_result(err);
          output.writeMessageBegin("getFavoriteMids", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getFavoriteMids", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getFavoriteMids((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getFavoriteMids_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getFavoriteMids", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getFavoriteMids", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getAcceptedProximityMatches (seqid, input, output) {
    const args = new TalkService_getAcceptedProximityMatches_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getAcceptedProximityMatches.length === 1) {
      Promise.resolve(this._handler.getAcceptedProximityMatches.bind(this._handler)(
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_getAcceptedProximityMatches_result({success: result});
        output.writeMessageBegin("getAcceptedProximityMatches", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getAcceptedProximityMatches_result(err);
          output.writeMessageBegin("getAcceptedProximityMatches", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAcceptedProximityMatches", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getAcceptedProximityMatches(args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getAcceptedProximityMatches_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getAcceptedProximityMatches", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAcceptedProximityMatches", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifyInstalled (seqid, input, output) {
    const args = new TalkService_notifyInstalled_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifyInstalled.length === 2) {
      Promise.resolve(this._handler.notifyInstalled.bind(this._handler)(
        args.udidHash,
        args.applicationTypeWithExtensions
      )).then(result => {
        const result_obj = new TalkService_notifyInstalled_result({success: result});
        output.writeMessageBegin("notifyInstalled", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("notifyInstalled", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifyInstalled(args.udidHash, args.applicationTypeWithExtensions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new TalkService_notifyInstalled_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifyInstalled", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyInstalled", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getCountryWithRequestIp (seqid, input, output) {
    const args = new TalkService_getCountryWithRequestIp_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getCountryWithRequestIp.length === 0) {
      Promise.resolve(this._handler.getCountryWithRequestIp.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getCountryWithRequestIp_result({success: result});
        output.writeMessageBegin("getCountryWithRequestIp", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getCountryWithRequestIp_result(err);
          output.writeMessageBegin("getCountryWithRequestIp", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCountryWithRequestIp", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getCountryWithRequestIp((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getCountryWithRequestIp_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getCountryWithRequestIp", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCountryWithRequestIp", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getGroupsV2 (seqid, input, output) {
    const args = new TalkService_getGroupsV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getGroupsV2.length === 1) {
      Promise.resolve(this._handler.getGroupsV2.bind(this._handler)(
        args.groupIds
      )).then(result => {
        const result_obj = new TalkService_getGroupsV2_result({success: result});
        output.writeMessageBegin("getGroupsV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getGroupsV2_result(err);
          output.writeMessageBegin("getGroupsV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroupsV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getGroupsV2(args.groupIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getGroupsV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getGroupsV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroupsV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_loginWithIdentityCredential (seqid, input, output) {
    const args = new TalkService_loginWithIdentityCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.loginWithIdentityCredential.length === 7) {
      Promise.resolve(this._handler.loginWithIdentityCredential.bind(this._handler)(
        args.identifier,
        args.password,
        args.keepLoggedIn,
        args.accessLocation,
        args.systemName,
        args.identityProvider,
        args.certificate
      )).then(result => {
        const result_obj = new TalkService_loginWithIdentityCredential_result({success: result});
        output.writeMessageBegin("loginWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_loginWithIdentityCredential_result(err);
          output.writeMessageBegin("loginWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.loginWithIdentityCredential(args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.identityProvider, args.certificate, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_loginWithIdentityCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("loginWithIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_startUpdateVerification (seqid, input, output) {
    const args = new TalkService_startUpdateVerification_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.startUpdateVerification.length === 8) {
      Promise.resolve(this._handler.startUpdateVerification.bind(this._handler)(
        args.region,
        args.carrier,
        args.phone,
        args.udidHash,
        args.deviceInfo,
        args.networkCode,
        args.locale,
        args.simInfo
      )).then(result => {
        const result_obj = new TalkService_startUpdateVerification_result({success: result});
        output.writeMessageBegin("startUpdateVerification", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_startUpdateVerification_result(err);
          output.writeMessageBegin("startUpdateVerification", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("startUpdateVerification", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.startUpdateVerification(args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.locale, args.simInfo, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_startUpdateVerification_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("startUpdateVerification", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("startUpdateVerification", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getSessions (seqid, input, output) {
    const args = new TalkService_getSessions_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getSessions.length === 0) {
      Promise.resolve(this._handler.getSessions.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getSessions_result({success: result});
        output.writeMessageBegin("getSessions", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getSessions_result(err);
          output.writeMessageBegin("getSessions", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSessions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getSessions((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getSessions_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getSessions", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSessions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateSettings (seqid, input, output) {
    const args = new TalkService_updateSettings_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateSettings.length === 2) {
      Promise.resolve(this._handler.updateSettings.bind(this._handler)(
        args.reqSeq,
        args.settings
      )).then(result => {
        const result_obj = new TalkService_updateSettings_result({success: result});
        output.writeMessageBegin("updateSettings", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateSettings_result(err);
          output.writeMessageBegin("updateSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateSettings(args.reqSeq, args.settings, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateSettings_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getContact (seqid, input, output) {
    const args = new TalkService_getContact_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getContact.length === 1) {
      Promise.resolve(this._handler.getContact.bind(this._handler)(
        args.id
      )).then(result => {
        const result_obj = new TalkService_getContact_result({success: result});
        output.writeMessageBegin("getContact", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getContact_result(err);
          output.writeMessageBegin("getContact", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getContact", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getContact(args.id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getContact_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getContact", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getContact", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getBlockedContactIds (seqid, input, output) {
    const args = new TalkService_getBlockedContactIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getBlockedContactIds.length === 0) {
      Promise.resolve(this._handler.getBlockedContactIds.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getBlockedContactIds_result({success: result});
        output.writeMessageBegin("getBlockedContactIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getBlockedContactIds_result(err);
          output.writeMessageBegin("getBlockedContactIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBlockedContactIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getBlockedContactIds((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getBlockedContactIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getBlockedContactIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getBlockedContactIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_loginWithVerifierForCertificate (seqid, input, output) {
    const args = new TalkService_loginWithVerifierForCertificate_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.loginWithVerifierForCertificate.length === 1) {
      Promise.resolve(this._handler.loginWithVerifierForCertificate.bind(this._handler)(
        args.verifier
      )).then(result => {
        const result_obj = new TalkService_loginWithVerifierForCertificate_result({success: result});
        output.writeMessageBegin("loginWithVerifierForCertificate", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_loginWithVerifierForCertificate_result(err);
          output.writeMessageBegin("loginWithVerifierForCertificate", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithVerifierForCertificate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.loginWithVerifierForCertificate(args.verifier, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_loginWithVerifierForCertificate_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("loginWithVerifierForCertificate", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("loginWithVerifierForCertificate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getProfile (seqid, input, output) {
    const args = new TalkService_getProfile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getProfile.length === 0) {
      Promise.resolve(this._handler.getProfile.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getProfile_result({success: result});
        output.writeMessageBegin("getProfile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getProfile_result(err);
          output.writeMessageBegin("getProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getProfile((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getProfile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findContactsByEmail (seqid, input, output) {
    const args = new TalkService_findContactsByEmail_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findContactsByEmail.length === 1) {
      Promise.resolve(this._handler.findContactsByEmail.bind(this._handler)(
        args.emails
      )).then(result => {
        const result_obj = new TalkService_findContactsByEmail_result({success: result});
        output.writeMessageBegin("findContactsByEmail", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findContactsByEmail_result(err);
          output.writeMessageBegin("findContactsByEmail", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactsByEmail", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findContactsByEmail(args.emails, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findContactsByEmail_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findContactsByEmail", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactsByEmail", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getSystemConfiguration (seqid, input, output) {
    const args = new TalkService_getSystemConfiguration_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getSystemConfiguration.length === 0) {
      Promise.resolve(this._handler.getSystemConfiguration.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getSystemConfiguration_result({success: result});
        output.writeMessageBegin("getSystemConfiguration", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getSystemConfiguration_result(err);
          output.writeMessageBegin("getSystemConfiguration", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSystemConfiguration", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getSystemConfiguration((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getSystemConfiguration_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getSystemConfiguration", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getSystemConfiguration", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getRecentMessages (seqid, input, output) {
    const args = new TalkService_getRecentMessages_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getRecentMessages.length === 2) {
      Promise.resolve(this._handler.getRecentMessages.bind(this._handler)(
        args.messageBoxId,
        args.messagesCount
      )).then(result => {
        const result_obj = new TalkService_getRecentMessages_result({success: result});
        output.writeMessageBegin("getRecentMessages", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getRecentMessages_result(err);
          output.writeMessageBegin("getRecentMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRecentMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getRecentMessages(args.messageBoxId, args.messagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getRecentMessages_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getRecentMessages", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getRecentMessages", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_verifyPhone (seqid, input, output) {
    const args = new TalkService_verifyPhone_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.verifyPhone.length === 3) {
      Promise.resolve(this._handler.verifyPhone.bind(this._handler)(
        args.sessionId,
        args.pinCode,
        args.udidHash
      )).then(result => {
        const result_obj = new TalkService_verifyPhone_result({success: result});
        output.writeMessageBegin("verifyPhone", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_verifyPhone_result(err);
          output.writeMessageBegin("verifyPhone", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyPhone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.verifyPhone(args.sessionId, args.pinCode, args.udidHash, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_verifyPhone_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("verifyPhone", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyPhone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_createGroup (seqid, input, output) {
    const args = new TalkService_createGroup_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.createGroup.length === 3) {
      Promise.resolve(this._handler.createGroup.bind(this._handler)(
        args.seq,
        args.name,
        args.contactIds
      )).then(result => {
        const result_obj = new TalkService_createGroup_result({success: result});
        output.writeMessageBegin("createGroup", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_createGroup_result(err);
          output.writeMessageBegin("createGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.createGroup(args.seq, args.name, args.contactIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_createGroup_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("createGroup", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createGroup", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateBuddySetting (seqid, input, output) {
    const args = new TalkService_updateBuddySetting_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateBuddySetting.length === 2) {
      Promise.resolve(this._handler.updateBuddySetting.bind(this._handler)(
        args.key,
        args.value
      )).then(result => {
        const result_obj = new TalkService_updateBuddySetting_result({success: result});
        output.writeMessageBegin("updateBuddySetting", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateBuddySetting_result(err);
          output.writeMessageBegin("updateBuddySetting", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateBuddySetting", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateBuddySetting(args.key, args.value, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateBuddySetting_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateBuddySetting", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateBuddySetting", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateRegion (seqid, input, output) {
    const args = new TalkService_updateRegion_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateRegion.length === 1) {
      Promise.resolve(this._handler.updateRegion.bind(this._handler)(
        args.region
      )).then(result => {
        const result_obj = new TalkService_updateRegion_result({success: result});
        output.writeMessageBegin("updateRegion", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateRegion_result(err);
          output.writeMessageBegin("updateRegion", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateRegion", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateRegion(args.region, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateRegion_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateRegion", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateRegion", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_verifyIdentityCredential (seqid, input, output) {
    const args = new TalkService_verifyIdentityCredential_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.verifyIdentityCredential.length === 3) {
      Promise.resolve(this._handler.verifyIdentityCredential.bind(this._handler)(
        args.identifier,
        args.password,
        args.identityProvider
      )).then(result => {
        const result_obj = new TalkService_verifyIdentityCredential_result({success: result});
        output.writeMessageBegin("verifyIdentityCredential", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_verifyIdentityCredential_result(err);
          output.writeMessageBegin("verifyIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.verifyIdentityCredential(args.identifier, args.password, args.identityProvider, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_verifyIdentityCredential_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("verifyIdentityCredential", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyIdentityCredential", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendChatRemoved (seqid, input, output) {
    const args = new TalkService_sendChatRemoved_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendChatRemoved.length === 4) {
      Promise.resolve(this._handler.sendChatRemoved.bind(this._handler)(
        args.seq,
        args.consumer,
        args.lastMessageId,
        args.sessionId
      )).then(result => {
        const result_obj = new TalkService_sendChatRemoved_result({success: result});
        output.writeMessageBegin("sendChatRemoved", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendChatRemoved_result(err);
          output.writeMessageBegin("sendChatRemoved", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendChatRemoved", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendChatRemoved(args.seq, args.consumer, args.lastMessageId, args.sessionId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendChatRemoved_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendChatRemoved", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendChatRemoved", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getGroupIdsJoined (seqid, input, output) {
    const args = new TalkService_getGroupIdsJoined_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getGroupIdsJoined.length === 0) {
      Promise.resolve(this._handler.getGroupIdsJoined.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getGroupIdsJoined_result({success: result});
        output.writeMessageBegin("getGroupIdsJoined", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getGroupIdsJoined_result(err);
          output.writeMessageBegin("getGroupIdsJoined", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroupIdsJoined", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getGroupIdsJoined((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getGroupIdsJoined_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getGroupIdsJoined", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getGroupIdsJoined", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findContactByUserid (seqid, input, output) {
    const args = new TalkService_findContactByUserid_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findContactByUserid.length === 1) {
      Promise.resolve(this._handler.findContactByUserid.bind(this._handler)(
        args.userid
      )).then(result => {
        const result_obj = new TalkService_findContactByUserid_result({success: result});
        output.writeMessageBegin("findContactByUserid", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findContactByUserid_result(err);
          output.writeMessageBegin("findContactByUserid", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactByUserid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findContactByUserid(args.userid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findContactByUserid_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findContactByUserid", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findContactByUserid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getE2EEPublicKeys (seqid, input, output) {
    const args = new TalkService_getE2EEPublicKeys_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getE2EEPublicKeys.length === 0) {
      Promise.resolve(this._handler.getE2EEPublicKeys.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getE2EEPublicKeys_result({success: result});
        output.writeMessageBegin("getE2EEPublicKeys", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getE2EEPublicKeys_result(err);
          output.writeMessageBegin("getE2EEPublicKeys", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getE2EEPublicKeys", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getE2EEPublicKeys((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getE2EEPublicKeys_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getE2EEPublicKeys", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getE2EEPublicKeys", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxWrapUpList (seqid, input, output) {
    const args = new TalkService_getMessageBoxWrapUpList_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxWrapUpList.length === 2) {
      Promise.resolve(this._handler.getMessageBoxWrapUpList.bind(this._handler)(
        args.start,
        args.messageBoxCount
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxWrapUpList_result({success: result});
        output.writeMessageBegin("getMessageBoxWrapUpList", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxWrapUpList_result(err);
          output.writeMessageBegin("getMessageBoxWrapUpList", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxWrapUpList", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxWrapUpList(args.start, args.messageBoxCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxWrapUpList_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxWrapUpList", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxWrapUpList", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_leaveRoom (seqid, input, output) {
    const args = new TalkService_leaveRoom_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.leaveRoom.length === 2) {
      Promise.resolve(this._handler.leaveRoom.bind(this._handler)(
        args.reqSeq,
        args.roomId
      )).then(result => {
        const result_obj = new TalkService_leaveRoom_result({success: result});
        output.writeMessageBegin("leaveRoom", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_leaveRoom_result(err);
          output.writeMessageBegin("leaveRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("leaveRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.leaveRoom(args.reqSeq, args.roomId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_leaveRoom_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("leaveRoom", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("leaveRoom", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_unblockRecommendation (seqid, input, output) {
    const args = new TalkService_unblockRecommendation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.unblockRecommendation.length === 2) {
      Promise.resolve(this._handler.unblockRecommendation.bind(this._handler)(
        args.reqSeq,
        args.id
      )).then(result => {
        const result_obj = new TalkService_unblockRecommendation_result({success: result});
        output.writeMessageBegin("unblockRecommendation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_unblockRecommendation_result(err);
          output.writeMessageBegin("unblockRecommendation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unblockRecommendation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.unblockRecommendation(args.reqSeq, args.id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_unblockRecommendation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("unblockRecommendation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unblockRecommendation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findAndAddContactsByPhone (seqid, input, output) {
    const args = new TalkService_findAndAddContactsByPhone_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findAndAddContactsByPhone.length === 2) {
      Promise.resolve(this._handler.findAndAddContactsByPhone.bind(this._handler)(
        args.reqSeq,
        args.phones
      )).then(result => {
        const result_obj = new TalkService_findAndAddContactsByPhone_result({success: result});
        output.writeMessageBegin("findAndAddContactsByPhone", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findAndAddContactsByPhone_result(err);
          output.writeMessageBegin("findAndAddContactsByPhone", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactsByPhone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findAndAddContactsByPhone(args.reqSeq, args.phones, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findAndAddContactsByPhone_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findAndAddContactsByPhone", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactsByPhone", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getAuthQrcode (seqid, input, output) {
    const args = new TalkService_getAuthQrcode_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getAuthQrcode.length === 3) {
      Promise.resolve(this._handler.getAuthQrcode.bind(this._handler)(
        args.keepLoggedIn,
        args.systemName,
        args.returnCallbackUrl
      )).then(result => {
        const result_obj = new TalkService_getAuthQrcode_result({success: result});
        output.writeMessageBegin("getAuthQrcode", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getAuthQrcode_result(err);
          output.writeMessageBegin("getAuthQrcode", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAuthQrcode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getAuthQrcode(args.keepLoggedIn, args.systemName, args.returnCallbackUrl, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getAuthQrcode_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getAuthQrcode", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAuthQrcode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getE2EEGroupSharedKey (seqid, input, output) {
    const args = new TalkService_getE2EEGroupSharedKey_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getE2EEGroupSharedKey.length === 3) {
      Promise.resolve(this._handler.getE2EEGroupSharedKey.bind(this._handler)(
        args.version,
        args.chatMid,
        args.groupKeyId
      )).then(result => {
        const result_obj = new TalkService_getE2EEGroupSharedKey_result({success: result});
        output.writeMessageBegin("getE2EEGroupSharedKey", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getE2EEGroupSharedKey_result(err);
          output.writeMessageBegin("getE2EEGroupSharedKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getE2EEGroupSharedKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getE2EEGroupSharedKey(args.version, args.chatMid, args.groupKeyId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getE2EEGroupSharedKey_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getE2EEGroupSharedKey", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getE2EEGroupSharedKey", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxWrapUp (seqid, input, output) {
    const args = new TalkService_getMessageBoxWrapUp_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxWrapUp.length === 1) {
      Promise.resolve(this._handler.getMessageBoxWrapUp.bind(this._handler)(
        args.mid
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxWrapUp_result({success: result});
        output.writeMessageBegin("getMessageBoxWrapUp", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxWrapUp_result(err);
          output.writeMessageBegin("getMessageBoxWrapUp", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxWrapUp", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxWrapUp(args.mid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxWrapUp_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxWrapUp", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxWrapUp", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateSettingsAttributes (seqid, input, output) {
    const args = new TalkService_updateSettingsAttributes_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateSettingsAttributes.length === 3) {
      Promise.resolve(this._handler.updateSettingsAttributes.bind(this._handler)(
        args.reqSeq,
        args.attrBitset,
        args.settings
      )).then(result => {
        const result_obj = new TalkService_updateSettingsAttributes_result({success: result});
        output.writeMessageBegin("updateSettingsAttributes", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateSettingsAttributes_result(err);
          output.writeMessageBegin("updateSettingsAttributes", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateSettingsAttributes", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateSettingsAttributes(args.reqSeq, args.attrBitset, args.settings, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateSettingsAttributes_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateSettingsAttributes", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateSettingsAttributes", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_startVerification (seqid, input, output) {
    const args = new TalkService_startVerification_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.startVerification.length === 10) {
      Promise.resolve(this._handler.startVerification.bind(this._handler)(
        args.region,
        args.carrier,
        args.phone,
        args.udidHash,
        args.deviceInfo,
        args.networkCode,
        args.mid,
        args.locale,
        args.simInfo,
        args.oldUdidHash
      )).then(result => {
        const result_obj = new TalkService_startVerification_result({success: result});
        output.writeMessageBegin("startVerification", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_startVerification_result(err);
          output.writeMessageBegin("startVerification", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("startVerification", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.startVerification(args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.mid, args.locale, args.simInfo, args.oldUdidHash, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_startVerification_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("startVerification", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("startVerification", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_reportRooms (seqid, input, output) {
    const args = new TalkService_reportRooms_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.reportRooms.length === 2) {
      Promise.resolve(this._handler.reportRooms.bind(this._handler)(
        args.syncOpRevision,
        args.rooms
      )).then(result => {
        const result_obj = new TalkService_reportRooms_result({success: result});
        output.writeMessageBegin("reportRooms", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_reportRooms_result(err);
          output.writeMessageBegin("reportRooms", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportRooms", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.reportRooms(args.syncOpRevision, args.rooms, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_reportRooms_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("reportRooms", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("reportRooms", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateGroupPreferenceAttribute (seqid, input, output) {
    const args = new TalkService_updateGroupPreferenceAttribute_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateGroupPreferenceAttribute.length === 3) {
      Promise.resolve(this._handler.updateGroupPreferenceAttribute.bind(this._handler)(
        args.reqSeq,
        args.groupMid,
        args.updatedAttrs
      )).then(result => {
        const result_obj = new TalkService_updateGroupPreferenceAttribute_result({success: result});
        output.writeMessageBegin("updateGroupPreferenceAttribute", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateGroupPreferenceAttribute_result(err);
          output.writeMessageBegin("updateGroupPreferenceAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateGroupPreferenceAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateGroupPreferenceAttribute(args.reqSeq, args.groupMid, args.updatedAttrs, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateGroupPreferenceAttribute_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateGroupPreferenceAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateGroupPreferenceAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBoxWrapUpV2 (seqid, input, output) {
    const args = new TalkService_getMessageBoxWrapUpV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBoxWrapUpV2.length === 1) {
      Promise.resolve(this._handler.getMessageBoxWrapUpV2.bind(this._handler)(
        args.messageBoxId
      )).then(result => {
        const result_obj = new TalkService_getMessageBoxWrapUpV2_result({success: result});
        output.writeMessageBegin("getMessageBoxWrapUpV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBoxWrapUpV2_result(err);
          output.writeMessageBegin("getMessageBoxWrapUpV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxWrapUpV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBoxWrapUpV2(args.messageBoxId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBoxWrapUpV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBoxWrapUpV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBoxWrapUpV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getCompactRooms (seqid, input, output) {
    const args = new TalkService_getCompactRooms_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getCompactRooms.length === 1) {
      Promise.resolve(this._handler.getCompactRooms.bind(this._handler)(
        args.roomIds
      )).then(result => {
        const result_obj = new TalkService_getCompactRooms_result({success: result});
        output.writeMessageBegin("getCompactRooms", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getCompactRooms_result(err);
          output.writeMessageBegin("getCompactRooms", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactRooms", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getCompactRooms(args.roomIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getCompactRooms_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getCompactRooms", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getCompactRooms", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findAndAddContactByMetaTag (seqid, input, output) {
    const args = new TalkService_findAndAddContactByMetaTag_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findAndAddContactByMetaTag.length === 3) {
      Promise.resolve(this._handler.findAndAddContactByMetaTag.bind(this._handler)(
        args.reqSeq,
        args.userid,
        args.reference
      )).then(result => {
        const result_obj = new TalkService_findAndAddContactByMetaTag_result({success: result});
        output.writeMessageBegin("findAndAddContactByMetaTag", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findAndAddContactByMetaTag_result(err);
          output.writeMessageBegin("findAndAddContactByMetaTag", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactByMetaTag", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findAndAddContactByMetaTag(args.reqSeq, args.userid, args.reference, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findAndAddContactByMetaTag_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findAndAddContactByMetaTag", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactByMetaTag", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_storeUpdateProfileAttribute (seqid, input, output) {
    const args = new TalkService_storeUpdateProfileAttribute_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.storeUpdateProfileAttribute.length === 3) {
      Promise.resolve(this._handler.storeUpdateProfileAttribute.bind(this._handler)(
        args.seq,
        args.profileAttribute,
        args.value
      )).then(result => {
        const result_obj = new TalkService_storeUpdateProfileAttribute_result({success: result});
        output.writeMessageBegin("storeUpdateProfileAttribute", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_storeUpdateProfileAttribute_result(err);
          output.writeMessageBegin("storeUpdateProfileAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("storeUpdateProfileAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.storeUpdateProfileAttribute(args.seq, args.profileAttribute, args.value, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_storeUpdateProfileAttribute_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("storeUpdateProfileAttribute", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("storeUpdateProfileAttribute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_resendEmailConfirmation (seqid, input, output) {
    const args = new TalkService_resendEmailConfirmation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.resendEmailConfirmation.length === 1) {
      Promise.resolve(this._handler.resendEmailConfirmation.bind(this._handler)(
        args.verifier
      )).then(result => {
        const result_obj = new TalkService_resendEmailConfirmation_result({success: result});
        output.writeMessageBegin("resendEmailConfirmation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_resendEmailConfirmation_result(err);
          output.writeMessageBegin("resendEmailConfirmation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("resendEmailConfirmation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.resendEmailConfirmation(args.verifier, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_resendEmailConfirmation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("resendEmailConfirmation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("resendEmailConfirmation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_confirmEmail (seqid, input, output) {
    const args = new TalkService_confirmEmail_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.confirmEmail.length === 2) {
      Promise.resolve(this._handler.confirmEmail.bind(this._handler)(
        args.verifier,
        args.pinCode
      )).then(result => {
        const result_obj = new TalkService_confirmEmail_result({success: result});
        output.writeMessageBegin("confirmEmail", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_confirmEmail_result(err);
          output.writeMessageBegin("confirmEmail", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("confirmEmail", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.confirmEmail(args.verifier, args.pinCode, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_confirmEmail_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("confirmEmail", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("confirmEmail", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getExtendedProfile (seqid, input, output) {
    const args = new TalkService_getExtendedProfile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getExtendedProfile.length === 0) {
      Promise.resolve(this._handler.getExtendedProfile.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getExtendedProfile_result({success: result});
        output.writeMessageBegin("getExtendedProfile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getExtendedProfile_result(err);
          output.writeMessageBegin("getExtendedProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getExtendedProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getExtendedProfile((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getExtendedProfile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getExtendedProfile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getExtendedProfile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_isUseridAvailable (seqid, input, output) {
    const args = new TalkService_isUseridAvailable_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.isUseridAvailable.length === 1) {
      Promise.resolve(this._handler.isUseridAvailable.bind(this._handler)(
        args.userid
      )).then(result => {
        const result_obj = new TalkService_isUseridAvailable_result({success: result});
        output.writeMessageBegin("isUseridAvailable", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_isUseridAvailable_result(err);
          output.writeMessageBegin("isUseridAvailable", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("isUseridAvailable", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.isUseridAvailable(args.userid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_isUseridAvailable_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("isUseridAvailable", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("isUseridAvailable", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_notifyRegistrationComplete (seqid, input, output) {
    const args = new TalkService_notifyRegistrationComplete_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.notifyRegistrationComplete.length === 2) {
      Promise.resolve(this._handler.notifyRegistrationComplete.bind(this._handler)(
        args.udidHash,
        args.applicationTypeWithExtensions
      )).then(result => {
        const result_obj = new TalkService_notifyRegistrationComplete_result({success: result});
        output.writeMessageBegin("notifyRegistrationComplete", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_notifyRegistrationComplete_result(err);
          output.writeMessageBegin("notifyRegistrationComplete", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyRegistrationComplete", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.notifyRegistrationComplete(args.udidHash, args.applicationTypeWithExtensions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_notifyRegistrationComplete_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("notifyRegistrationComplete", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("notifyRegistrationComplete", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateDeviceInfo (seqid, input, output) {
    const args = new TalkService_updateDeviceInfo_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateDeviceInfo.length === 2) {
      Promise.resolve(this._handler.updateDeviceInfo.bind(this._handler)(
        args.deviceUid,
        args.deviceInfo
      )).then(result => {
        const result_obj = new TalkService_updateDeviceInfo_result({success: result});
        output.writeMessageBegin("updateDeviceInfo", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateDeviceInfo_result(err);
          output.writeMessageBegin("updateDeviceInfo", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateDeviceInfo", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateDeviceInfo(args.deviceUid, args.deviceInfo, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateDeviceInfo_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateDeviceInfo", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateDeviceInfo", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_blockRecommendation (seqid, input, output) {
    const args = new TalkService_blockRecommendation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.blockRecommendation.length === 2) {
      Promise.resolve(this._handler.blockRecommendation.bind(this._handler)(
        args.reqSeq,
        args.id
      )).then(result => {
        const result_obj = new TalkService_blockRecommendation_result({success: result});
        output.writeMessageBegin("blockRecommendation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_blockRecommendation_result(err);
          output.writeMessageBegin("blockRecommendation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("blockRecommendation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.blockRecommendation(args.reqSeq, args.id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_blockRecommendation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("blockRecommendation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("blockRecommendation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_rejectGroupInvitation (seqid, input, output) {
    const args = new TalkService_rejectGroupInvitation_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.rejectGroupInvitation.length === 2) {
      Promise.resolve(this._handler.rejectGroupInvitation.bind(this._handler)(
        args.reqSeq,
        args.groupId
      )).then(result => {
        const result_obj = new TalkService_rejectGroupInvitation_result({success: result});
        output.writeMessageBegin("rejectGroupInvitation", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_rejectGroupInvitation_result(err);
          output.writeMessageBegin("rejectGroupInvitation", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("rejectGroupInvitation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.rejectGroupInvitation(args.reqSeq, args.groupId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_rejectGroupInvitation_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("rejectGroupInvitation", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("rejectGroupInvitation", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_updateCustomModeSettings (seqid, input, output) {
    const args = new TalkService_updateCustomModeSettings_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.updateCustomModeSettings.length === 2) {
      Promise.resolve(this._handler.updateCustomModeSettings.bind(this._handler)(
        args.customMode,
        args.paramMap
      )).then(result => {
        const result_obj = new TalkService_updateCustomModeSettings_result({success: result});
        output.writeMessageBegin("updateCustomModeSettings", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_updateCustomModeSettings_result(err);
          output.writeMessageBegin("updateCustomModeSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateCustomModeSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.updateCustomModeSettings(args.customMode, args.paramMap, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_updateCustomModeSettings_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("updateCustomModeSettings", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("updateCustomModeSettings", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_createRoomV2 (seqid, input, output) {
    const args = new TalkService_createRoomV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.createRoomV2.length === 2) {
      Promise.resolve(this._handler.createRoomV2.bind(this._handler)(
        args.reqSeq,
        args.contactIds
      )).then(result => {
        const result_obj = new TalkService_createRoomV2_result({success: result});
        output.writeMessageBegin("createRoomV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_createRoomV2_result(err);
          output.writeMessageBegin("createRoomV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createRoomV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.createRoomV2(args.reqSeq, args.contactIds, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_createRoomV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("createRoomV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("createRoomV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_noop (seqid, input, output) {
    const args = new TalkService_noop_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.noop.length === 0) {
      Promise.resolve(this._handler.noop.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_noop_result({success: result});
        output.writeMessageBegin("noop", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_noop_result(err);
          output.writeMessageBegin("noop", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("noop", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.noop((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_noop_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("noop", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("noop", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_acquireEncryptedAccessToken (seqid, input, output) {
    const args = new TalkService_acquireEncryptedAccessToken_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.acquireEncryptedAccessToken.length === 1) {
      Promise.resolve(this._handler.acquireEncryptedAccessToken.bind(this._handler)(
        args.featureType
      )).then(result => {
        const result_obj = new TalkService_acquireEncryptedAccessToken_result({success: result});
        output.writeMessageBegin("acquireEncryptedAccessToken", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_acquireEncryptedAccessToken_result(err);
          output.writeMessageBegin("acquireEncryptedAccessToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acquireEncryptedAccessToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.acquireEncryptedAccessToken(args.featureType, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_acquireEncryptedAccessToken_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("acquireEncryptedAccessToken", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("acquireEncryptedAccessToken", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getE2EEPublicKeysEx (seqid, input, output) {
    const args = new TalkService_getE2EEPublicKeysEx_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getE2EEPublicKeysEx.length === 1) {
      Promise.resolve(this._handler.getE2EEPublicKeysEx.bind(this._handler)(
        args.ignoreE2EEStatus
      )).then(result => {
        const result_obj = new TalkService_getE2EEPublicKeysEx_result({success: result});
        output.writeMessageBegin("getE2EEPublicKeysEx", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getE2EEPublicKeysEx_result(err);
          output.writeMessageBegin("getE2EEPublicKeysEx", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getE2EEPublicKeysEx", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getE2EEPublicKeysEx(args.ignoreE2EEStatus, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getE2EEPublicKeysEx_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getE2EEPublicKeysEx", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getE2EEPublicKeysEx", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_syncContacts (seqid, input, output) {
    const args = new TalkService_syncContacts_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.syncContacts.length === 2) {
      Promise.resolve(this._handler.syncContacts.bind(this._handler)(
        args.reqSeq,
        args.localContacts
      )).then(result => {
        const result_obj = new TalkService_syncContacts_result({success: result});
        output.writeMessageBegin("syncContacts", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_syncContacts_result(err);
          output.writeMessageBegin("syncContacts", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("syncContacts", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.syncContacts(args.reqSeq, args.localContacts, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_syncContacts_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("syncContacts", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("syncContacts", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findAndAddContactsByMid (seqid, input, output) {
    const args = new TalkService_findAndAddContactsByMid_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findAndAddContactsByMid.length === 4) {
      Promise.resolve(this._handler.findAndAddContactsByMid.bind(this._handler)(
        args.reqSeq,
        args.mid,
        args.type,
        args.reference
      )).then(result => {
        const result_obj = new TalkService_findAndAddContactsByMid_result({success: result});
        output.writeMessageBegin("findAndAddContactsByMid", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findAndAddContactsByMid_result(err);
          output.writeMessageBegin("findAndAddContactsByMid", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactsByMid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findAndAddContactsByMid(args.reqSeq, args.mid, args.type, args.reference, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findAndAddContactsByMid_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findAndAddContactsByMid", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findAndAddContactsByMid", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_findGroupByTicketV2 (seqid, input, output) {
    const args = new TalkService_findGroupByTicketV2_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.findGroupByTicketV2.length === 1) {
      Promise.resolve(this._handler.findGroupByTicketV2.bind(this._handler)(
        args.ticketId
      )).then(result => {
        const result_obj = new TalkService_findGroupByTicketV2_result({success: result});
        output.writeMessageBegin("findGroupByTicketV2", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_findGroupByTicketV2_result(err);
          output.writeMessageBegin("findGroupByTicketV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findGroupByTicketV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.findGroupByTicketV2(args.ticketId, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_findGroupByTicketV2_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("findGroupByTicketV2", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("findGroupByTicketV2", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_removeFriendRequest (seqid, input, output) {
    const args = new TalkService_removeFriendRequest_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.removeFriendRequest.length === 2) {
      Promise.resolve(this._handler.removeFriendRequest.bind(this._handler)(
        args.direction,
        args.midOrEMid
      )).then(result => {
        const result_obj = new TalkService_removeFriendRequest_result({success: result});
        output.writeMessageBegin("removeFriendRequest", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_removeFriendRequest_result(err);
          output.writeMessageBegin("removeFriendRequest", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeFriendRequest", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.removeFriendRequest(args.direction, args.midOrEMid, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_removeFriendRequest_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("removeFriendRequest", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("removeFriendRequest", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_verifyPhoneNumber (seqid, input, output) {
    const args = new TalkService_verifyPhoneNumber_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.verifyPhoneNumber.length === 5) {
      Promise.resolve(this._handler.verifyPhoneNumber.bind(this._handler)(
        args.sessionId,
        args.pinCode,
        args.udidHash,
        args.migrationPincodeSessionId,
        args.oldUdidHash
      )).then(result => {
        const result_obj = new TalkService_verifyPhoneNumber_result({success: result});
        output.writeMessageBegin("verifyPhoneNumber", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_verifyPhoneNumber_result(err);
          output.writeMessageBegin("verifyPhoneNumber", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyPhoneNumber", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.verifyPhoneNumber(args.sessionId, args.pinCode, args.udidHash, args.migrationPincodeSessionId, args.oldUdidHash, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_verifyPhoneNumber_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("verifyPhoneNumber", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("verifyPhoneNumber", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_setNotificationsEnabled (seqid, input, output) {
    const args = new TalkService_setNotificationsEnabled_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.setNotificationsEnabled.length === 4) {
      Promise.resolve(this._handler.setNotificationsEnabled.bind(this._handler)(
        args.reqSeq,
        args.type,
        args.target,
        args.enablement
      )).then(result => {
        const result_obj = new TalkService_setNotificationsEnabled_result({success: result});
        output.writeMessageBegin("setNotificationsEnabled", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_setNotificationsEnabled_result(err);
          output.writeMessageBegin("setNotificationsEnabled", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("setNotificationsEnabled", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.setNotificationsEnabled(args.reqSeq, args.type, args.target, args.enablement, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_setNotificationsEnabled_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("setNotificationsEnabled", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("setNotificationsEnabled", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getAllContactIds (seqid, input, output) {
    const args = new TalkService_getAllContactIds_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getAllContactIds.length === 0) {
      Promise.resolve(this._handler.getAllContactIds.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getAllContactIds_result({success: result});
        output.writeMessageBegin("getAllContactIds", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getAllContactIds_result(err);
          output.writeMessageBegin("getAllContactIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAllContactIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getAllContactIds((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getAllContactIds_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getAllContactIds", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getAllContactIds", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getIdentityIdentifier (seqid, input, output) {
    const args = new TalkService_getIdentityIdentifier_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getIdentityIdentifier.length === 0) {
      Promise.resolve(this._handler.getIdentityIdentifier.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_getIdentityIdentifier_result({success: result});
        output.writeMessageBegin("getIdentityIdentifier", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getIdentityIdentifier_result(err);
          output.writeMessageBegin("getIdentityIdentifier", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getIdentityIdentifier", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getIdentityIdentifier((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getIdentityIdentifier_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getIdentityIdentifier", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getIdentityIdentifier", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sendDummyPush (seqid, input, output) {
    const args = new TalkService_sendDummyPush_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sendDummyPush.length === 0) {
      Promise.resolve(this._handler.sendDummyPush.bind(this._handler)(
      )).then(result => {
        const result_obj = new TalkService_sendDummyPush_result({success: result});
        output.writeMessageBegin("sendDummyPush", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_sendDummyPush_result(err);
          output.writeMessageBegin("sendDummyPush", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendDummyPush", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sendDummyPush((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_sendDummyPush_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sendDummyPush", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sendDummyPush", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_inviteFriendsBySms (seqid, input, output) {
    const args = new TalkService_inviteFriendsBySms_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.inviteFriendsBySms.length === 1) {
      Promise.resolve(this._handler.inviteFriendsBySms.bind(this._handler)(
        args.phoneNumberList
      )).then(result => {
        const result_obj = new TalkService_inviteFriendsBySms_result({success: result});
        output.writeMessageBegin("inviteFriendsBySms", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_inviteFriendsBySms_result(err);
          output.writeMessageBegin("inviteFriendsBySms", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("inviteFriendsBySms", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.inviteFriendsBySms(args.phoneNumberList, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_inviteFriendsBySms_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("inviteFriendsBySms", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("inviteFriendsBySms", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_getMessageBox (seqid, input, output) {
    const args = new TalkService_getMessageBox_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.getMessageBox.length === 3) {
      Promise.resolve(this._handler.getMessageBox.bind(this._handler)(
        args.channelId,
        args.messageBoxId,
        args.lastMessagesCount
      )).then(result => {
        const result_obj = new TalkService_getMessageBox_result({success: result});
        output.writeMessageBegin("getMessageBox", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TalkException) {
          result = new TalkService_getMessageBox_result(err);
          output.writeMessageBegin("getMessageBox", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBox", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.getMessageBox(args.channelId, args.messageBoxId, args.lastMessagesCount, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TalkException) {
          result_obj = new TalkService_getMessageBox_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("getMessageBox", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("getMessageBox", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
};
